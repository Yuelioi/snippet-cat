/******/ (() => {
    // webpackBootstrap
    /******/ var __webpack_modules__ = [
        /* 0 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          var desc = Object.getOwnPropertyDescriptor(m, k);
                          if (
                              !desc ||
                              ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
                          ) {
                              desc = {
                                  enumerable: true,
                                  get: function () {
                                      return m[k];
                                  }
                              };
                          }
                          Object.defineProperty(o, k2, desc);
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, 'default', { enumerable: true, value: v });
                      }
                    : function (o, v) {
                          o['default'] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.activate = void 0;
            const vscode = __importStar(__webpack_require__(1));
            const SnippetsProvider_1 = __webpack_require__(2);
            const TOCProvider_1 = __webpack_require__(182);
            const package_nls_en_json_1 = __importDefault(__webpack_require__(184));
            const package_nls_jp_json_1 = __importDefault(__webpack_require__(185));
            const localeTableKey = vscode.env.language;
            const localeTable = Object.assign(
                package_nls_en_json_1.default,
                {
                    ja: package_nls_jp_json_1.default
                }[localeTableKey] || {}
            );
            const localeString = (key) => localeTable[key] || key;
            const localeMap = (key) => localeString(key);
            function activate(context) {
                const snippetProvider = new SnippetsProvider_1.SnippetsProvider(context);
                const tocProvider = new TOCProvider_1.TOCProvider(context);
                context.subscriptions.push(
                    // 监听窗口变化
                    vscode.window.onDidChangeActiveTextEditor(() => {
                        tocProvider.refresh();
                    }),
                    vscode.workspace.onDidChangeConfiguration(() => {
                        snippetProvider.init();
                    }),
                    vscode.commands.registerCommand(
                        'snippet-cat.saveToStock',
                        snippetProvider.saveToStock.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand('snippet-cat.main.click', (path) =>
                        snippetProvider.click(path)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.viewSwitch',
                        snippetProvider.viewSwitch.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.upload',
                        snippetProvider.upload.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.download',
                        snippetProvider.download.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.refresh',
                        snippetProvider.refresh.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.search',
                        snippetProvider.search.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.addStockPath',
                        snippetProvider.addStockPath.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.addGroup',
                        snippetProvider.addGroup.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.editGroup',
                        snippetProvider.editGroup.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.openGroup',
                        snippetProvider.openGroup.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.deleteGroup',
                        snippetProvider.deleteGroup.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.addSnippet',
                        snippetProvider.addSnippet.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.editSnippet',
                        snippetProvider.editSnippet.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.main.deleteSnippet',
                        snippetProvider.deleteSnippet.bind(snippetProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.outline.click',
                        tocProvider.click.bind(tocProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.outline.copy',
                        tocProvider.copy.bind(tocProvider)
                    ),
                    vscode.commands.registerCommand(
                        'snippet-cat.outline.refresh',
                        tocProvider.refresh.bind(tocProvider)
                    )
                );
            }
            exports.activate = activate;

            /***/
        },
        /* 1 */
        /***/ (module) => {
            'use strict';
            module.exports = require('vscode');

            /***/
        },
        /* 2 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          var desc = Object.getOwnPropertyDescriptor(m, k);
                          if (
                              !desc ||
                              ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
                          ) {
                              desc = {
                                  enumerable: true,
                                  get: function () {
                                      return m[k];
                                  }
                              };
                          }
                          Object.defineProperty(o, k2, desc);
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, 'default', { enumerable: true, value: v });
                      }
                    : function (o, v) {
                          o['default'] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.SnippetsProvider = void 0;
            const vscode = __importStar(__webpack_require__(1));
            const fs = __importStar(__webpack_require__(3));
            const path = __importStar(__webpack_require__(4));
            const utils = __importStar(__webpack_require__(5));
            const syncs = __importStar(__webpack_require__(47));
            class SnippetsProvider {
                constructor(context) {
                    this.dropMimeTypes = ['application/vnd.code.tree.snippet-cat-view'];
                    this.dragMimeTypes = ['text/uri-list'];
                    this._onDidChangeTreeData = new vscode.EventEmitter();
                    this.onDidChangeTreeData = this._onDidChangeTreeData.event;
                    this.stockPath = '';
                    this.hasRoot = false;
                    const snippetTreeView = vscode.window.createTreeView('snippet-cat-view', {
                        treeDataProvider: this,
                        showCollapseAll: true,
                        canSelectMany: true,
                        dragAndDropController: this
                    });
                    context.subscriptions.push(snippetTreeView);
                    this.view = snippetTreeView;
                    this.treeExpandList = [];
                    this.viewTreeMode = true;
                    this.init();
                }
                getChildren(element) {
                    this.checkRoot();
                    return Promise.resolve(
                        this._getChildren(element ? element.fullPath : this.stockPath)
                    );
                }
                getTreeItem(element) {
                    this.checkRoot();
                    const treeItem = this._getTreeItem(element.fullPath);
                    return treeItem;
                }
                // getParent(element:SnippetElement){
                //   return this._getTreeElement(path.dirname(element.fullPath));
                // }
                _getTreeItem(fullPath) {
                    const treeElement = this._getTreeElement(fullPath);
                    return new SnippetItem(
                        treeElement,
                        treeElement.basename,
                        treeElement.isDir
                            ? vscode.TreeItemCollapsibleState.Collapsed
                            : vscode.TreeItemCollapsibleState.None
                    );
                }
                _getTreeElement(fullPath) {
                    return new SnippetElement(fullPath);
                }
                // Element 列表
                _getChildren(folderPath) {
                    const resFolder = fs.readdirSync(folderPath);
                    const tree = [];
                    const _this = this;
                    let folderList = resFolder.filter(
                        (fileName) =>
                            fs.lstatSync(path.resolve(folderPath, fileName)).isDirectory() &&
                            !fileName.startsWith('.')
                    );
                    let fileList = resFolder.filter(
                        (fileName) => !folderList.includes(fileName) && !fileName.startsWith('.')
                    );
                    folderList.forEach(function (fileName) {
                        const fullPath = path.resolve(folderPath, fileName);
                        if (_this.viewTreeMode) {
                            tree.push(_this._getTreeElement(fullPath));
                        }
                        _this._getChildren(fullPath);
                    });
                    fileList.forEach(function (fileName) {
                        const fullPath = path.resolve(folderPath, fileName);
                        if (_this.viewTreeMode) {
                            tree.push(_this._getTreeElement(fullPath));
                        } else {
                            _this.treeExpandList.push(_this._getTreeElement(fullPath));
                        }
                    });
                    if (_this.viewTreeMode) {
                        return tree;
                    } else {
                        return this.treeExpandList.sort((el1, el2) =>
                            path.extname(el1.fullPath).toUpperCase() <
                            path.extname(el2.fullPath).toUpperCase()
                                ? -1
                                : 1
                        );
                    }
                }
                // Drag and drop
                async handleDrop(target, sources, token) {
                    const transferItem = sources.get('application/vnd.code.tree.snippet-cat-view');
                    if (!transferItem) {
                        return;
                    }
                    const srcTreeElemtents = transferItem.value;
                    srcTreeElemtents.forEach((el) => {
                        fs.rename(
                            el.fullPath,
                            path.join(target.dirPath, el.basename),
                            function (err) {
                                if (err) {
                                    throw err;
                                }
                            }
                        );
                    });
                    this.refresh();
                }
                async handleDrag(source, treeDataTransfer, token) {
                    treeDataTransfer.set(
                        'application/vnd.code.tree.snippet-cat-view',
                        new vscode.DataTransferItem(source)
                    );
                }
                setTreeView(element) {
                    this.treeExpandList = element;
                }
                async saveToStock() {
                    let editor = vscode.window.activeTextEditor;
                    if (editor) {
                        const selText = editor.document.getText(editor.selection);
                        const languageId = editor.document.languageId;
                        Promise.resolve(utils.generateDescription(languageId, selText)).then(
                            (data) => {
                                let { ext, content } = data;
                                const targetPath = path.join(
                                    this.stockPath,
                                    languageId + '.' + ext
                                );
                                utils.addContentToFile(targetPath, '\n' + content + '\n', this);
                                vscode.window.showInformationMessage('已添加到:' + targetPath);
                            }
                        );
                    }
                }
                async addStockPath() {
                    let recordConfig = this.snippetCatConfig.get('stockPath');
                    const options = {
                        canSelectMany: false,
                        openLabel: 'Select',
                        canSelectFiles: false,
                        canSelectFolders: true
                    };
                    await vscode.window.showOpenDialog(options).then((fileUri) => {
                        if (fileUri && fileUri[0]) {
                            this.snippetCatConfig
                                .update(
                                    'stockPath',
                                    fileUri[0].fsPath,
                                    vscode.ConfigurationTarget.Global
                                )
                                .then(() => {});
                            this.refresh();
                        } else {
                            vscode.window.showInformationMessage('用户取消设置');
                        }
                    });
                }
                async refresh() {
                    this._onDidChangeTreeData.fire(undefined);
                }
                init() {
                    this.snippetCatConfig = vscode.workspace.getConfiguration('snippet-cat');
                    this.stockPath = this.snippetCatConfig.get('stockPath');
                    var stat = fs.statSync(path.join(__dirname, 'content'));
                    if (!stat.isDirectory()) {
                        this.hasRoot = false;
                        throw new Error('请先添加根目录');
                    } else {
                        this.hasRoot = true;
                    }
                }
                viewSwitch() {
                    this.viewTreeMode = !this.viewTreeMode;
                    this.treeExpandList = [];
                    this.refresh();
                }
                click(filePath) {
                    var openPath = vscode.Uri.parse('file:///' + filePath.split(`\\`).join(`/`)); //A request file path
                    vscode.workspace.openTextDocument(openPath).then((doc) => {
                        vscode.window.showTextDocument(doc);
                    });
                }
                // TODO
                search() {
                    this.view.reveal();
                    this.view.reveal(this._getTreeElement('E:\\Project\\Snippet Cat\\PHP\\1.PHP'), {
                        select: true,
                        focus: true,
                        expand: true
                    });
                    // this.treeExpandList.reveal(element, { select: true, focus: true, expand: true });
                }
                checkRoot() {
                    if (!this.hasRoot) {
                        throw new Error('请先添加根目录');
                    }
                }
                async upload() {
                    syncs.syncCloud(this, '上传', '云端', 0, this.snippetCatConfig);
                }
                async download() {
                    syncs.syncCloud(this, '下载', '本地', 1, this.snippetCatConfig);
                }
                openGroup(e) {
                    utils.revealFileInOS(e.fullPath);
                }
                addGroup(e) {
                    this.checkRoot();
                    let folderPath = e ? e.fullPath : this.stockPath;
                    let iter = this.handleSnippets('请输入文件夹名', '', [0, 0]);
                    iter.next().then(
                        (data) => {
                            iter.next([fs.mkdir, path.join(folderPath, data.value)]);
                        },
                        (err) => console.log(err)
                    );
                }
                editGroup(e) {
                    let iter = this.handleSnippets('请输入文件夹名', e.basename, [
                        0,
                        e.basename.length
                    ]);
                    iter.next().then(
                        (data) => {
                            iter.next([
                                fs.rename,
                                e.fullPath,
                                path.join(e.fullPath, '..', data.value)
                            ]);
                        },
                        (err) => console.log(err)
                    );
                }
                deleteGroup(e) {
                    let iter = this.handleSnippets('确认删除', '确认', [0, 2]);
                    iter.next().then(
                        (data) => {
                            iter.next([fs.rmSync, e.fullPath, { recursive: true, force: true }]);
                        },
                        (err) => console.log(err)
                    );
                }
                async *handleSnippets(...args) {
                    let [placeHolder, value, valueSelection] = args;
                    let key = await vscode.window.showInputBox({
                        placeHolder: placeHolder,
                        value: value,
                        valueSelection: valueSelection
                    });
                    if (key !== undefined) {
                        let [fun, ...args2] = yield key;
                        fun(...args2, (err) => {
                            if (err) {
                                vscode.window.showErrorMessage(err.toString());
                            }
                        });
                        this.refresh();
                    } else {
                        throw new Error('用户未确认');
                    }
                }
                async addSnippet(e) {
                    let lastExt = this.snippetCatConfig.get('lastFileExt');
                    let iter = this.handleSnippets('请输入文件名', '.' + lastExt, [0, 0]);
                    iter.next().then(
                        (data) => {
                            let ext = data.value.split('.');
                            ext = ext.length > 1 ? ext[1] : '';
                            iter.next([fs.writeFileSync, path.join(e.fullPath, data.value), '']);
                            this.snippetCatConfig
                                .update('lastFileExt', ext, vscode.ConfigurationTarget.Global)
                                .then(() => {});
                        },
                        (err) => console.log(err)
                    );
                }
                deleteSnippet(e) {
                    let iter = this.handleSnippets('确认删除', '确认', [0, 2]);
                    iter.next().then(
                        (data) => {
                            iter.next([fs.rmSync, e.fullPath, { recursive: true, force: true }]);
                        },
                        (err) => console.log(err)
                    );
                }
                editSnippet(e) {
                    let ext = path.extname(e.fullPath);
                    let endPos = e.basename.length - ext.length;
                    let iter = this.handleSnippets('请输入新文件名', e.basename, [0, endPos]);
                    iter.next().then(
                        (data) => {
                            iter.next([
                                fs.rename,
                                e.fullPath,
                                path.join(e.fullPath, '..', data.value)
                            ]);
                        },
                        (err) => console.log(err)
                    );
                }
            }
            exports.SnippetsProvider = SnippetsProvider;
            class SnippetElement {
                constructor(fullPath) {
                    this.fullPath = fullPath;
                    this.basename = path.basename(fullPath);
                    this.isDir = fs.lstatSync(fullPath).isDirectory();
                    this.dirPath = this.isDir ? fullPath : path.dirname(fullPath);
                }
            }
            class SnippetItem extends vscode.TreeItem {
                constructor(element, label, collapsibleState) {
                    super(label, collapsibleState);
                    this.label = element.basename;
                    this.id = this.tooltip = element.fullPath;
                    this.contextValue = element.isDir ? 'Group' : 'Snippet';
                    let icon = 'folder';
                    if (this.contextValue === 'Snippet') {
                        this.command = {
                            title: 'Item Command',
                            command: 'snippet-cat.main.click',
                            arguments: [element.fullPath]
                        };
                        icon = path.extname(element.fullPath).replace('.', '');
                        if (
                            !fs.existsSync(
                                path.join(
                                    __filename,
                                    '..',
                                    '..',
                                    'media',
                                    'icons',
                                    'files',
                                    'dark',
                                    `${icon}.svg`
                                )
                            )
                        ) {
                            icon = 'file';
                        }
                    }
                    this.iconPath = {
                        light: path.join(
                            __filename,
                            '..',
                            '..',
                            'media',
                            'icons',
                            'files',
                            'light',
                            `${icon}.svg`
                        ),
                        dark: path.join(
                            __filename,
                            '..',
                            '..',
                            'media',
                            'icons',
                            'files',
                            'dark',
                            `${icon}.svg`
                        )
                    };
                }
            }

            /***/
        },
        /* 3 */
        /***/ (module) => {
            'use strict';
            module.exports = require('fs');

            /***/
        },
        /* 4 */
        /***/ (module) => {
            'use strict';
            module.exports = require('path');

            /***/
        },
        /* 5 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          var desc = Object.getOwnPropertyDescriptor(m, k);
                          if (
                              !desc ||
                              ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
                          ) {
                              desc = {
                                  enumerable: true,
                                  get: function () {
                                      return m[k];
                                  }
                              };
                          }
                          Object.defineProperty(o, k2, desc);
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, 'default', { enumerable: true, value: v });
                      }
                    : function (o, v) {
                          o['default'] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.generateDescription =
                exports.addContentToFile =
                exports.recoveryStock =
                exports.getTimeStamp =
                exports.runCMD =
                exports.revealFileInOS =
                    void 0;
            const { execSync, spawn } = __webpack_require__(6);
            const fse = __webpack_require__(7);
            const fs = __webpack_require__(3);
            const path = __webpack_require__(4);
            const vscode = __importStar(__webpack_require__(1));
            /**
             * @description: 打开目标文件夹 并选择指定路径的文件
             * @tutorial: https://stackoverflow.com/questions/64320632/node-js-child-process-spawning-explorer-with-select-option-does-not-work-wi
             */
            function revealFileInOS(path) {
                spawn(`explorer`, [`/select,"${path}"`], { windowsVerbatimArguments: true });
            }
            exports.revealFileInOS = revealFileInOS;
            /**
             * @description:运行CMD命令
             * @param runPath :运行路径
             * @param cmd :指令列表
             */
            function runCMD(runPath, cmd, srcThis) {
                let cmdToProgress = cmd.split('|').join(' && ').replace('%time', getTimeStamp());
                try {
                    execSync(cmdToProgress, { cwd: runPath });
                    srcThis.refresh();
                } catch (e) {
                    vscode.window.showErrorMessage(e);
                }
                return;
            }
            exports.runCMD = runCMD;
            /**
             * @description : 获取时间戳
             * @returns :YYYYMMDDHHMMss (string)
             */
            function getTimeStamp() {
                var date = new Date();
                return (
                    date.getFullYear() +
                    ('0' + (date.getMonth() + 1)).slice(-2) +
                    ('0' + date.getDate()).slice(-2) +
                    ('0' + date.getHours()).slice(-2) +
                    ('0' + date.getMinutes()).slice(-2) +
                    ('0' + date.getSeconds()).slice(-2)
                );
            }
            exports.getTimeStamp = getTimeStamp;
            /**
             * @description: 备份文件
             * @param stockPath :储存文件根目录
             */
            function recoveryStock(stockPath) {
                const timeStamp = getTimeStamp();
                const tempFolder = path.join(stockPath, '..', timeStamp);
                const recoveryPath = path.join(stockPath, '.recovery');
                if (!fs.existsSync(recoveryPath)) {
                    fs.mkdirSync(recoveryPath);
                }
                try {
                    fse.copySync(stockPath, tempFolder);
                } catch (err) {
                    console.error(err);
                }
                fs.rmSync(path.join(tempFolder, '.recovery'), { recursive: true });
                fse.moveSync(tempFolder, path.join(recoveryPath, timeStamp));
            }
            exports.recoveryStock = recoveryStock;
            function addContentToFile(trgPath, content, srcThis) {
                fs.writeFile(
                    trgPath,
                    content,
                    {
                        encoding: 'utf8',
                        flag: 'a'
                    },
                    (err) => {
                        if (err) {
                            console.log(err);
                        } else {
                            srcThis.refresh();
                        }
                    }
                );
            }
            exports.addContentToFile = addContentToFile;
            async function generateDescription(languageId, selContent) {
                const languageList = __webpack_require__(46);
                let ext = 'txt';
                let content = '';
                if (Object.hasOwn(languageList, languageId)) {
                    const lanInfo = languageList[languageId];
                    ext = lanInfo['ext'];
                    if (ext !== 'txt' && ext !== 'md') {
                        const name =
                            (await vscode.window.showInputBox({
                                placeHolder: ``,
                                value: `未命名函数`,
                                valueSelection: [0, 5]
                            })) || '未命名函数';
                        const description =
                            (await vscode.window.showInputBox({
                                placeHolder: ``,
                                value: `暂无描述`,
                                valueSelection: [0, 4]
                            })) || '暂无描述';
                        if (lanInfo['comments-start']) {
                            content = `${lanInfo['comments-start']}\n${lanInfo['comments-split']} @start\n${lanInfo['comments-split']} @name:${name}\n${lanInfo['comments-split']} @description::${description}\n${lanInfo['comments-end']}`;
                        }
                        content += '\n' + selContent + '\n';
                        if (lanInfo['comments-oneline']) {
                            content += `${lanInfo['comments-oneline']} @end`;
                        } else {
                            content += `${lanInfo['comments-start']} @end ${lanInfo['comments-end']}`;
                        }
                    }
                }
                if (content === '') {
                    content = `${selContent}`;
                }
                return { ext, content };
            }
            exports.generateDescription = generateDescription;

            /***/
        },
        /* 6 */
        /***/ (module) => {
            'use strict';
            module.exports = require('child_process');

            /***/
        },
        /* 7 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            module.exports = {
                // Export promiseified graceful-fs:
                ...__webpack_require__(8),
                // Export extra methods:
                ...__webpack_require__(18),
                ...__webpack_require__(27),
                ...__webpack_require__(30),
                ...__webpack_require__(36),
                ...__webpack_require__(20),
                ...__webpack_require__(43),
                ...__webpack_require__(41),
                ...__webpack_require__(23),
                ...__webpack_require__(28)
            };

            /***/
        },
        /* 8 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            // This is adapted from https://github.com/normalize/mz
            // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
            const u = __webpack_require__(9).fromCallback;
            const fs = __webpack_require__(10);

            const api = [
                'access',
                'appendFile',
                'chmod',
                'chown',
                'close',
                'copyFile',
                'fchmod',
                'fchown',
                'fdatasync',
                'fstat',
                'fsync',
                'ftruncate',
                'futimes',
                'lchmod',
                'lchown',
                'link',
                'lstat',
                'mkdir',
                'mkdtemp',
                'open',
                'opendir',
                'readdir',
                'readFile',
                'readlink',
                'realpath',
                'rename',
                'rm',
                'rmdir',
                'stat',
                'symlink',
                'truncate',
                'unlink',
                'utimes',
                'writeFile'
            ].filter((key) => {
                // Some commands are not available on some systems. Ex:
                // fs.opendir was added in Node.js v12.12.0
                // fs.rm was added in Node.js v14.14.0
                // fs.lchown is not available on at least some Linux
                return typeof fs[key] === 'function';
            });

            // Export cloned fs:
            Object.assign(exports, fs);

            // Universalify async methods:
            api.forEach((method) => {
                exports[method] = u(fs[method]);
            });

            // We differ from mz/fs in that we still ship the old, broken, fs.exists()
            // since we are a drop-in replacement for the native module
            exports.exists = function (filename, callback) {
                if (typeof callback === 'function') {
                    return fs.exists(filename, callback);
                }
                return new Promise((resolve) => {
                    return fs.exists(filename, resolve);
                });
            };

            // fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args

            exports.read = function (fd, buffer, offset, length, position, callback) {
                if (typeof callback === 'function') {
                    return fs.read(fd, buffer, offset, length, position, callback);
                }
                return new Promise((resolve, reject) => {
                    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
                        if (err) return reject(err);
                        resolve({ bytesRead, buffer });
                    });
                });
            };

            // Function signature can be
            // fs.write(fd, buffer[, offset[, length[, position]]], callback)
            // OR
            // fs.write(fd, string[, position[, encoding]], callback)
            // We need to handle both cases, so we use ...args
            exports.write = function (fd, buffer, ...args) {
                if (typeof args[args.length - 1] === 'function') {
                    return fs.write(fd, buffer, ...args);
                }

                return new Promise((resolve, reject) => {
                    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
                        if (err) return reject(err);
                        resolve({ bytesWritten, buffer });
                    });
                });
            };

            // fs.writev only available in Node v12.9.0+
            if (typeof fs.writev === 'function') {
                // Function signature is
                // s.writev(fd, buffers[, position], callback)
                // We need to handle the optional arg, so we use ...args
                exports.writev = function (fd, buffers, ...args) {
                    if (typeof args[args.length - 1] === 'function') {
                        return fs.writev(fd, buffers, ...args);
                    }

                    return new Promise((resolve, reject) => {
                        fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
                            if (err) return reject(err);
                            resolve({ bytesWritten, buffers });
                        });
                    });
                };
            }

            // fs.realpath.native sometimes not available if fs is monkey-patched
            if (typeof fs.realpath.native === 'function') {
                exports.realpath.native = u(fs.realpath.native);
            } else {
                process.emitWarning(
                    'fs.realpath.native is not a function. Is fs being monkey-patched?',
                    'Warning',
                    'fs-extra-WARN0003'
                );
            }

            /***/
        },
        /* 9 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            exports.fromCallback = function (fn) {
                return Object.defineProperty(
                    function (...args) {
                        if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
                        else {
                            return new Promise((resolve, reject) => {
                                fn.call(this, ...args, (err, res) =>
                                    err != null ? reject(err) : resolve(res)
                                );
                            });
                        }
                    },
                    'name',
                    { value: fn.name }
                );
            };

            exports.fromPromise = function (fn) {
                return Object.defineProperty(
                    function (...args) {
                        const cb = args[args.length - 1];
                        if (typeof cb !== 'function') return fn.apply(this, args);
                        else fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
                    },
                    'name',
                    { value: fn.name }
                );
            };

            /***/
        },
        /* 10 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var fs = __webpack_require__(3);
            var polyfills = __webpack_require__(11);
            var legacy = __webpack_require__(13);
            var clone = __webpack_require__(15);

            var util = __webpack_require__(16);

            /* istanbul ignore next - node 0.x polyfill */
            var gracefulQueue;
            var previousSymbol;

            /* istanbul ignore else - node 0.x polyfill */
            if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
                gracefulQueue = Symbol.for('graceful-fs.queue');
                // This is used in testing by future versions
                previousSymbol = Symbol.for('graceful-fs.previous');
            } else {
                gracefulQueue = '___graceful-fs.queue';
                previousSymbol = '___graceful-fs.previous';
            }

            function noop() {}

            function publishQueue(context, queue) {
                Object.defineProperty(context, gracefulQueue, {
                    get: function () {
                        return queue;
                    }
                });
            }

            var debug = noop;
            if (util.debuglog) debug = util.debuglog('gfs4');
            else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
                debug = function () {
                    var m = util.format.apply(util, arguments);
                    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
                    console.error(m);
                };

            // Once time initialization
            if (!fs[gracefulQueue]) {
                // This queue can be shared by multiple loaded instances
                var queue = global[gracefulQueue] || [];
                publishQueue(fs, queue);

                // Patch fs.close/closeSync to shared queue version, because we need
                // to retry() whenever a close happens *anywhere* in the program.
                // This is essential when multiple graceful-fs instances are
                // in play at the same time.
                fs.close = (function (fs$close) {
                    function close(fd, cb) {
                        return fs$close.call(fs, fd, function (err) {
                            // This function uses the graceful-fs shared queue
                            if (!err) {
                                resetQueue();
                            }

                            if (typeof cb === 'function') cb.apply(this, arguments);
                        });
                    }

                    Object.defineProperty(close, previousSymbol, {
                        value: fs$close
                    });
                    return close;
                })(fs.close);

                fs.closeSync = (function (fs$closeSync) {
                    function closeSync(fd) {
                        // This function uses the graceful-fs shared queue
                        fs$closeSync.apply(fs, arguments);
                        resetQueue();
                    }

                    Object.defineProperty(closeSync, previousSymbol, {
                        value: fs$closeSync
                    });
                    return closeSync;
                })(fs.closeSync);

                if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
                    process.on('exit', function () {
                        debug(fs[gracefulQueue]);
                        __webpack_require__(17).equal(fs[gracefulQueue].length, 0);
                    });
                }
            }

            if (!global[gracefulQueue]) {
                publishQueue(global, fs[gracefulQueue]);
            }

            module.exports = patch(clone(fs));
            if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
                module.exports = patch(fs);
                fs.__patched = true;
            }

            function patch(fs) {
                // Everything that references the open() function needs to be in here
                polyfills(fs);
                fs.gracefulify = patch;

                fs.createReadStream = createReadStream;
                fs.createWriteStream = createWriteStream;
                var fs$readFile = fs.readFile;
                fs.readFile = readFile;
                function readFile(path, options, cb) {
                    if (typeof options === 'function') (cb = options), (options = null);

                    return go$readFile(path, options, cb);

                    function go$readFile(path, options, cb, startTime) {
                        return fs$readFile(path, options, function (err) {
                            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                                enqueue([
                                    go$readFile,
                                    [path, options, cb],
                                    err,
                                    startTime || Date.now(),
                                    Date.now()
                                ]);
                            else {
                                if (typeof cb === 'function') cb.apply(this, arguments);
                            }
                        });
                    }
                }

                var fs$writeFile = fs.writeFile;
                fs.writeFile = writeFile;
                function writeFile(path, data, options, cb) {
                    if (typeof options === 'function') (cb = options), (options = null);

                    return go$writeFile(path, data, options, cb);

                    function go$writeFile(path, data, options, cb, startTime) {
                        return fs$writeFile(path, data, options, function (err) {
                            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                                enqueue([
                                    go$writeFile,
                                    [path, data, options, cb],
                                    err,
                                    startTime || Date.now(),
                                    Date.now()
                                ]);
                            else {
                                if (typeof cb === 'function') cb.apply(this, arguments);
                            }
                        });
                    }
                }

                var fs$appendFile = fs.appendFile;
                if (fs$appendFile) fs.appendFile = appendFile;
                function appendFile(path, data, options, cb) {
                    if (typeof options === 'function') (cb = options), (options = null);

                    return go$appendFile(path, data, options, cb);

                    function go$appendFile(path, data, options, cb, startTime) {
                        return fs$appendFile(path, data, options, function (err) {
                            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                                enqueue([
                                    go$appendFile,
                                    [path, data, options, cb],
                                    err,
                                    startTime || Date.now(),
                                    Date.now()
                                ]);
                            else {
                                if (typeof cb === 'function') cb.apply(this, arguments);
                            }
                        });
                    }
                }

                var fs$copyFile = fs.copyFile;
                if (fs$copyFile) fs.copyFile = copyFile;
                function copyFile(src, dest, flags, cb) {
                    if (typeof flags === 'function') {
                        cb = flags;
                        flags = 0;
                    }
                    return go$copyFile(src, dest, flags, cb);

                    function go$copyFile(src, dest, flags, cb, startTime) {
                        return fs$copyFile(src, dest, flags, function (err) {
                            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                                enqueue([
                                    go$copyFile,
                                    [src, dest, flags, cb],
                                    err,
                                    startTime || Date.now(),
                                    Date.now()
                                ]);
                            else {
                                if (typeof cb === 'function') cb.apply(this, arguments);
                            }
                        });
                    }
                }

                var fs$readdir = fs.readdir;
                fs.readdir = readdir;
                var noReaddirOptionVersions = /^v[0-5]\./;
                function readdir(path, options, cb) {
                    if (typeof options === 'function') (cb = options), (options = null);

                    var go$readdir = noReaddirOptionVersions.test(process.version)
                        ? function go$readdir(path, options, cb, startTime) {
                              return fs$readdir(
                                  path,
                                  fs$readdirCallback(path, options, cb, startTime)
                              );
                          }
                        : function go$readdir(path, options, cb, startTime) {
                              return fs$readdir(
                                  path,
                                  options,
                                  fs$readdirCallback(path, options, cb, startTime)
                              );
                          };

                    return go$readdir(path, options, cb);

                    function fs$readdirCallback(path, options, cb, startTime) {
                        return function (err, files) {
                            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                                enqueue([
                                    go$readdir,
                                    [path, options, cb],
                                    err,
                                    startTime || Date.now(),
                                    Date.now()
                                ]);
                            else {
                                if (files && files.sort) files.sort();

                                if (typeof cb === 'function') cb.call(this, err, files);
                            }
                        };
                    }
                }

                if (process.version.substr(0, 4) === 'v0.8') {
                    var legStreams = legacy(fs);
                    ReadStream = legStreams.ReadStream;
                    WriteStream = legStreams.WriteStream;
                }

                var fs$ReadStream = fs.ReadStream;
                if (fs$ReadStream) {
                    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
                    ReadStream.prototype.open = ReadStream$open;
                }

                var fs$WriteStream = fs.WriteStream;
                if (fs$WriteStream) {
                    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
                    WriteStream.prototype.open = WriteStream$open;
                }

                Object.defineProperty(fs, 'ReadStream', {
                    get: function () {
                        return ReadStream;
                    },
                    set: function (val) {
                        ReadStream = val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(fs, 'WriteStream', {
                    get: function () {
                        return WriteStream;
                    },
                    set: function (val) {
                        WriteStream = val;
                    },
                    enumerable: true,
                    configurable: true
                });

                // legacy names
                var FileReadStream = ReadStream;
                Object.defineProperty(fs, 'FileReadStream', {
                    get: function () {
                        return FileReadStream;
                    },
                    set: function (val) {
                        FileReadStream = val;
                    },
                    enumerable: true,
                    configurable: true
                });
                var FileWriteStream = WriteStream;
                Object.defineProperty(fs, 'FileWriteStream', {
                    get: function () {
                        return FileWriteStream;
                    },
                    set: function (val) {
                        FileWriteStream = val;
                    },
                    enumerable: true,
                    configurable: true
                });

                function ReadStream(path, options) {
                    if (this instanceof ReadStream)
                        return fs$ReadStream.apply(this, arguments), this;
                    else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
                }

                function ReadStream$open() {
                    var that = this;
                    open(that.path, that.flags, that.mode, function (err, fd) {
                        if (err) {
                            if (that.autoClose) that.destroy();

                            that.emit('error', err);
                        } else {
                            that.fd = fd;
                            that.emit('open', fd);
                            that.read();
                        }
                    });
                }

                function WriteStream(path, options) {
                    if (this instanceof WriteStream)
                        return fs$WriteStream.apply(this, arguments), this;
                    else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
                }

                function WriteStream$open() {
                    var that = this;
                    open(that.path, that.flags, that.mode, function (err, fd) {
                        if (err) {
                            that.destroy();
                            that.emit('error', err);
                        } else {
                            that.fd = fd;
                            that.emit('open', fd);
                        }
                    });
                }

                function createReadStream(path, options) {
                    return new fs.ReadStream(path, options);
                }

                function createWriteStream(path, options) {
                    return new fs.WriteStream(path, options);
                }

                var fs$open = fs.open;
                fs.open = open;
                function open(path, flags, mode, cb) {
                    if (typeof mode === 'function') (cb = mode), (mode = null);

                    return go$open(path, flags, mode, cb);

                    function go$open(path, flags, mode, cb, startTime) {
                        return fs$open(path, flags, mode, function (err, fd) {
                            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                                enqueue([
                                    go$open,
                                    [path, flags, mode, cb],
                                    err,
                                    startTime || Date.now(),
                                    Date.now()
                                ]);
                            else {
                                if (typeof cb === 'function') cb.apply(this, arguments);
                            }
                        });
                    }
                }

                return fs;
            }

            function enqueue(elem) {
                debug('ENQUEUE', elem[0].name, elem[1]);
                fs[gracefulQueue].push(elem);
                retry();
            }

            // keep track of the timeout between retry() calls
            var retryTimer;

            // reset the startTime and lastTime to now
            // this resets the start of the 60 second overall timeout as well as the
            // delay between attempts so that we'll retry these jobs sooner
            function resetQueue() {
                var now = Date.now();
                for (var i = 0; i < fs[gracefulQueue].length; ++i) {
                    // entries that are only a length of 2 are from an older version, don't
                    // bother modifying those since they'll be retried anyway.
                    if (fs[gracefulQueue][i].length > 2) {
                        fs[gracefulQueue][i][3] = now; // startTime
                        fs[gracefulQueue][i][4] = now; // lastTime
                    }
                }
                // call retry to make sure we're actively processing the queue
                retry();
            }

            function retry() {
                // clear the timer and remove it to help prevent unintended concurrency
                clearTimeout(retryTimer);
                retryTimer = undefined;

                if (fs[gracefulQueue].length === 0) return;

                var elem = fs[gracefulQueue].shift();
                var fn = elem[0];
                var args = elem[1];
                // these items may be unset if they were added by an older graceful-fs
                var err = elem[2];
                var startTime = elem[3];
                var lastTime = elem[4];

                // if we don't have a startTime we have no way of knowing if we've waited
                // long enough, so go ahead and retry this item now
                if (startTime === undefined) {
                    debug('RETRY', fn.name, args);
                    fn.apply(null, args);
                } else if (Date.now() - startTime >= 60000) {
                    // it's been more than 60 seconds total, bail now
                    debug('TIMEOUT', fn.name, args);
                    var cb = args.pop();
                    if (typeof cb === 'function') cb.call(null, err);
                } else {
                    // the amount of time between the last attempt and right now
                    var sinceAttempt = Date.now() - lastTime;
                    // the amount of time between when we first tried, and when we last tried
                    // rounded up to at least 1
                    var sinceStart = Math.max(lastTime - startTime, 1);
                    // backoff. wait longer than the total time we've been retrying, but only
                    // up to a maximum of 100ms
                    var desiredDelay = Math.min(sinceStart * 1.2, 100);
                    // it's been long enough since the last retry, do it again
                    if (sinceAttempt >= desiredDelay) {
                        debug('RETRY', fn.name, args);
                        fn.apply(null, args.concat([startTime]));
                    } else {
                        // if we can't do this job yet, push it to the end of the queue
                        // and let the next iteration check again
                        fs[gracefulQueue].push(elem);
                    }
                }

                // schedule our next run if one isn't already scheduled
                if (retryTimer === undefined) {
                    retryTimer = setTimeout(retry, 0);
                }
            }

            /***/
        },
        /* 11 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var constants = __webpack_require__(12);

            var origCwd = process.cwd;
            var cwd = null;

            var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

            process.cwd = function () {
                if (!cwd) cwd = origCwd.call(process);
                return cwd;
            };
            try {
                process.cwd();
            } catch (er) {}

            // This check is needed until node.js 12 is required
            if (typeof process.chdir === 'function') {
                var chdir = process.chdir;
                process.chdir = function (d) {
                    cwd = null;
                    chdir.call(process, d);
                };
                if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
            }

            module.exports = patch;

            function patch(fs) {
                // (re-)implement some things that are known busted or missing.

                // lchmod, broken prior to 0.6.2
                // back-port the fix here.
                if (
                    constants.hasOwnProperty('O_SYMLINK') &&
                    process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)
                ) {
                    patchLchmod(fs);
                }

                // lutimes implementation, or no-op
                if (!fs.lutimes) {
                    patchLutimes(fs);
                }

                // https://github.com/isaacs/node-graceful-fs/issues/4
                // Chown should not fail on einval or eperm if non-root.
                // It should not fail on enosys ever, as this just indicates
                // that a fs doesn't support the intended operation.

                fs.chown = chownFix(fs.chown);
                fs.fchown = chownFix(fs.fchown);
                fs.lchown = chownFix(fs.lchown);

                fs.chmod = chmodFix(fs.chmod);
                fs.fchmod = chmodFix(fs.fchmod);
                fs.lchmod = chmodFix(fs.lchmod);

                fs.chownSync = chownFixSync(fs.chownSync);
                fs.fchownSync = chownFixSync(fs.fchownSync);
                fs.lchownSync = chownFixSync(fs.lchownSync);

                fs.chmodSync = chmodFixSync(fs.chmodSync);
                fs.fchmodSync = chmodFixSync(fs.fchmodSync);
                fs.lchmodSync = chmodFixSync(fs.lchmodSync);

                fs.stat = statFix(fs.stat);
                fs.fstat = statFix(fs.fstat);
                fs.lstat = statFix(fs.lstat);

                fs.statSync = statFixSync(fs.statSync);
                fs.fstatSync = statFixSync(fs.fstatSync);
                fs.lstatSync = statFixSync(fs.lstatSync);

                // if lchmod/lchown do not exist, then make them no-ops
                if (fs.chmod && !fs.lchmod) {
                    fs.lchmod = function (path, mode, cb) {
                        if (cb) process.nextTick(cb);
                    };
                    fs.lchmodSync = function () {};
                }
                if (fs.chown && !fs.lchown) {
                    fs.lchown = function (path, uid, gid, cb) {
                        if (cb) process.nextTick(cb);
                    };
                    fs.lchownSync = function () {};
                }

                // on Windows, A/V software can lock the directory, causing this
                // to fail with an EACCES or EPERM if the directory contains newly
                // created files.  Try again on failure, for up to 60 seconds.

                // Set the timeout this long because some Windows Anti-Virus, such as Parity
                // bit9, may lock files for up to a minute, causing npm package install
                // failures. Also, take care to yield the scheduler. Windows scheduling gives
                // CPU to a busy looping process, which can cause the program causing the lock
                // contention to be starved of CPU by node, so the contention doesn't resolve.
                if (platform === 'win32') {
                    fs.rename =
                        typeof fs.rename !== 'function'
                            ? fs.rename
                            : (function (fs$rename) {
                                  function rename(from, to, cb) {
                                      var start = Date.now();
                                      var backoff = 0;
                                      fs$rename(from, to, function CB(er) {
                                          if (
                                              er &&
                                              (er.code === 'EACCES' || er.code === 'EPERM') &&
                                              Date.now() - start < 60000
                                          ) {
                                              setTimeout(function () {
                                                  fs.stat(to, function (stater, st) {
                                                      if (stater && stater.code === 'ENOENT')
                                                          fs$rename(from, to, CB);
                                                      else cb(er);
                                                  });
                                              }, backoff);
                                              if (backoff < 100) backoff += 10;
                                              return;
                                          }
                                          if (cb) cb(er);
                                      });
                                  }
                                  if (Object.setPrototypeOf)
                                      Object.setPrototypeOf(rename, fs$rename);
                                  return rename;
                              })(fs.rename);
                }

                // if read() returns EAGAIN, then just try it again.
                fs.read =
                    typeof fs.read !== 'function'
                        ? fs.read
                        : (function (fs$read) {
                              function read(fd, buffer, offset, length, position, callback_) {
                                  var callback;
                                  if (callback_ && typeof callback_ === 'function') {
                                      var eagCounter = 0;
                                      callback = function (er, _, __) {
                                          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                                              eagCounter++;
                                              return fs$read.call(
                                                  fs,
                                                  fd,
                                                  buffer,
                                                  offset,
                                                  length,
                                                  position,
                                                  callback
                                              );
                                          }
                                          callback_.apply(this, arguments);
                                      };
                                  }
                                  return fs$read.call(
                                      fs,
                                      fd,
                                      buffer,
                                      offset,
                                      length,
                                      position,
                                      callback
                                  );
                              }

                              // This ensures `util.promisify` works as it does for native `fs.read`.
                              if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
                              return read;
                          })(fs.read);

                fs.readSync =
                    typeof fs.readSync !== 'function'
                        ? fs.readSync
                        : (function (fs$readSync) {
                              return function (fd, buffer, offset, length, position) {
                                  var eagCounter = 0;
                                  while (true) {
                                      try {
                                          return fs$readSync.call(
                                              fs,
                                              fd,
                                              buffer,
                                              offset,
                                              length,
                                              position
                                          );
                                      } catch (er) {
                                          if (er.code === 'EAGAIN' && eagCounter < 10) {
                                              eagCounter++;
                                              continue;
                                          }
                                          throw er;
                                      }
                                  }
                              };
                          })(fs.readSync);

                function patchLchmod(fs) {
                    fs.lchmod = function (path, mode, callback) {
                        fs.open(
                            path,
                            constants.O_WRONLY | constants.O_SYMLINK,
                            mode,
                            function (err, fd) {
                                if (err) {
                                    if (callback) callback(err);
                                    return;
                                }
                                // prefer to return the chmod error, if one occurs,
                                // but still try to close, and report closing errors if they occur.
                                fs.fchmod(fd, mode, function (err) {
                                    fs.close(fd, function (err2) {
                                        if (callback) callback(err || err2);
                                    });
                                });
                            }
                        );
                    };

                    fs.lchmodSync = function (path, mode) {
                        var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

                        // prefer to return the chmod error, if one occurs,
                        // but still try to close, and report closing errors if they occur.
                        var threw = true;
                        var ret;
                        try {
                            ret = fs.fchmodSync(fd, mode);
                            threw = false;
                        } finally {
                            if (threw) {
                                try {
                                    fs.closeSync(fd);
                                } catch (er) {}
                            } else {
                                fs.closeSync(fd);
                            }
                        }
                        return ret;
                    };
                }

                function patchLutimes(fs) {
                    if (constants.hasOwnProperty('O_SYMLINK') && fs.futimes) {
                        fs.lutimes = function (path, at, mt, cb) {
                            fs.open(path, constants.O_SYMLINK, function (er, fd) {
                                if (er) {
                                    if (cb) cb(er);
                                    return;
                                }
                                fs.futimes(fd, at, mt, function (er) {
                                    fs.close(fd, function (er2) {
                                        if (cb) cb(er || er2);
                                    });
                                });
                            });
                        };

                        fs.lutimesSync = function (path, at, mt) {
                            var fd = fs.openSync(path, constants.O_SYMLINK);
                            var ret;
                            var threw = true;
                            try {
                                ret = fs.futimesSync(fd, at, mt);
                                threw = false;
                            } finally {
                                if (threw) {
                                    try {
                                        fs.closeSync(fd);
                                    } catch (er) {}
                                } else {
                                    fs.closeSync(fd);
                                }
                            }
                            return ret;
                        };
                    } else if (fs.futimes) {
                        fs.lutimes = function (_a, _b, _c, cb) {
                            if (cb) process.nextTick(cb);
                        };
                        fs.lutimesSync = function () {};
                    }
                }

                function chmodFix(orig) {
                    if (!orig) return orig;
                    return function (target, mode, cb) {
                        return orig.call(fs, target, mode, function (er) {
                            if (chownErOk(er)) er = null;
                            if (cb) cb.apply(this, arguments);
                        });
                    };
                }

                function chmodFixSync(orig) {
                    if (!orig) return orig;
                    return function (target, mode) {
                        try {
                            return orig.call(fs, target, mode);
                        } catch (er) {
                            if (!chownErOk(er)) throw er;
                        }
                    };
                }

                function chownFix(orig) {
                    if (!orig) return orig;
                    return function (target, uid, gid, cb) {
                        return orig.call(fs, target, uid, gid, function (er) {
                            if (chownErOk(er)) er = null;
                            if (cb) cb.apply(this, arguments);
                        });
                    };
                }

                function chownFixSync(orig) {
                    if (!orig) return orig;
                    return function (target, uid, gid) {
                        try {
                            return orig.call(fs, target, uid, gid);
                        } catch (er) {
                            if (!chownErOk(er)) throw er;
                        }
                    };
                }

                function statFix(orig) {
                    if (!orig) return orig;
                    // Older versions of Node erroneously returned signed integers for
                    // uid + gid.
                    return function (target, options, cb) {
                        if (typeof options === 'function') {
                            cb = options;
                            options = null;
                        }
                        function callback(er, stats) {
                            if (stats) {
                                if (stats.uid < 0) stats.uid += 0x100000000;
                                if (stats.gid < 0) stats.gid += 0x100000000;
                            }
                            if (cb) cb.apply(this, arguments);
                        }
                        return options
                            ? orig.call(fs, target, options, callback)
                            : orig.call(fs, target, callback);
                    };
                }

                function statFixSync(orig) {
                    if (!orig) return orig;
                    // Older versions of Node erroneously returned signed integers for
                    // uid + gid.
                    return function (target, options) {
                        var stats = options
                            ? orig.call(fs, target, options)
                            : orig.call(fs, target);
                        if (stats) {
                            if (stats.uid < 0) stats.uid += 0x100000000;
                            if (stats.gid < 0) stats.gid += 0x100000000;
                        }
                        return stats;
                    };
                }

                // ENOSYS means that the fs doesn't support the op. Just ignore
                // that, because it doesn't matter.
                //
                // if there's no getuid, or if getuid() is something other
                // than 0, and the error is EINVAL or EPERM, then just ignore
                // it.
                //
                // This specific case is a silent failure in cp, install, tar,
                // and most other unix tools that manage permissions.
                //
                // When running as root, or if other types of errors are
                // encountered, then it's strict.
                function chownErOk(er) {
                    if (!er) return true;

                    if (er.code === 'ENOSYS') return true;

                    var nonroot = !process.getuid || process.getuid() !== 0;
                    if (nonroot) {
                        if (er.code === 'EINVAL' || er.code === 'EPERM') return true;
                    }

                    return false;
                }
            }

            /***/
        },
        /* 12 */
        /***/ (module) => {
            'use strict';
            module.exports = require('constants');

            /***/
        },
        /* 13 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var Stream = __webpack_require__(14).Stream;

            module.exports = legacy;

            function legacy(fs) {
                return {
                    ReadStream: ReadStream,
                    WriteStream: WriteStream
                };

                function ReadStream(path, options) {
                    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

                    Stream.call(this);

                    var self = this;

                    this.path = path;
                    this.fd = null;
                    this.readable = true;
                    this.paused = false;

                    this.flags = 'r';
                    this.mode = 438; /*=0666*/
                    this.bufferSize = 64 * 1024;

                    options = options || {};

                    // Mixin options into this
                    var keys = Object.keys(options);
                    for (var index = 0, length = keys.length; index < length; index++) {
                        var key = keys[index];
                        this[key] = options[key];
                    }

                    if (this.encoding) this.setEncoding(this.encoding);

                    if (this.start !== undefined) {
                        if ('number' !== typeof this.start) {
                            throw TypeError('start must be a Number');
                        }
                        if (this.end === undefined) {
                            this.end = Infinity;
                        } else if ('number' !== typeof this.end) {
                            throw TypeError('end must be a Number');
                        }

                        if (this.start > this.end) {
                            throw new Error('start must be <= end');
                        }

                        this.pos = this.start;
                    }

                    if (this.fd !== null) {
                        process.nextTick(function () {
                            self._read();
                        });
                        return;
                    }

                    fs.open(this.path, this.flags, this.mode, function (err, fd) {
                        if (err) {
                            self.emit('error', err);
                            self.readable = false;
                            return;
                        }

                        self.fd = fd;
                        self.emit('open', fd);
                        self._read();
                    });
                }

                function WriteStream(path, options) {
                    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

                    Stream.call(this);

                    this.path = path;
                    this.fd = null;
                    this.writable = true;

                    this.flags = 'w';
                    this.encoding = 'binary';
                    this.mode = 438; /*=0666*/
                    this.bytesWritten = 0;

                    options = options || {};

                    // Mixin options into this
                    var keys = Object.keys(options);
                    for (var index = 0, length = keys.length; index < length; index++) {
                        var key = keys[index];
                        this[key] = options[key];
                    }

                    if (this.start !== undefined) {
                        if ('number' !== typeof this.start) {
                            throw TypeError('start must be a Number');
                        }
                        if (this.start < 0) {
                            throw new Error('start must be >= zero');
                        }

                        this.pos = this.start;
                    }

                    this.busy = false;
                    this._queue = [];

                    if (this.fd === null) {
                        this._open = fs.open;
                        this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
                        this.flush();
                    }
                }
            }

            /***/
        },
        /* 14 */
        /***/ (module) => {
            'use strict';
            module.exports = require('stream');

            /***/
        },
        /* 15 */
        /***/ (module) => {
            'use strict';

            module.exports = clone;

            var getPrototypeOf =
                Object.getPrototypeOf ||
                function (obj) {
                    return obj.__proto__;
                };

            function clone(obj) {
                if (obj === null || typeof obj !== 'object') return obj;

                if (obj instanceof Object) var copy = { __proto__: getPrototypeOf(obj) };
                else var copy = Object.create(null);

                Object.getOwnPropertyNames(obj).forEach(function (key) {
                    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
                });

                return copy;
            }

            /***/
        },
        /* 16 */
        /***/ (module) => {
            'use strict';
            module.exports = require('util');

            /***/
        },
        /* 17 */
        /***/ (module) => {
            'use strict';
            module.exports = require('assert');

            /***/
        },
        /* 18 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromCallback;
            module.exports = {
                copy: u(__webpack_require__(19)),
                copySync: __webpack_require__(26)
            };

            /***/
        },
        /* 19 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(10);
            const path = __webpack_require__(4);
            const mkdirs = __webpack_require__(20).mkdirs;
            const pathExists = __webpack_require__(23).pathExists;
            const utimesMillis = __webpack_require__(24).utimesMillis;
            const stat = __webpack_require__(25);

            function copy(src, dest, opts, cb) {
                if (typeof opts === 'function' && !cb) {
                    cb = opts;
                    opts = {};
                } else if (typeof opts === 'function') {
                    opts = { filter: opts };
                }

                cb = cb || function () {};
                opts = opts || {};

                opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
                opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

                // Warn about using preserveTimestamps on 32-bit node
                if (opts.preserveTimestamps && process.arch === 'ia32') {
                    process.emitWarning(
                        'Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' +
                            '\tsee https://github.com/jprichardson/node-fs-extra/issues/269',
                        'Warning',
                        'fs-extra-WARN0001'
                    );
                }

                stat.checkPaths(src, dest, 'copy', opts, (err, stats) => {
                    if (err) return cb(err);
                    const { srcStat, destStat } = stats;
                    stat.checkParentPaths(src, srcStat, dest, 'copy', (err) => {
                        if (err) return cb(err);
                        if (opts.filter)
                            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
                        return checkParentDir(destStat, src, dest, opts, cb);
                    });
                });
            }

            function checkParentDir(destStat, src, dest, opts, cb) {
                const destParent = path.dirname(dest);
                pathExists(destParent, (err, dirExists) => {
                    if (err) return cb(err);
                    if (dirExists) return getStats(destStat, src, dest, opts, cb);
                    mkdirs(destParent, (err) => {
                        if (err) return cb(err);
                        return getStats(destStat, src, dest, opts, cb);
                    });
                });
            }

            function handleFilter(onInclude, destStat, src, dest, opts, cb) {
                Promise.resolve(opts.filter(src, dest)).then(
                    (include) => {
                        if (include) return onInclude(destStat, src, dest, opts, cb);
                        return cb();
                    },
                    (error) => cb(error)
                );
            }

            function startCopy(destStat, src, dest, opts, cb) {
                if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb);
                return getStats(destStat, src, dest, opts, cb);
            }

            function getStats(destStat, src, dest, opts, cb) {
                const stat = opts.dereference ? fs.stat : fs.lstat;
                stat(src, (err, srcStat) => {
                    if (err) return cb(err);

                    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);
                    else if (
                        srcStat.isFile() ||
                        srcStat.isCharacterDevice() ||
                        srcStat.isBlockDevice()
                    )
                        return onFile(srcStat, destStat, src, dest, opts, cb);
                    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);
                    else if (srcStat.isSocket())
                        return cb(new Error(`Cannot copy a socket file: ${src}`));
                    else if (srcStat.isFIFO())
                        return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
                    return cb(new Error(`Unknown file: ${src}`));
                });
            }

            function onFile(srcStat, destStat, src, dest, opts, cb) {
                if (!destStat) return copyFile(srcStat, src, dest, opts, cb);
                return mayCopyFile(srcStat, src, dest, opts, cb);
            }

            function mayCopyFile(srcStat, src, dest, opts, cb) {
                if (opts.overwrite) {
                    fs.unlink(dest, (err) => {
                        if (err) return cb(err);
                        return copyFile(srcStat, src, dest, opts, cb);
                    });
                } else if (opts.errorOnExist) {
                    return cb(new Error(`'${dest}' already exists`));
                } else return cb();
            }

            function copyFile(srcStat, src, dest, opts, cb) {
                fs.copyFile(src, dest, (err) => {
                    if (err) return cb(err);
                    if (opts.preserveTimestamps)
                        return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
                    return setDestMode(dest, srcStat.mode, cb);
                });
            }

            function handleTimestampsAndMode(srcMode, src, dest, cb) {
                // Make sure the file is writable before setting the timestamp
                // otherwise open fails with EPERM when invoked with 'r+'
                // (through utimes call)
                if (fileIsNotWritable(srcMode)) {
                    return makeFileWritable(dest, srcMode, (err) => {
                        if (err) return cb(err);
                        return setDestTimestampsAndMode(srcMode, src, dest, cb);
                    });
                }
                return setDestTimestampsAndMode(srcMode, src, dest, cb);
            }

            function fileIsNotWritable(srcMode) {
                return (srcMode & 0o200) === 0;
            }

            function makeFileWritable(dest, srcMode, cb) {
                return setDestMode(dest, srcMode | 0o200, cb);
            }

            function setDestTimestampsAndMode(srcMode, src, dest, cb) {
                setDestTimestamps(src, dest, (err) => {
                    if (err) return cb(err);
                    return setDestMode(dest, srcMode, cb);
                });
            }

            function setDestMode(dest, srcMode, cb) {
                return fs.chmod(dest, srcMode, cb);
            }

            function setDestTimestamps(src, dest, cb) {
                // The initial srcStat.atime cannot be trusted
                // because it is modified by the read(2) system call
                // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
                fs.stat(src, (err, updatedSrcStat) => {
                    if (err) return cb(err);
                    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
                });
            }

            function onDir(srcStat, destStat, src, dest, opts, cb) {
                if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
                return copyDir(src, dest, opts, cb);
            }

            function mkDirAndCopy(srcMode, src, dest, opts, cb) {
                fs.mkdir(dest, (err) => {
                    if (err) return cb(err);
                    copyDir(src, dest, opts, (err) => {
                        if (err) return cb(err);
                        return setDestMode(dest, srcMode, cb);
                    });
                });
            }

            function copyDir(src, dest, opts, cb) {
                fs.readdir(src, (err, items) => {
                    if (err) return cb(err);
                    return copyDirItems(items, src, dest, opts, cb);
                });
            }

            function copyDirItems(items, src, dest, opts, cb) {
                const item = items.pop();
                if (!item) return cb();
                return copyDirItem(items, item, src, dest, opts, cb);
            }

            function copyDirItem(items, item, src, dest, opts, cb) {
                const srcItem = path.join(src, item);
                const destItem = path.join(dest, item);
                stat.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {
                    if (err) return cb(err);
                    const { destStat } = stats;
                    startCopy(destStat, srcItem, destItem, opts, (err) => {
                        if (err) return cb(err);
                        return copyDirItems(items, src, dest, opts, cb);
                    });
                });
            }

            function onLink(destStat, src, dest, opts, cb) {
                fs.readlink(src, (err, resolvedSrc) => {
                    if (err) return cb(err);
                    if (opts.dereference) {
                        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
                    }

                    if (!destStat) {
                        return fs.symlink(resolvedSrc, dest, cb);
                    } else {
                        fs.readlink(dest, (err, resolvedDest) => {
                            if (err) {
                                // dest exists and is a regular file or directory,
                                // Windows may throw UNKNOWN error. If dest already exists,
                                // fs throws error anyway, so no need to guard against it here.
                                if (err.code === 'EINVAL' || err.code === 'UNKNOWN')
                                    return fs.symlink(resolvedSrc, dest, cb);
                                return cb(err);
                            }
                            if (opts.dereference) {
                                resolvedDest = path.resolve(process.cwd(), resolvedDest);
                            }
                            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                                return cb(
                                    new Error(
                                        `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
                                    )
                                );
                            }

                            // do not copy if src is a subdir of dest since unlinking
                            // dest in this case would result in removing src contents
                            // and therefore a broken symlink would be created.
                            if (
                                destStat.isDirectory() &&
                                stat.isSrcSubdir(resolvedDest, resolvedSrc)
                            ) {
                                return cb(
                                    new Error(
                                        `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
                                    )
                                );
                            }
                            return copyLink(resolvedSrc, dest, cb);
                        });
                    }
                });
            }

            function copyLink(resolvedSrc, dest, cb) {
                fs.unlink(dest, (err) => {
                    if (err) return cb(err);
                    return fs.symlink(resolvedSrc, dest, cb);
                });
            }

            module.exports = copy;

            /***/
        },
        /* 20 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromPromise;
            const { makeDir: _makeDir, makeDirSync } = __webpack_require__(21);
            const makeDir = u(_makeDir);

            module.exports = {
                mkdirs: makeDir,
                mkdirsSync: makeDirSync,
                // alias
                mkdirp: makeDir,
                mkdirpSync: makeDirSync,
                ensureDir: makeDir,
                ensureDirSync: makeDirSync
            };

            /***/
        },
        /* 21 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(8);
            const { checkPath } = __webpack_require__(22);

            const getMode = (options) => {
                const defaults = { mode: 0o777 };
                if (typeof options === 'number') return options;
                return { ...defaults, ...options }.mode;
            };

            module.exports.makeDir = async (dir, options) => {
                checkPath(dir);

                return fs.mkdir(dir, {
                    mode: getMode(options),
                    recursive: true
                });
            };

            module.exports.makeDirSync = (dir, options) => {
                checkPath(dir);

                return fs.mkdirSync(dir, {
                    mode: getMode(options),
                    recursive: true
                });
            };

            /***/
        },
        /* 22 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';
            // Adapted from https://github.com/sindresorhus/make-dir
            // Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
            // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
            // The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

            const path = __webpack_require__(4);

            // https://github.com/nodejs/node/issues/8987
            // https://github.com/libuv/libuv/pull/1088
            module.exports.checkPath = function checkPath(pth) {
                if (process.platform === 'win32') {
                    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(
                        pth.replace(path.parse(pth).root, '')
                    );

                    if (pathHasInvalidWinCharacters) {
                        const error = new Error(`Path contains invalid characters: ${pth}`);
                        error.code = 'EINVAL';
                        throw error;
                    }
                }
            };

            /***/
        },
        /* 23 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromPromise;
            const fs = __webpack_require__(8);

            function pathExists(path) {
                return fs
                    .access(path)
                    .then(() => true)
                    .catch(() => false);
            }

            module.exports = {
                pathExists: u(pathExists),
                pathExistsSync: fs.existsSync
            };

            /***/
        },
        /* 24 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(10);

            function utimesMillis(path, atime, mtime, callback) {
                // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
                fs.open(path, 'r+', (err, fd) => {
                    if (err) return callback(err);
                    fs.futimes(fd, atime, mtime, (futimesErr) => {
                        fs.close(fd, (closeErr) => {
                            if (callback) callback(futimesErr || closeErr);
                        });
                    });
                });
            }

            function utimesMillisSync(path, atime, mtime) {
                const fd = fs.openSync(path, 'r+');
                fs.futimesSync(fd, atime, mtime);
                return fs.closeSync(fd);
            }

            module.exports = {
                utimesMillis,
                utimesMillisSync
            };

            /***/
        },
        /* 25 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(8);
            const path = __webpack_require__(4);
            const util = __webpack_require__(16);

            function getStats(src, dest, opts) {
                const statFunc = opts.dereference
                    ? (file) => fs.stat(file, { bigint: true })
                    : (file) => fs.lstat(file, { bigint: true });
                return Promise.all([
                    statFunc(src),
                    statFunc(dest).catch((err) => {
                        if (err.code === 'ENOENT') return null;
                        throw err;
                    })
                ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
            }

            function getStatsSync(src, dest, opts) {
                let destStat;
                const statFunc = opts.dereference
                    ? (file) => fs.statSync(file, { bigint: true })
                    : (file) => fs.lstatSync(file, { bigint: true });
                const srcStat = statFunc(src);
                try {
                    destStat = statFunc(dest);
                } catch (err) {
                    if (err.code === 'ENOENT') return { srcStat, destStat: null };
                    throw err;
                }
                return { srcStat, destStat };
            }

            function checkPaths(src, dest, funcName, opts, cb) {
                util.callbackify(getStats)(src, dest, opts, (err, stats) => {
                    if (err) return cb(err);
                    const { srcStat, destStat } = stats;

                    if (destStat) {
                        if (areIdentical(srcStat, destStat)) {
                            const srcBaseName = path.basename(src);
                            const destBaseName = path.basename(dest);
                            if (
                                funcName === 'move' &&
                                srcBaseName !== destBaseName &&
                                srcBaseName.toLowerCase() === destBaseName.toLowerCase()
                            ) {
                                return cb(null, { srcStat, destStat, isChangingCase: true });
                            }
                            return cb(new Error('Source and destination must not be the same.'));
                        }
                        if (srcStat.isDirectory() && !destStat.isDirectory()) {
                            return cb(
                                new Error(
                                    `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
                                )
                            );
                        }
                        if (!srcStat.isDirectory() && destStat.isDirectory()) {
                            return cb(
                                new Error(
                                    `Cannot overwrite directory '${dest}' with non-directory '${src}'.`
                                )
                            );
                        }
                    }

                    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
                        return cb(new Error(errMsg(src, dest, funcName)));
                    }
                    return cb(null, { srcStat, destStat });
                });
            }

            function checkPathsSync(src, dest, funcName, opts) {
                const { srcStat, destStat } = getStatsSync(src, dest, opts);

                if (destStat) {
                    if (areIdentical(srcStat, destStat)) {
                        const srcBaseName = path.basename(src);
                        const destBaseName = path.basename(dest);
                        if (
                            funcName === 'move' &&
                            srcBaseName !== destBaseName &&
                            srcBaseName.toLowerCase() === destBaseName.toLowerCase()
                        ) {
                            return { srcStat, destStat, isChangingCase: true };
                        }
                        throw new Error('Source and destination must not be the same.');
                    }
                    if (srcStat.isDirectory() && !destStat.isDirectory()) {
                        throw new Error(
                            `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
                        );
                    }
                    if (!srcStat.isDirectory() && destStat.isDirectory()) {
                        throw new Error(
                            `Cannot overwrite directory '${dest}' with non-directory '${src}'.`
                        );
                    }
                }

                if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
                    throw new Error(errMsg(src, dest, funcName));
                }
                return { srcStat, destStat };
            }

            // recursively check if dest parent is a subdirectory of src.
            // It works for all file types including symlinks since it
            // checks the src and dest inodes. It starts from the deepest
            // parent and stops once it reaches the src parent or the root path.
            function checkParentPaths(src, srcStat, dest, funcName, cb) {
                const srcParent = path.resolve(path.dirname(src));
                const destParent = path.resolve(path.dirname(dest));
                if (destParent === srcParent || destParent === path.parse(destParent).root)
                    return cb();
                fs.stat(destParent, { bigint: true }, (err, destStat) => {
                    if (err) {
                        if (err.code === 'ENOENT') return cb();
                        return cb(err);
                    }
                    if (areIdentical(srcStat, destStat)) {
                        return cb(new Error(errMsg(src, dest, funcName)));
                    }
                    return checkParentPaths(src, srcStat, destParent, funcName, cb);
                });
            }

            function checkParentPathsSync(src, srcStat, dest, funcName) {
                const srcParent = path.resolve(path.dirname(src));
                const destParent = path.resolve(path.dirname(dest));
                if (destParent === srcParent || destParent === path.parse(destParent).root) return;
                let destStat;
                try {
                    destStat = fs.statSync(destParent, { bigint: true });
                } catch (err) {
                    if (err.code === 'ENOENT') return;
                    throw err;
                }
                if (areIdentical(srcStat, destStat)) {
                    throw new Error(errMsg(src, dest, funcName));
                }
                return checkParentPathsSync(src, srcStat, destParent, funcName);
            }

            function areIdentical(srcStat, destStat) {
                return (
                    destStat.ino &&
                    destStat.dev &&
                    destStat.ino === srcStat.ino &&
                    destStat.dev === srcStat.dev
                );
            }

            // return true if dest is a subdir of src, otherwise false.
            // It only checks the path strings.
            function isSrcSubdir(src, dest) {
                const srcArr = path
                    .resolve(src)
                    .split(path.sep)
                    .filter((i) => i);
                const destArr = path
                    .resolve(dest)
                    .split(path.sep)
                    .filter((i) => i);
                return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
            }

            function errMsg(src, dest, funcName) {
                return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
            }

            module.exports = {
                checkPaths,
                checkPathsSync,
                checkParentPaths,
                checkParentPathsSync,
                isSrcSubdir,
                areIdentical
            };

            /***/
        },
        /* 26 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(10);
            const path = __webpack_require__(4);
            const mkdirsSync = __webpack_require__(20).mkdirsSync;
            const utimesMillisSync = __webpack_require__(24).utimesMillisSync;
            const stat = __webpack_require__(25);

            function copySync(src, dest, opts) {
                if (typeof opts === 'function') {
                    opts = { filter: opts };
                }

                opts = opts || {};
                opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
                opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

                // Warn about using preserveTimestamps on 32-bit node
                if (opts.preserveTimestamps && process.arch === 'ia32') {
                    process.emitWarning(
                        'Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' +
                            '\tsee https://github.com/jprichardson/node-fs-extra/issues/269',
                        'Warning',
                        'fs-extra-WARN0002'
                    );
                }

                const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts);
                stat.checkParentPathsSync(src, srcStat, dest, 'copy');
                return handleFilterAndCopy(destStat, src, dest, opts);
            }

            function handleFilterAndCopy(destStat, src, dest, opts) {
                if (opts.filter && !opts.filter(src, dest)) return;
                const destParent = path.dirname(dest);
                if (!fs.existsSync(destParent)) mkdirsSync(destParent);
                return getStats(destStat, src, dest, opts);
            }

            function startCopy(destStat, src, dest, opts) {
                if (opts.filter && !opts.filter(src, dest)) return;
                return getStats(destStat, src, dest, opts);
            }

            function getStats(destStat, src, dest, opts) {
                const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
                const srcStat = statSync(src);

                if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
                else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
                    return onFile(srcStat, destStat, src, dest, opts);
                else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
                else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
                else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
                throw new Error(`Unknown file: ${src}`);
            }

            function onFile(srcStat, destStat, src, dest, opts) {
                if (!destStat) return copyFile(srcStat, src, dest, opts);
                return mayCopyFile(srcStat, src, dest, opts);
            }

            function mayCopyFile(srcStat, src, dest, opts) {
                if (opts.overwrite) {
                    fs.unlinkSync(dest);
                    return copyFile(srcStat, src, dest, opts);
                } else if (opts.errorOnExist) {
                    throw new Error(`'${dest}' already exists`);
                }
            }

            function copyFile(srcStat, src, dest, opts) {
                fs.copyFileSync(src, dest);
                if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
                return setDestMode(dest, srcStat.mode);
            }

            function handleTimestamps(srcMode, src, dest) {
                // Make sure the file is writable before setting the timestamp
                // otherwise open fails with EPERM when invoked with 'r+'
                // (through utimes call)
                if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
                return setDestTimestamps(src, dest);
            }

            function fileIsNotWritable(srcMode) {
                return (srcMode & 0o200) === 0;
            }

            function makeFileWritable(dest, srcMode) {
                return setDestMode(dest, srcMode | 0o200);
            }

            function setDestMode(dest, srcMode) {
                return fs.chmodSync(dest, srcMode);
            }

            function setDestTimestamps(src, dest) {
                // The initial srcStat.atime cannot be trusted
                // because it is modified by the read(2) system call
                // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
                const updatedSrcStat = fs.statSync(src);
                return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
            }

            function onDir(srcStat, destStat, src, dest, opts) {
                if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
                return copyDir(src, dest, opts);
            }

            function mkDirAndCopy(srcMode, src, dest, opts) {
                fs.mkdirSync(dest);
                copyDir(src, dest, opts);
                return setDestMode(dest, srcMode);
            }

            function copyDir(src, dest, opts) {
                fs.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
            }

            function copyDirItem(item, src, dest, opts) {
                const srcItem = path.join(src, item);
                const destItem = path.join(dest, item);
                const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts);
                return startCopy(destStat, srcItem, destItem, opts);
            }

            function onLink(destStat, src, dest, opts) {
                let resolvedSrc = fs.readlinkSync(src);
                if (opts.dereference) {
                    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
                }

                if (!destStat) {
                    return fs.symlinkSync(resolvedSrc, dest);
                } else {
                    let resolvedDest;
                    try {
                        resolvedDest = fs.readlinkSync(dest);
                    } catch (err) {
                        // dest exists and is a regular file or directory,
                        // Windows may throw UNKNOWN error. If dest already exists,
                        // fs throws error anyway, so no need to guard against it here.
                        if (err.code === 'EINVAL' || err.code === 'UNKNOWN')
                            return fs.symlinkSync(resolvedSrc, dest);
                        throw err;
                    }
                    if (opts.dereference) {
                        resolvedDest = path.resolve(process.cwd(), resolvedDest);
                    }
                    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                        throw new Error(
                            `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
                        );
                    }

                    // prevent copy if src is a subdir of dest since unlinking
                    // dest in this case would result in removing src contents
                    // and therefore a broken symlink would be created.
                    if (
                        fs.statSync(dest).isDirectory() &&
                        stat.isSrcSubdir(resolvedDest, resolvedSrc)
                    ) {
                        throw new Error(
                            `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
                        );
                    }
                    return copyLink(resolvedSrc, dest);
                }
            }

            function copyLink(resolvedSrc, dest) {
                fs.unlinkSync(dest);
                return fs.symlinkSync(resolvedSrc, dest);
            }

            module.exports = copySync;

            /***/
        },
        /* 27 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromPromise;
            const fs = __webpack_require__(8);
            const path = __webpack_require__(4);
            const mkdir = __webpack_require__(20);
            const remove = __webpack_require__(28);

            const emptyDir = u(async function emptyDir(dir) {
                let items;
                try {
                    items = await fs.readdir(dir);
                } catch {
                    return mkdir.mkdirs(dir);
                }

                return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
            });

            function emptyDirSync(dir) {
                let items;
                try {
                    items = fs.readdirSync(dir);
                } catch {
                    return mkdir.mkdirsSync(dir);
                }

                items.forEach((item) => {
                    item = path.join(dir, item);
                    remove.removeSync(item);
                });
            }

            module.exports = {
                emptyDirSync,
                emptydirSync: emptyDirSync,
                emptyDir,
                emptydir: emptyDir
            };

            /***/
        },
        /* 28 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(10);
            const u = __webpack_require__(9).fromCallback;
            const rimraf = __webpack_require__(29);

            function remove(path, callback) {
                // Node 14.14.0+
                if (fs.rm) return fs.rm(path, { recursive: true, force: true }, callback);
                rimraf(path, callback);
            }

            function removeSync(path) {
                // Node 14.14.0+
                if (fs.rmSync) return fs.rmSync(path, { recursive: true, force: true });
                rimraf.sync(path);
            }

            module.exports = {
                remove: u(remove),
                removeSync
            };

            /***/
        },
        /* 29 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(10);
            const path = __webpack_require__(4);
            const assert = __webpack_require__(17);

            const isWindows = process.platform === 'win32';

            function defaults(options) {
                const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];
                methods.forEach((m) => {
                    options[m] = options[m] || fs[m];
                    m = m + 'Sync';
                    options[m] = options[m] || fs[m];
                });

                options.maxBusyTries = options.maxBusyTries || 3;
            }

            function rimraf(p, options, cb) {
                let busyTries = 0;

                if (typeof options === 'function') {
                    cb = options;
                    options = {};
                }

                assert(p, 'rimraf: missing path');
                assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
                assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
                assert(options, 'rimraf: invalid options argument provided');
                assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

                defaults(options);

                rimraf_(p, options, function CB(er) {
                    if (er) {
                        if (
                            (er.code === 'EBUSY' ||
                                er.code === 'ENOTEMPTY' ||
                                er.code === 'EPERM') &&
                            busyTries < options.maxBusyTries
                        ) {
                            busyTries++;
                            const time = busyTries * 100;
                            // try again, with the same exact callback as this one.
                            return setTimeout(() => rimraf_(p, options, CB), time);
                        }

                        // already gone
                        if (er.code === 'ENOENT') er = null;
                    }

                    cb(er);
                });
            }

            // Two possible strategies.
            // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
            // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
            //
            // Both result in an extra syscall when you guess wrong.  However, there
            // are likely far more normal files in the world than directories.  This
            // is based on the assumption that a the average number of files per
            // directory is >= 1.
            //
            // If anyone ever complains about this, then I guess the strategy could
            // be made configurable somehow.  But until then, YAGNI.
            function rimraf_(p, options, cb) {
                assert(p);
                assert(options);
                assert(typeof cb === 'function');

                // sunos lets the root user unlink directories, which is... weird.
                // so we have to lstat here and make sure it's not a dir.
                options.lstat(p, (er, st) => {
                    if (er && er.code === 'ENOENT') {
                        return cb(null);
                    }

                    // Windows can EPERM on stat.  Life is suffering.
                    if (er && er.code === 'EPERM' && isWindows) {
                        return fixWinEPERM(p, options, er, cb);
                    }

                    if (st && st.isDirectory()) {
                        return rmdir(p, options, er, cb);
                    }

                    options.unlink(p, (er) => {
                        if (er) {
                            if (er.code === 'ENOENT') {
                                return cb(null);
                            }
                            if (er.code === 'EPERM') {
                                return isWindows
                                    ? fixWinEPERM(p, options, er, cb)
                                    : rmdir(p, options, er, cb);
                            }
                            if (er.code === 'EISDIR') {
                                return rmdir(p, options, er, cb);
                            }
                        }
                        return cb(er);
                    });
                });
            }

            function fixWinEPERM(p, options, er, cb) {
                assert(p);
                assert(options);
                assert(typeof cb === 'function');

                options.chmod(p, 0o666, (er2) => {
                    if (er2) {
                        cb(er2.code === 'ENOENT' ? null : er);
                    } else {
                        options.stat(p, (er3, stats) => {
                            if (er3) {
                                cb(er3.code === 'ENOENT' ? null : er);
                            } else if (stats.isDirectory()) {
                                rmdir(p, options, er, cb);
                            } else {
                                options.unlink(p, cb);
                            }
                        });
                    }
                });
            }

            function fixWinEPERMSync(p, options, er) {
                let stats;

                assert(p);
                assert(options);

                try {
                    options.chmodSync(p, 0o666);
                } catch (er2) {
                    if (er2.code === 'ENOENT') {
                        return;
                    } else {
                        throw er;
                    }
                }

                try {
                    stats = options.statSync(p);
                } catch (er3) {
                    if (er3.code === 'ENOENT') {
                        return;
                    } else {
                        throw er;
                    }
                }

                if (stats.isDirectory()) {
                    rmdirSync(p, options, er);
                } else {
                    options.unlinkSync(p);
                }
            }

            function rmdir(p, options, originalEr, cb) {
                assert(p);
                assert(options);
                assert(typeof cb === 'function');

                // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
                // if we guessed wrong, and it's not a directory, then
                // raise the original error.
                options.rmdir(p, (er) => {
                    if (
                        er &&
                        (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')
                    ) {
                        rmkids(p, options, cb);
                    } else if (er && er.code === 'ENOTDIR') {
                        cb(originalEr);
                    } else {
                        cb(er);
                    }
                });
            }

            function rmkids(p, options, cb) {
                assert(p);
                assert(options);
                assert(typeof cb === 'function');

                options.readdir(p, (er, files) => {
                    if (er) return cb(er);

                    let n = files.length;
                    let errState;

                    if (n === 0) return options.rmdir(p, cb);

                    files.forEach((f) => {
                        rimraf(path.join(p, f), options, (er) => {
                            if (errState) {
                                return;
                            }
                            if (er) return cb((errState = er));
                            if (--n === 0) {
                                options.rmdir(p, cb);
                            }
                        });
                    });
                });
            }

            // this looks simpler, and is strictly *faster*, but will
            // tie up the JavaScript thread and fail on excessively
            // deep directory trees.
            function rimrafSync(p, options) {
                let st;

                options = options || {};
                defaults(options);

                assert(p, 'rimraf: missing path');
                assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
                assert(options, 'rimraf: missing options');
                assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

                try {
                    st = options.lstatSync(p);
                } catch (er) {
                    if (er.code === 'ENOENT') {
                        return;
                    }

                    // Windows can EPERM on stat.  Life is suffering.
                    if (er.code === 'EPERM' && isWindows) {
                        fixWinEPERMSync(p, options, er);
                    }
                }

                try {
                    // sunos lets the root user unlink directories, which is... weird.
                    if (st && st.isDirectory()) {
                        rmdirSync(p, options, null);
                    } else {
                        options.unlinkSync(p);
                    }
                } catch (er) {
                    if (er.code === 'ENOENT') {
                        return;
                    } else if (er.code === 'EPERM') {
                        return isWindows
                            ? fixWinEPERMSync(p, options, er)
                            : rmdirSync(p, options, er);
                    } else if (er.code !== 'EISDIR') {
                        throw er;
                    }
                    rmdirSync(p, options, er);
                }
            }

            function rmdirSync(p, options, originalEr) {
                assert(p);
                assert(options);

                try {
                    options.rmdirSync(p);
                } catch (er) {
                    if (er.code === 'ENOTDIR') {
                        throw originalEr;
                    } else if (
                        er.code === 'ENOTEMPTY' ||
                        er.code === 'EEXIST' ||
                        er.code === 'EPERM'
                    ) {
                        rmkidsSync(p, options);
                    } else if (er.code !== 'ENOENT') {
                        throw er;
                    }
                }
            }

            function rmkidsSync(p, options) {
                assert(p);
                assert(options);
                options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));

                if (isWindows) {
                    // We only end up here once we got ENOTEMPTY at least once, and
                    // at this point, we are guaranteed to have removed all the kids.
                    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
                    // try really hard to delete stuff on windows, because it has a
                    // PROFOUNDLY annoying habit of not closing handles promptly when
                    // files are deleted, resulting in spurious ENOTEMPTY errors.
                    const startTime = Date.now();
                    do {
                        try {
                            const ret = options.rmdirSync(p, options);
                            return ret;
                        } catch {}
                    } while (Date.now() - startTime < 500); // give up after 500ms
                } else {
                    const ret = options.rmdirSync(p, options);
                    return ret;
                }
            }

            module.exports = rimraf;
            rimraf.sync = rimrafSync;

            /***/
        },
        /* 30 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const { createFile, createFileSync } = __webpack_require__(31);
            const { createLink, createLinkSync } = __webpack_require__(32);
            const { createSymlink, createSymlinkSync } = __webpack_require__(33);

            module.exports = {
                // file
                createFile,
                createFileSync,
                ensureFile: createFile,
                ensureFileSync: createFileSync,
                // link
                createLink,
                createLinkSync,
                ensureLink: createLink,
                ensureLinkSync: createLinkSync,
                // symlink
                createSymlink,
                createSymlinkSync,
                ensureSymlink: createSymlink,
                ensureSymlinkSync: createSymlinkSync
            };

            /***/
        },
        /* 31 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromCallback;
            const path = __webpack_require__(4);
            const fs = __webpack_require__(10);
            const mkdir = __webpack_require__(20);

            function createFile(file, callback) {
                function makeFile() {
                    fs.writeFile(file, '', (err) => {
                        if (err) return callback(err);
                        callback();
                    });
                }

                fs.stat(file, (err, stats) => {
                    // eslint-disable-line handle-callback-err
                    if (!err && stats.isFile()) return callback();
                    const dir = path.dirname(file);
                    fs.stat(dir, (err, stats) => {
                        if (err) {
                            // if the directory doesn't exist, make it
                            if (err.code === 'ENOENT') {
                                return mkdir.mkdirs(dir, (err) => {
                                    if (err) return callback(err);
                                    makeFile();
                                });
                            }
                            return callback(err);
                        }

                        if (stats.isDirectory()) makeFile();
                        else {
                            // parent is not a directory
                            // This is just to cause an internal ENOTDIR error to be thrown
                            fs.readdir(dir, (err) => {
                                if (err) return callback(err);
                            });
                        }
                    });
                });
            }

            function createFileSync(file) {
                let stats;
                try {
                    stats = fs.statSync(file);
                } catch {}
                if (stats && stats.isFile()) return;

                const dir = path.dirname(file);
                try {
                    if (!fs.statSync(dir).isDirectory()) {
                        // parent is not a directory
                        // This is just to cause an internal ENOTDIR error to be thrown
                        fs.readdirSync(dir);
                    }
                } catch (err) {
                    // If the stat call above failed because the directory doesn't exist, create it
                    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir);
                    else throw err;
                }

                fs.writeFileSync(file, '');
            }

            module.exports = {
                createFile: u(createFile),
                createFileSync
            };

            /***/
        },
        /* 32 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromCallback;
            const path = __webpack_require__(4);
            const fs = __webpack_require__(10);
            const mkdir = __webpack_require__(20);
            const pathExists = __webpack_require__(23).pathExists;
            const { areIdentical } = __webpack_require__(25);

            function createLink(srcpath, dstpath, callback) {
                function makeLink(srcpath, dstpath) {
                    fs.link(srcpath, dstpath, (err) => {
                        if (err) return callback(err);
                        callback(null);
                    });
                }

                fs.lstat(dstpath, (_, dstStat) => {
                    fs.lstat(srcpath, (err, srcStat) => {
                        if (err) {
                            err.message = err.message.replace('lstat', 'ensureLink');
                            return callback(err);
                        }
                        if (dstStat && areIdentical(srcStat, dstStat)) return callback(null);

                        const dir = path.dirname(dstpath);
                        pathExists(dir, (err, dirExists) => {
                            if (err) return callback(err);
                            if (dirExists) return makeLink(srcpath, dstpath);
                            mkdir.mkdirs(dir, (err) => {
                                if (err) return callback(err);
                                makeLink(srcpath, dstpath);
                            });
                        });
                    });
                });
            }

            function createLinkSync(srcpath, dstpath) {
                let dstStat;
                try {
                    dstStat = fs.lstatSync(dstpath);
                } catch {}

                try {
                    const srcStat = fs.lstatSync(srcpath);
                    if (dstStat && areIdentical(srcStat, dstStat)) return;
                } catch (err) {
                    err.message = err.message.replace('lstat', 'ensureLink');
                    throw err;
                }

                const dir = path.dirname(dstpath);
                const dirExists = fs.existsSync(dir);
                if (dirExists) return fs.linkSync(srcpath, dstpath);
                mkdir.mkdirsSync(dir);

                return fs.linkSync(srcpath, dstpath);
            }

            module.exports = {
                createLink: u(createLink),
                createLinkSync
            };

            /***/
        },
        /* 33 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromCallback;
            const path = __webpack_require__(4);
            const fs = __webpack_require__(8);
            const _mkdirs = __webpack_require__(20);
            const mkdirs = _mkdirs.mkdirs;
            const mkdirsSync = _mkdirs.mkdirsSync;

            const _symlinkPaths = __webpack_require__(34);
            const symlinkPaths = _symlinkPaths.symlinkPaths;
            const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

            const _symlinkType = __webpack_require__(35);
            const symlinkType = _symlinkType.symlinkType;
            const symlinkTypeSync = _symlinkType.symlinkTypeSync;

            const pathExists = __webpack_require__(23).pathExists;

            const { areIdentical } = __webpack_require__(25);

            function createSymlink(srcpath, dstpath, type, callback) {
                callback = typeof type === 'function' ? type : callback;
                type = typeof type === 'function' ? false : type;

                fs.lstat(dstpath, (err, stats) => {
                    if (!err && stats.isSymbolicLink()) {
                        Promise.all([fs.stat(srcpath), fs.stat(dstpath)]).then(
                            ([srcStat, dstStat]) => {
                                if (areIdentical(srcStat, dstStat)) return callback(null);
                                _createSymlink(srcpath, dstpath, type, callback);
                            }
                        );
                    } else _createSymlink(srcpath, dstpath, type, callback);
                });
            }

            function _createSymlink(srcpath, dstpath, type, callback) {
                symlinkPaths(srcpath, dstpath, (err, relative) => {
                    if (err) return callback(err);
                    srcpath = relative.toDst;
                    symlinkType(relative.toCwd, type, (err, type) => {
                        if (err) return callback(err);
                        const dir = path.dirname(dstpath);
                        pathExists(dir, (err, dirExists) => {
                            if (err) return callback(err);
                            if (dirExists) return fs.symlink(srcpath, dstpath, type, callback);
                            mkdirs(dir, (err) => {
                                if (err) return callback(err);
                                fs.symlink(srcpath, dstpath, type, callback);
                            });
                        });
                    });
                });
            }

            function createSymlinkSync(srcpath, dstpath, type) {
                let stats;
                try {
                    stats = fs.lstatSync(dstpath);
                } catch {}
                if (stats && stats.isSymbolicLink()) {
                    const srcStat = fs.statSync(srcpath);
                    const dstStat = fs.statSync(dstpath);
                    if (areIdentical(srcStat, dstStat)) return;
                }

                const relative = symlinkPathsSync(srcpath, dstpath);
                srcpath = relative.toDst;
                type = symlinkTypeSync(relative.toCwd, type);
                const dir = path.dirname(dstpath);
                const exists = fs.existsSync(dir);
                if (exists) return fs.symlinkSync(srcpath, dstpath, type);
                mkdirsSync(dir);
                return fs.symlinkSync(srcpath, dstpath, type);
            }

            module.exports = {
                createSymlink: u(createSymlink),
                createSymlinkSync
            };

            /***/
        },
        /* 34 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const path = __webpack_require__(4);
            const fs = __webpack_require__(10);
            const pathExists = __webpack_require__(23).pathExists;

            /**
             * Function that returns two types of paths, one relative to symlink, and one
             * relative to the current working directory. Checks if path is absolute or
             * relative. If the path is relative, this function checks if the path is
             * relative to symlink or relative to current working directory. This is an
             * initiative to find a smarter `srcpath` to supply when building symlinks.
             * This allows you to determine which path to use out of one of three possible
             * types of source paths. The first is an absolute path. This is detected by
             * `path.isAbsolute()`. When an absolute path is provided, it is checked to
             * see if it exists. If it does it's used, if not an error is returned
             * (callback)/ thrown (sync). The other two options for `srcpath` are a
             * relative url. By default Node's `fs.symlink` works by creating a symlink
             * using `dstpath` and expects the `srcpath` to be relative to the newly
             * created symlink. If you provide a `srcpath` that does not exist on the file
             * system it results in a broken symlink. To minimize this, the function
             * checks to see if the 'relative to symlink' source file exists, and if it
             * does it will use it. If it does not, it checks if there's a file that
             * exists that is relative to the current working directory, if does its used.
             * This preserves the expectations of the original fs.symlink spec and adds
             * the ability to pass in `relative to current working direcotry` paths.
             */

            function symlinkPaths(srcpath, dstpath, callback) {
                if (path.isAbsolute(srcpath)) {
                    return fs.lstat(srcpath, (err) => {
                        if (err) {
                            err.message = err.message.replace('lstat', 'ensureSymlink');
                            return callback(err);
                        }
                        return callback(null, {
                            toCwd: srcpath,
                            toDst: srcpath
                        });
                    });
                } else {
                    const dstdir = path.dirname(dstpath);
                    const relativeToDst = path.join(dstdir, srcpath);
                    return pathExists(relativeToDst, (err, exists) => {
                        if (err) return callback(err);
                        if (exists) {
                            return callback(null, {
                                toCwd: relativeToDst,
                                toDst: srcpath
                            });
                        } else {
                            return fs.lstat(srcpath, (err) => {
                                if (err) {
                                    err.message = err.message.replace('lstat', 'ensureSymlink');
                                    return callback(err);
                                }
                                return callback(null, {
                                    toCwd: srcpath,
                                    toDst: path.relative(dstdir, srcpath)
                                });
                            });
                        }
                    });
                }
            }

            function symlinkPathsSync(srcpath, dstpath) {
                let exists;
                if (path.isAbsolute(srcpath)) {
                    exists = fs.existsSync(srcpath);
                    if (!exists) throw new Error('absolute srcpath does not exist');
                    return {
                        toCwd: srcpath,
                        toDst: srcpath
                    };
                } else {
                    const dstdir = path.dirname(dstpath);
                    const relativeToDst = path.join(dstdir, srcpath);
                    exists = fs.existsSync(relativeToDst);
                    if (exists) {
                        return {
                            toCwd: relativeToDst,
                            toDst: srcpath
                        };
                    } else {
                        exists = fs.existsSync(srcpath);
                        if (!exists) throw new Error('relative srcpath does not exist');
                        return {
                            toCwd: srcpath,
                            toDst: path.relative(dstdir, srcpath)
                        };
                    }
                }
            }

            module.exports = {
                symlinkPaths,
                symlinkPathsSync
            };

            /***/
        },
        /* 35 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(10);

            function symlinkType(srcpath, type, callback) {
                callback = typeof type === 'function' ? type : callback;
                type = typeof type === 'function' ? false : type;
                if (type) return callback(null, type);
                fs.lstat(srcpath, (err, stats) => {
                    if (err) return callback(null, 'file');
                    type = stats && stats.isDirectory() ? 'dir' : 'file';
                    callback(null, type);
                });
            }

            function symlinkTypeSync(srcpath, type) {
                let stats;

                if (type) return type;
                try {
                    stats = fs.lstatSync(srcpath);
                } catch {
                    return 'file';
                }
                return stats && stats.isDirectory() ? 'dir' : 'file';
            }

            module.exports = {
                symlinkType,
                symlinkTypeSync
            };

            /***/
        },
        /* 36 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromPromise;
            const jsonFile = __webpack_require__(37);

            jsonFile.outputJson = u(__webpack_require__(40));
            jsonFile.outputJsonSync = __webpack_require__(42);
            // aliases
            jsonFile.outputJSON = jsonFile.outputJson;
            jsonFile.outputJSONSync = jsonFile.outputJsonSync;
            jsonFile.writeJSON = jsonFile.writeJson;
            jsonFile.writeJSONSync = jsonFile.writeJsonSync;
            jsonFile.readJSON = jsonFile.readJson;
            jsonFile.readJSONSync = jsonFile.readJsonSync;

            module.exports = jsonFile;

            /***/
        },
        /* 37 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const jsonFile = __webpack_require__(38);

            module.exports = {
                // jsonfile exports
                readJson: jsonFile.readFile,
                readJsonSync: jsonFile.readFileSync,
                writeJson: jsonFile.writeFile,
                writeJsonSync: jsonFile.writeFileSync
            };

            /***/
        },
        /* 38 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            let _fs;
            try {
                _fs = __webpack_require__(10);
            } catch (_) {
                _fs = __webpack_require__(3);
            }
            const universalify = __webpack_require__(9);
            const { stringify, stripBom } = __webpack_require__(39);

            async function _readFile(file, options = {}) {
                if (typeof options === 'string') {
                    options = { encoding: options };
                }

                const fs = options.fs || _fs;

                const shouldThrow = 'throws' in options ? options.throws : true;

                let data = await universalify.fromCallback(fs.readFile)(file, options);

                data = stripBom(data);

                let obj;
                try {
                    obj = JSON.parse(data, options ? options.reviver : null);
                } catch (err) {
                    if (shouldThrow) {
                        err.message = `${file}: ${err.message}`;
                        throw err;
                    } else {
                        return null;
                    }
                }

                return obj;
            }

            const readFile = universalify.fromPromise(_readFile);

            function readFileSync(file, options = {}) {
                if (typeof options === 'string') {
                    options = { encoding: options };
                }

                const fs = options.fs || _fs;

                const shouldThrow = 'throws' in options ? options.throws : true;

                try {
                    let content = fs.readFileSync(file, options);
                    content = stripBom(content);
                    return JSON.parse(content, options.reviver);
                } catch (err) {
                    if (shouldThrow) {
                        err.message = `${file}: ${err.message}`;
                        throw err;
                    } else {
                        return null;
                    }
                }
            }

            async function _writeFile(file, obj, options = {}) {
                const fs = options.fs || _fs;

                const str = stringify(obj, options);

                await universalify.fromCallback(fs.writeFile)(file, str, options);
            }

            const writeFile = universalify.fromPromise(_writeFile);

            function writeFileSync(file, obj, options = {}) {
                const fs = options.fs || _fs;

                const str = stringify(obj, options);
                // not sure if fs.writeFileSync returns anything, but just in case
                return fs.writeFileSync(file, str, options);
            }

            const jsonfile = {
                readFile,
                readFileSync,
                writeFile,
                writeFileSync
            };

            module.exports = jsonfile;

            /***/
        },
        /* 39 */
        /***/ (module) => {
            function stringify(obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
                const EOF = finalEOL ? EOL : '';
                const str = JSON.stringify(obj, replacer, spaces);

                return str.replace(/\n/g, EOL) + EOF;
            }

            function stripBom(content) {
                // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
                if (Buffer.isBuffer(content)) content = content.toString('utf8');
                return content.replace(/^\uFEFF/, '');
            }

            module.exports = { stringify, stripBom };

            /***/
        },
        /* 40 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const { stringify } = __webpack_require__(39);
            const { outputFile } = __webpack_require__(41);

            async function outputJson(file, data, options = {}) {
                const str = stringify(data, options);

                await outputFile(file, str, options);
            }

            module.exports = outputJson;

            /***/
        },
        /* 41 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromCallback;
            const fs = __webpack_require__(10);
            const path = __webpack_require__(4);
            const mkdir = __webpack_require__(20);
            const pathExists = __webpack_require__(23).pathExists;

            function outputFile(file, data, encoding, callback) {
                if (typeof encoding === 'function') {
                    callback = encoding;
                    encoding = 'utf8';
                }

                const dir = path.dirname(file);
                pathExists(dir, (err, itDoes) => {
                    if (err) return callback(err);
                    if (itDoes) return fs.writeFile(file, data, encoding, callback);

                    mkdir.mkdirs(dir, (err) => {
                        if (err) return callback(err);

                        fs.writeFile(file, data, encoding, callback);
                    });
                });
            }

            function outputFileSync(file, ...args) {
                const dir = path.dirname(file);
                if (fs.existsSync(dir)) {
                    return fs.writeFileSync(file, ...args);
                }
                mkdir.mkdirsSync(dir);
                fs.writeFileSync(file, ...args);
            }

            module.exports = {
                outputFile: u(outputFile),
                outputFileSync
            };

            /***/
        },
        /* 42 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const { stringify } = __webpack_require__(39);
            const { outputFileSync } = __webpack_require__(41);

            function outputJsonSync(file, data, options) {
                const str = stringify(data, options);

                outputFileSync(file, str, options);
            }

            module.exports = outputJsonSync;

            /***/
        },
        /* 43 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const u = __webpack_require__(9).fromCallback;
            module.exports = {
                move: u(__webpack_require__(44)),
                moveSync: __webpack_require__(45)
            };

            /***/
        },
        /* 44 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(10);
            const path = __webpack_require__(4);
            const copy = __webpack_require__(18).copy;
            const remove = __webpack_require__(28).remove;
            const mkdirp = __webpack_require__(20).mkdirp;
            const pathExists = __webpack_require__(23).pathExists;
            const stat = __webpack_require__(25);

            function move(src, dest, opts, cb) {
                if (typeof opts === 'function') {
                    cb = opts;
                    opts = {};
                }

                opts = opts || {};

                const overwrite = opts.overwrite || opts.clobber || false;

                stat.checkPaths(src, dest, 'move', opts, (err, stats) => {
                    if (err) return cb(err);
                    const { srcStat, isChangingCase = false } = stats;
                    stat.checkParentPaths(src, srcStat, dest, 'move', (err) => {
                        if (err) return cb(err);
                        if (isParentRoot(dest))
                            return doRename(src, dest, overwrite, isChangingCase, cb);
                        mkdirp(path.dirname(dest), (err) => {
                            if (err) return cb(err);
                            return doRename(src, dest, overwrite, isChangingCase, cb);
                        });
                    });
                });
            }

            function isParentRoot(dest) {
                const parent = path.dirname(dest);
                const parsedPath = path.parse(parent);
                return parsedPath.root === parent;
            }

            function doRename(src, dest, overwrite, isChangingCase, cb) {
                if (isChangingCase) return rename(src, dest, overwrite, cb);
                if (overwrite) {
                    return remove(dest, (err) => {
                        if (err) return cb(err);
                        return rename(src, dest, overwrite, cb);
                    });
                }
                pathExists(dest, (err, destExists) => {
                    if (err) return cb(err);
                    if (destExists) return cb(new Error('dest already exists.'));
                    return rename(src, dest, overwrite, cb);
                });
            }

            function rename(src, dest, overwrite, cb) {
                fs.rename(src, dest, (err) => {
                    if (!err) return cb();
                    if (err.code !== 'EXDEV') return cb(err);
                    return moveAcrossDevice(src, dest, overwrite, cb);
                });
            }

            function moveAcrossDevice(src, dest, overwrite, cb) {
                const opts = {
                    overwrite,
                    errorOnExist: true
                };
                copy(src, dest, opts, (err) => {
                    if (err) return cb(err);
                    return remove(src, cb);
                });
            }

            module.exports = move;

            /***/
        },
        /* 45 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const fs = __webpack_require__(10);
            const path = __webpack_require__(4);
            const copySync = __webpack_require__(18).copySync;
            const removeSync = __webpack_require__(28).removeSync;
            const mkdirpSync = __webpack_require__(20).mkdirpSync;
            const stat = __webpack_require__(25);

            function moveSync(src, dest, opts) {
                opts = opts || {};
                const overwrite = opts.overwrite || opts.clobber || false;

                const { srcStat, isChangingCase = false } = stat.checkPathsSync(
                    src,
                    dest,
                    'move',
                    opts
                );
                stat.checkParentPathsSync(src, srcStat, dest, 'move');
                if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest));
                return doRename(src, dest, overwrite, isChangingCase);
            }

            function isParentRoot(dest) {
                const parent = path.dirname(dest);
                const parsedPath = path.parse(parent);
                return parsedPath.root === parent;
            }

            function doRename(src, dest, overwrite, isChangingCase) {
                if (isChangingCase) return rename(src, dest, overwrite);
                if (overwrite) {
                    removeSync(dest);
                    return rename(src, dest, overwrite);
                }
                if (fs.existsSync(dest)) throw new Error('dest already exists.');
                return rename(src, dest, overwrite);
            }

            function rename(src, dest, overwrite) {
                try {
                    fs.renameSync(src, dest);
                } catch (err) {
                    if (err.code !== 'EXDEV') throw err;
                    return moveAcrossDevice(src, dest, overwrite);
                }
            }

            function moveAcrossDevice(src, dest, overwrite) {
                const opts = {
                    overwrite,
                    errorOnExist: true
                };
                copySync(src, dest, opts);
                return removeSync(src);
            }

            module.exports = moveSync;

            /***/
        },
        /* 46 */
        /***/ (module) => {
            'use strict';
            module.exports = JSON.parse(
                '{"abap":{"ext":"abap","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"bat":{"ext":"bat","comments-start":"","comments-split":"","comments-end":"","comments-oneline":"::"},"bibtex":{"ext":"bib","comments-start":"@Comment={","comments-split":" ","comments-end":"}","comments-oneline":"%"},"clojure":{"ext":"clj","comments-start":"(comment","comments-split":" ","comments-end":")","comments-oneline":";;"},"coffeescript":{"ext":"coffee","comments-start":"###","comments-split":"#","comments-end":"###","comments-oneline":"#"},"c":{"ext":"c","comments-start":"/**","comments-end":" */","comments-split":" *","comments-oneline":"//"},"cpp":{"ext":"cpp","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"csharp":{"ext":"cs","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"cuda-cpp":{"ext":"cpp","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"css":{"ext":"css","comments-start":"/*","comments-split":" *","comments-end":" */","comments-oneline":""},"diff":{"ext":"diff","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"dockerfile":{"ext":"txt","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"fsharp":{"ext":"fs","comments-start":"(*","comments-split":" *","comments-end":"*)","comments-oneline":"///"},"git-rebase":{"ext":"txt","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"go":{"ext":"go","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"groovy":{"ext":"groovy","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"handlebars":{"ext":"txt","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"haml":{"ext":"haml","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"html":{"ext":"html","comments-start":"<!--","comments-split":" ","comments-end":"-->","comments-oneline":""},"ini":{"ext":"ini","comments-start":"","comments-split":"","comments-end":"","comments-oneline":";"},"java":{"ext":"java","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"javascript":{"ext":"js","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"javascriptreact":{"ext":"js","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"json":{"ext":"json","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"jsonc":{"ext":"jsonc","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"latex":{"ext":"tex","comments-start":"\\\\begin{comment} ","comments-split":"  %","comments-end":"\\\\end{comment} ","comments-oneline":""},"less":{"ext":"less","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"lua":{"ext":"lua","comments-start":"--[[","comments-split":" ","comments-end":"]]--","comments-oneline":""},"makefile":{"ext":"","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"markdown":{"ext":"md","comments-start":"<!--","comments-split":" ","comments-end":"-->","comments-oneline":"[//]: #"},"objective-c":{"ext":"c","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"objective-cpp":{"ext":"cpp","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"perl":{"ext":"txt","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"php":{"ext":"php","comments-start":"/**","comments-split":" *","comments-end":" */","comments-oneline":"//"},"plaintext":{"ext":"txt","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"powershell":{"ext":"ps1","comments-start":"<#","comments-split":" #","comments-end":"#>","comments-oneline":"#"},"pug":{"ext":"pug","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"python":{"ext":"py","comments-start":"\\"\\"\\"","comments-split":"  :","comments-end":"\\"\\"\\"","comments-oneline":"#"},"r":{"ext":"txt","comments-start":"","comments-split":"","comments-end":"","comments-oneline":"#"},"razor":{"ext":"razor","comments-start":"@*","comments-split":" *","comments-end":"*@","comments-oneline":""},"ruby":{"ext":"rb","comments-start":"=begin","comments-split":"=end","comments-end":" ","comments-oneline":"#"},"rust":{"ext":"rs","comments-start":"/*","comments-split":" *","comments-end":"*/","comments-oneline":"//"},"scss":{"ext":"scss","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"shaderlab":{"ext":"txt","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"shellscript":{"ext":"sh","comments-start":": \'","comments-split":" ","comments-end":"\'","comments-oneline":"#"},"slim":{"ext":"txt","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"sql":{"ext":"sql","comments-start":"/*","comments-split":" *","comments-end":"*/","comments-oneline":"--"},"stylus":{"ext":"styl","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"swift":{"ext":"swift","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"typescript":{"ext":"ts","comments-start":"/*","comments-split":" *","comments-end":"*/","comments-oneline":"//"},"typescriptreact":{"ext":"ts","comments-start":"/*","comments-split":" *","comments-end":"*/","comments-oneline":"//"},"tex":{"ext":"tex","comments-start":"","comments-split":"","comments-end":"","comments-oneline":""},"vb":{"ext":"vb","comments-start":"","comments-split":"","comments-end":"","comments-oneline":"\'"},"vue":{"ext":"vue","comments-start":"/*","comments-split":" *","comments-end":"*/","comments-oneline":"//"},"vue-html":{"ext":"vue","comments-start":"<!--","comments-split":" ","comments-end":"-->","comments-oneline":""},"xml":{"ext":"xml","comments-start":"<!--","comments-split":" ","comments-end":"-->","comments-oneline":""},"xsl":{"ext":"xsl","comments-start":"<!--","comments-split":" ","comments-end":"-->","comments-oneline":""},"yaml":{"ext":"yaml","comments-start":"","comments-split":"","comments-end":"","comments-oneline":"#"}}'
            );

            /***/
        },
        /* 47 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          var desc = Object.getOwnPropertyDescriptor(m, k);
                          if (
                              !desc ||
                              ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
                          ) {
                              desc = {
                                  enumerable: true,
                                  get: function () {
                                      return m[k];
                                  }
                              };
                          }
                          Object.defineProperty(o, k2, desc);
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, 'default', { enumerable: true, value: v });
                      }
                    : function (o, v) {
                          o['default'] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.syncCloud = exports.uploadDepsFiles = exports.downloadDepsFiles = void 0;
            const fs = __importStar(__webpack_require__(3));
            const path = __importStar(__webpack_require__(4));
            const vscode = __importStar(__webpack_require__(1));
            const utils = __importStar(__webpack_require__(5));
            const syncs = __importStar(__webpack_require__(47));
            const webdav_1 = __webpack_require__(48);
            async function downloadDepsFiles(localFolderPath, syncFolderPath, client) {
                const syncFolder = await client.getDirectoryContents(syncFolderPath);
                const syncItems = syncFolder.map((x) => x.basename);
                syncFolder.forEach(async function (syncFileInfo) {
                    let syncFullPath = syncFileInfo.filename;
                    let syncFileName = syncFileInfo.basename;
                    let localFullPath = path.resolve(localFolderPath, syncFileName);
                    if (syncFileInfo.type !== 'directory') {
                        const syncStatus = await client.stat(syncFullPath);
                        const syncModTime = new Date(syncStatus.lastModify).getTime();
                        let localModTime = 0;
                        if (fs.existsSync(localFullPath)) {
                            fs.stat(localFullPath, async (err, stat) => {
                                localModTime = stat.mtimeMs;
                            });
                        }
                        if (localModTime !== syncModTime) {
                            const content = await client.getFileContents(syncFullPath, {
                                format: 'text'
                            });
                            fs.writeFileSync(localFullPath, content, {
                                encoding: 'utf8',
                                flag: 'w+'
                            });
                        }
                    } else {
                        if (!fs.existsSync(localFullPath)) {
                            fs.mkdir(path.join(localFullPath), (err) =>
                                console.log('文件不存在,已创建')
                            );
                        }
                        downloadDepsFiles(localFullPath, syncFullPath, client);
                    }
                });
                const localItems = fs.readdirSync(localFolderPath);
                const diffItems = localItems.filter((x) => !syncItems.includes(x));
                diffItems.forEach(async (x) => {
                    fs.rmSync(path.join(localFolderPath, x), { recursive: true, force: true });
                });
            }
            exports.downloadDepsFiles = downloadDepsFiles;
            async function uploadDepsFiles(localFolderPath, syncFolderPath, client) {
                const localItems = fs.readdirSync(localFolderPath);
                localItems.forEach(async function (localFileName) {
                    let localFullPath = path.resolve(localFolderPath, localFileName);
                    let syncFullPath = path
                        .join(syncFolderPath, localFileName)
                        .split(path.sep)
                        .join('/');
                    let isFolder = fs.lstatSync(localFullPath).isDirectory();
                    if (!isFolder) {
                        console.log('正在上传' + localFullPath);
                        fs.stat(localFullPath, async (err, stat) => {
                            let syncModTime = 0;
                            const localModTime = stat.mtimeMs;
                            if ((await client.exists(syncFullPath)) === true) {
                                const syncStatus = await client.stat(syncFullPath);
                                syncModTime = new Date(syncStatus.lastModify).getTime();
                            }
                            if (localModTime !== syncModTime) {
                                fs.readFile(localFullPath, 'utf8', async function (err, data) {
                                    await client.putFileContents(syncFullPath, data, {
                                        overwrite: true
                                    });
                                });
                            }
                        });
                    } else {
                        if ((await client.exists(syncFullPath)) === false) {
                            await client.createDirectory(syncFullPath);
                        }
                        uploadDepsFiles(localFullPath, syncFullPath, client);
                    }
                });
                const syncRes = await client.getDirectoryContents(syncFolderPath);
                const syncItems = syncRes.map((x) => x.basename);
                const diffItems = syncItems.filter((x) => !localItems.includes(x));
                diffItems.forEach(async (x) => {
                    await client.deleteFile(syncFolderPath + '/' + x);
                });
            }
            exports.uploadDepsFiles = uploadDepsFiles;
            /**
             * @param srcThis
             * @param syncInfo 上传|下载
             * @param localInfo 云端|本地
             * @param syncMode 0|1 上传|下载
             */
            async function syncCloud(srcThis, syncInfo, localInfo, syncMode, snippetCatConfig) {
                srcThis.checkRoot();
                let key = await vscode.window.showInputBox({
                    placeHolder: `确定${syncInfo}吗,这将覆盖${localInfo}数据`,
                    value: `确定${syncInfo}吗,这将覆盖${localInfo}数据`,
                    valueSelection: [0, 2]
                });
                if (key) {
                    vscode.window.showInformationMessage('正在备份中');
                    const stockPath = srcThis.getStockPath().split('\\').join('/');
                    utils.recoveryStock(stockPath);
                    vscode.window.showInformationMessage('备份成功');
                    const syncModel = snippetCatConfig.get('syncModel');
                    if (syncModel === 'github') {
                        vscode.window.showInformationMessage(`正在使用GITHUB${syncInfo}`);
                        let { push, pull } = snippetCatConfig.get('github');
                        utils.runCMD(stockPath, [push, pull][syncMode], srcThis);
                    } else if (syncModel === 'webdav') {
                        let { url, username, password } = snippetCatConfig.get('webdav');
                        const client = (0, webdav_1.createClient)(url, {
                            username: username,
                            password: password
                        });
                        try {
                            if ((await client.exists('/Snippet Cat')) === false) {
                                await client.createDirectory('/Snippet Cat');
                            }
                            vscode.window.showInformationMessage(`正在使用WEBDAV${syncInfo}`);
                            if (syncMode === 0) {
                                await syncs.uploadDepsFiles(stockPath, '/Snippet Cat', client);
                                vscode.window.showInformationMessage('${syncInfo}完毕');
                            } else {
                                await syncs.downloadDepsFiles(stockPath, '/Snippet Cat', client);
                                vscode.window.showInformationMessage('${syncInfo}完毕');
                                srcThis.refresh();
                            }
                        } catch (e) {
                            vscode.window.showErrorMessage(e.message);
                        }
                    }
                } else {
                    vscode.window.showErrorMessage(`用户取消${syncInfo}`);
                }
            }
            exports.syncCloud = syncCloud;

            /***/
        },
        /* 48 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          var desc = Object.getOwnPropertyDescriptor(m, k);
                          if (
                              !desc ||
                              ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
                          ) {
                              desc = {
                                  enumerable: true,
                                  get: function () {
                                      return m[k];
                                  }
                              };
                          }
                          Object.defineProperty(o, k2, desc);
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __exportStar =
                (this && this.__exportStar) ||
                function (m, exports) {
                    for (var p in m)
                        if (p !== 'default' && !Object.prototype.hasOwnProperty.call(exports, p))
                            __createBinding(exports, m, p);
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.parseXML =
                exports.parseStat =
                exports.getPatcher =
                exports.createClient =
                    void 0;
            var factory_1 = __webpack_require__(49);
            Object.defineProperty(exports, 'createClient', {
                enumerable: true,
                get: function () {
                    return factory_1.createClient;
                }
            });
            var patcher_1 = __webpack_require__(142);
            Object.defineProperty(exports, 'getPatcher', {
                enumerable: true,
                get: function () {
                    return patcher_1.getPatcher;
                }
            });
            __exportStar(__webpack_require__(74), exports);
            var dav_1 = __webpack_require__(154);
            Object.defineProperty(exports, 'parseStat', {
                enumerable: true,
                get: function () {
                    return dav_1.parseStat;
                }
            });
            Object.defineProperty(exports, 'parseXML', {
                enumerable: true,
                get: function () {
                    return dav_1.parseXML;
                }
            });

            /***/
        },
        /* 49 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.createClient = void 0;
            var url_1 = __webpack_require__(50);
            var index_1 = __webpack_require__(57);
            var copyFile_1 = __webpack_require__(75);
            var createDirectory_1 = __webpack_require__(152);
            var createStream_1 = __webpack_require__(166);
            var customRequest_1 = __webpack_require__(167);
            var deleteFile_1 = __webpack_require__(168);
            var exists_1 = __webpack_require__(169);
            var directoryContents_1 = __webpack_require__(170);
            var getFileContents_1 = __webpack_require__(171);
            var lock_1 = __webpack_require__(172);
            var getQuota_1 = __webpack_require__(174);
            var stat_1 = __webpack_require__(153);
            var moveFile_1 = __webpack_require__(176);
            var putFileContents_1 = __webpack_require__(177);
            var types_1 = __webpack_require__(74);
            var DEFAULT_CONTACT_HREF =
                'https://github.com/perry-mitchell/webdav-client/blob/master/LOCK_CONTACT.md';
            function createClient(remoteURL, options) {
                if (options === void 0) {
                    options = {};
                }
                var _a = options.authType,
                    authTypeRaw = _a === void 0 ? null : _a,
                    _b = options.contactHref,
                    contactHref = _b === void 0 ? DEFAULT_CONTACT_HREF : _b,
                    _c = options.headers,
                    headers = _c === void 0 ? {} : _c,
                    httpAgent = options.httpAgent,
                    httpsAgent = options.httpsAgent,
                    maxBodyLength = options.maxBodyLength,
                    maxContentLength = options.maxContentLength,
                    password = options.password,
                    token = options.token,
                    username = options.username,
                    withCredentials = options.withCredentials;
                var authType = authTypeRaw;
                if (!authType) {
                    authType =
                        username || password ? types_1.AuthType.Password : types_1.AuthType.None;
                }
                var context = {
                    authType: authType,
                    contactHref: contactHref,
                    headers: Object.assign({}, headers),
                    httpAgent: httpAgent,
                    httpsAgent: httpsAgent,
                    maxBodyLength: maxBodyLength,
                    maxContentLength: maxContentLength,
                    remotePath: (0, url_1.extractURLPath)(remoteURL),
                    remoteURL: remoteURL,
                    password: password,
                    token: token,
                    username: username,
                    withCredentials: withCredentials
                };
                (0, index_1.setupAuth)(context, username, password, token);
                return {
                    copyFile: function (filename, destination, options) {
                        return (0, copyFile_1.copyFile)(context, filename, destination, options);
                    },
                    createDirectory: function (path, options) {
                        return (0, createDirectory_1.createDirectory)(context, path, options);
                    },
                    createReadStream: function (filename, options) {
                        return (0, createStream_1.createReadStream)(context, filename, options);
                    },
                    createWriteStream: function (filename, options, callback) {
                        return (0, createStream_1.createWriteStream)(
                            context,
                            filename,
                            options,
                            callback
                        );
                    },
                    customRequest: function (path, requestOptions) {
                        return (0, customRequest_1.customRequest)(context, path, requestOptions);
                    },
                    deleteFile: function (filename, options) {
                        return (0, deleteFile_1.deleteFile)(context, filename, options);
                    },
                    exists: function (path, options) {
                        return (0, exists_1.exists)(context, path, options);
                    },
                    getDirectoryContents: function (path, options) {
                        return (0, directoryContents_1.getDirectoryContents)(
                            context,
                            path,
                            options
                        );
                    },
                    getFileContents: function (filename, options) {
                        return (0, getFileContents_1.getFileContents)(context, filename, options);
                    },
                    getFileDownloadLink: function (filename) {
                        return (0, getFileContents_1.getFileDownloadLink)(context, filename);
                    },
                    getFileUploadLink: function (filename) {
                        return (0, putFileContents_1.getFileUploadLink)(context, filename);
                    },
                    getHeaders: function () {
                        return Object.assign({}, context.headers);
                    },
                    getQuota: function (options) {
                        return (0, getQuota_1.getQuota)(context, options);
                    },
                    lock: function (path, options) {
                        return (0, lock_1.lock)(context, path, options);
                    },
                    moveFile: function (filename, destinationFilename, options) {
                        return (0, moveFile_1.moveFile)(
                            context,
                            filename,
                            destinationFilename,
                            options
                        );
                    },
                    putFileContents: function (filename, data, options) {
                        return (0, putFileContents_1.putFileContents)(
                            context,
                            filename,
                            data,
                            options
                        );
                    },
                    setHeaders: function (headers) {
                        context.headers = Object.assign({}, headers);
                    },
                    stat: function (path, options) {
                        return (0, stat_1.getStat)(context, path, options);
                    },
                    unlock: function (path, token, options) {
                        return (0, lock_1.unlock)(context, path, token, options);
                    }
                };
            }
            exports.createClient = createClient;

            /***/
        },
        /* 50 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.normaliseHREF = exports.joinURL = exports.extractURLPath = void 0;
            var url_parse_1 = __importDefault(__webpack_require__(51));
            var url_join_1 = __importDefault(__webpack_require__(54));
            var path_1 = __webpack_require__(55);
            function extractURLPath(fullURL) {
                var url = new url_parse_1.default(fullURL);
                var urlPath = url.pathname;
                if (urlPath.length <= 0) {
                    urlPath = '/';
                }
                return (0, path_1.normalisePath)(urlPath);
            }
            exports.extractURLPath = extractURLPath;
            function joinURL() {
                var parts = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    parts[_i] = arguments[_i];
                }
                return (0, url_join_1.default)(
                    parts.reduce(function (output, nextPart, partIndex) {
                        if (
                            partIndex === 0 ||
                            nextPart !== '/' ||
                            (nextPart === '/' && output[output.length - 1] !== '/')
                        ) {
                            output.push(nextPart);
                        }
                        return output;
                    }, [])
                );
            }
            exports.joinURL = joinURL;
            function normaliseHREF(href) {
                var normalisedHref = href.replace(/^https?:\/\/[^\/]+/, '');
                return normalisedHref;
            }
            exports.normaliseHREF = normaliseHREF;

            /***/
        },
        /* 51 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var required = __webpack_require__(52),
                qs = __webpack_require__(53),
                controlOrWhitespace =
                    /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/,
                CRHTLF = /[\n\r\t]/g,
                slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
                port = /:\d+$/,
                protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i,
                windowsDriveLetter = /^[a-zA-Z]:/;

            /**
             * Remove control characters and whitespace from the beginning of a string.
             *
             * @param {Object|String} str String to trim.
             * @returns {String} A new string representing `str` stripped of control
             *     characters and whitespace from its beginning.
             * @public
             */
            function trimLeft(str) {
                return (str ? str : '').toString().replace(controlOrWhitespace, '');
            }

            /**
             * These are the parse rules for the URL parser, it informs the parser
             * about:
             *
             * 0. The char it Needs to parse, if it's a string it should be done using
             *    indexOf, RegExp using exec and NaN means set as current value.
             * 1. The property we should set when parsing this value.
             * 2. Indication if it's backwards or forward parsing, when set as number it's
             *    the value of extra chars that should be split off.
             * 3. Inherit from location if non existing in the parser.
             * 4. `toLowerCase` the resulting value.
             */
            var rules = [
                ['#', 'hash'], // Extract from the back.
                ['?', 'query'], // Extract from the back.
                function sanitize(address, url) {
                    // Sanitize what is left of the address
                    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
                },
                ['/', 'pathname'], // Extract from the back.
                ['@', 'auth', 1], // Extract from the front.
                [NaN, 'host', undefined, 1, 1], // Set left over value.
                [/:(\d*)$/, 'port', undefined, 1], // RegExp the back.
                [NaN, 'hostname', undefined, 1, 1] // Set left over.
            ];

            /**
             * These properties should not be copied or inherited from. This is only needed
             * for all non blob URL's as a blob URL does not include a hash, only the
             * origin.
             *
             * @type {Object}
             * @private
             */
            var ignore = { hash: 1, query: 1 };

            /**
             * The location object differs when your code is loaded through a normal page,
             * Worker or through a worker using a blob. And with the blobble begins the
             * trouble as the location object will contain the URL of the blob, not the
             * location of the page where our code is loaded in. The actual origin is
             * encoded in the `pathname` so we can thankfully generate a good "default"
             * location from it so we can generate proper relative URL's again.
             *
             * @param {Object|String} loc Optional default location object.
             * @returns {Object} lolcation object.
             * @public
             */
            function lolcation(loc) {
                var globalVar;

                if (typeof window !== 'undefined') globalVar = window;
                else if (typeof global !== 'undefined') globalVar = global;
                else if (typeof self !== 'undefined') globalVar = self;
                else globalVar = {};

                var location = globalVar.location || {};
                loc = loc || location;

                var finaldestination = {},
                    type = typeof loc,
                    key;

                if ('blob:' === loc.protocol) {
                    finaldestination = new Url(unescape(loc.pathname), {});
                } else if ('string' === type) {
                    finaldestination = new Url(loc, {});
                    for (key in ignore) delete finaldestination[key];
                } else if ('object' === type) {
                    for (key in loc) {
                        if (key in ignore) continue;
                        finaldestination[key] = loc[key];
                    }

                    if (finaldestination.slashes === undefined) {
                        finaldestination.slashes = slashes.test(loc.href);
                    }
                }

                return finaldestination;
            }

            /**
             * Check whether a protocol scheme is special.
             *
             * @param {String} The protocol scheme of the URL
             * @return {Boolean} `true` if the protocol scheme is special, else `false`
             * @private
             */
            function isSpecial(scheme) {
                return (
                    scheme === 'file:' ||
                    scheme === 'ftp:' ||
                    scheme === 'http:' ||
                    scheme === 'https:' ||
                    scheme === 'ws:' ||
                    scheme === 'wss:'
                );
            }

            /**
             * @typedef ProtocolExtract
             * @type Object
             * @property {String} protocol Protocol matched in the URL, in lowercase.
             * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
             * @property {String} rest Rest of the URL that is not part of the protocol.
             */

            /**
             * Extract protocol information from a URL with/without double slash ("//").
             *
             * @param {String} address URL we want to extract from.
             * @param {Object} location
             * @return {ProtocolExtract} Extracted information.
             * @private
             */
            function extractProtocol(address, location) {
                address = trimLeft(address);
                address = address.replace(CRHTLF, '');
                location = location || {};

                var match = protocolre.exec(address);
                var protocol = match[1] ? match[1].toLowerCase() : '';
                var forwardSlashes = !!match[2];
                var otherSlashes = !!match[3];
                var slashesCount = 0;
                var rest;

                if (forwardSlashes) {
                    if (otherSlashes) {
                        rest = match[2] + match[3] + match[4];
                        slashesCount = match[2].length + match[3].length;
                    } else {
                        rest = match[2] + match[4];
                        slashesCount = match[2].length;
                    }
                } else {
                    if (otherSlashes) {
                        rest = match[3] + match[4];
                        slashesCount = match[3].length;
                    } else {
                        rest = match[4];
                    }
                }

                if (protocol === 'file:') {
                    if (slashesCount >= 2) {
                        rest = rest.slice(2);
                    }
                } else if (isSpecial(protocol)) {
                    rest = match[4];
                } else if (protocol) {
                    if (forwardSlashes) {
                        rest = rest.slice(2);
                    }
                } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
                    rest = match[4];
                }

                return {
                    protocol: protocol,
                    slashes: forwardSlashes || isSpecial(protocol),
                    slashesCount: slashesCount,
                    rest: rest
                };
            }

            /**
             * Resolve a relative URL pathname against a base URL pathname.
             *
             * @param {String} relative Pathname of the relative URL.
             * @param {String} base Pathname of the base URL.
             * @return {String} Resolved pathname.
             * @private
             */
            function resolve(relative, base) {
                if (relative === '') return base;

                var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),
                    i = path.length,
                    last = path[i - 1],
                    unshift = false,
                    up = 0;

                while (i--) {
                    if (path[i] === '.') {
                        path.splice(i, 1);
                    } else if (path[i] === '..') {
                        path.splice(i, 1);
                        up++;
                    } else if (up) {
                        if (i === 0) unshift = true;
                        path.splice(i, 1);
                        up--;
                    }
                }

                if (unshift) path.unshift('');
                if (last === '.' || last === '..') path.push('');

                return path.join('/');
            }

            /**
             * The actual URL instance. Instead of returning an object we've opted-in to
             * create an actual constructor as it's much more memory efficient and
             * faster and it pleases my OCD.
             *
             * It is worth noting that we should not use `URL` as class name to prevent
             * clashes with the global URL instance that got introduced in browsers.
             *
             * @constructor
             * @param {String} address URL we want to parse.
             * @param {Object|String} [location] Location defaults for relative paths.
             * @param {Boolean|Function} [parser] Parser for the query string.
             * @private
             */
            function Url(address, location, parser) {
                address = trimLeft(address);
                address = address.replace(CRHTLF, '');

                if (!(this instanceof Url)) {
                    return new Url(address, location, parser);
                }

                var relative,
                    extracted,
                    parse,
                    instruction,
                    index,
                    key,
                    instructions = rules.slice(),
                    type = typeof location,
                    url = this,
                    i = 0;

                //
                // The following if statements allows this module two have compatibility with
                // 2 different API:
                //
                // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
                //    where the boolean indicates that the query string should also be parsed.
                //
                // 2. The `URL` interface of the browser which accepts a URL, object as
                //    arguments. The supplied object will be used as default values / fall-back
                //    for relative paths.
                //
                if ('object' !== type && 'string' !== type) {
                    parser = location;
                    location = null;
                }

                if (parser && 'function' !== typeof parser) parser = qs.parse;

                location = lolcation(location);

                //
                // Extract protocol information before running the instructions.
                //
                extracted = extractProtocol(address || '', location);
                relative = !extracted.protocol && !extracted.slashes;
                url.slashes = extracted.slashes || (relative && location.slashes);
                url.protocol = extracted.protocol || location.protocol || '';
                address = extracted.rest;

                //
                // When the authority component is absent the URL starts with a path
                // component.
                //
                if (
                    (extracted.protocol === 'file:' &&
                        (extracted.slashesCount !== 2 || windowsDriveLetter.test(address))) ||
                    (!extracted.slashes &&
                        (extracted.protocol ||
                            extracted.slashesCount < 2 ||
                            !isSpecial(url.protocol)))
                ) {
                    instructions[3] = [/(.*)/, 'pathname'];
                }

                for (; i < instructions.length; i++) {
                    instruction = instructions[i];

                    if (typeof instruction === 'function') {
                        address = instruction(address, url);
                        continue;
                    }

                    parse = instruction[0];
                    key = instruction[1];

                    if (parse !== parse) {
                        url[key] = address;
                    } else if ('string' === typeof parse) {
                        index = parse === '@' ? address.lastIndexOf(parse) : address.indexOf(parse);

                        if (~index) {
                            if ('number' === typeof instruction[2]) {
                                url[key] = address.slice(0, index);
                                address = address.slice(index + instruction[2]);
                            } else {
                                url[key] = address.slice(index);
                                address = address.slice(0, index);
                            }
                        }
                    } else if ((index = parse.exec(address))) {
                        url[key] = index[1];
                        address = address.slice(0, index.index);
                    }

                    url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : '');

                    //
                    // Hostname, host and protocol should be lowercased so they can be used to
                    // create a proper `origin`.
                    //
                    if (instruction[4]) url[key] = url[key].toLowerCase();
                }

                //
                // Also parse the supplied query string in to an object. If we're supplied
                // with a custom parser as function use that instead of the default build-in
                // parser.
                //
                if (parser) url.query = parser(url.query);

                //
                // If the URL is relative, resolve the pathname against the base URL.
                //
                if (
                    relative &&
                    location.slashes &&
                    url.pathname.charAt(0) !== '/' &&
                    (url.pathname !== '' || location.pathname !== '')
                ) {
                    url.pathname = resolve(url.pathname, location.pathname);
                }

                //
                // Default to a / for pathname if none exists. This normalizes the URL
                // to always have a /
                //
                if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
                    url.pathname = '/' + url.pathname;
                }

                //
                // We should not add port numbers if they are already the default port number
                // for a given protocol. As the host also contains the port number we're going
                // override it with the hostname which contains no port number.
                //
                if (!required(url.port, url.protocol)) {
                    url.host = url.hostname;
                    url.port = '';
                }

                //
                // Parse down the `auth` for the username and password.
                //
                url.username = url.password = '';

                if (url.auth) {
                    index = url.auth.indexOf(':');

                    if (~index) {
                        url.username = url.auth.slice(0, index);
                        url.username = encodeURIComponent(decodeURIComponent(url.username));

                        url.password = url.auth.slice(index + 1);
                        url.password = encodeURIComponent(decodeURIComponent(url.password));
                    } else {
                        url.username = encodeURIComponent(decodeURIComponent(url.auth));
                    }

                    url.auth = url.password ? url.username + ':' + url.password : url.username;
                }

                url.origin =
                    url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
                        ? url.protocol + '//' + url.host
                        : 'null';

                //
                // The href is just the compiled result.
                //
                url.href = url.toString();
            }

            /**
             * This is convenience method for changing properties in the URL instance to
             * insure that they all propagate correctly.
             *
             * @param {String} part          Property we need to adjust.
             * @param {Mixed} value          The newly assigned value.
             * @param {Boolean|Function} fn  When setting the query, it will be the function
             *                               used to parse the query.
             *                               When setting the protocol, double slash will be
             *                               removed from the final url if it is true.
             * @returns {URL} URL instance for chaining.
             * @public
             */
            function set(part, value, fn) {
                var url = this;

                switch (part) {
                    case 'query':
                        if ('string' === typeof value && value.length) {
                            value = (fn || qs.parse)(value);
                        }

                        url[part] = value;
                        break;

                    case 'port':
                        url[part] = value;

                        if (!required(value, url.protocol)) {
                            url.host = url.hostname;
                            url[part] = '';
                        } else if (value) {
                            url.host = url.hostname + ':' + value;
                        }

                        break;

                    case 'hostname':
                        url[part] = value;

                        if (url.port) value += ':' + url.port;
                        url.host = value;
                        break;

                    case 'host':
                        url[part] = value;

                        if (port.test(value)) {
                            value = value.split(':');
                            url.port = value.pop();
                            url.hostname = value.join(':');
                        } else {
                            url.hostname = value;
                            url.port = '';
                        }

                        break;

                    case 'protocol':
                        url.protocol = value.toLowerCase();
                        url.slashes = !fn;
                        break;

                    case 'pathname':
                    case 'hash':
                        if (value) {
                            var char = part === 'pathname' ? '/' : '#';
                            url[part] = value.charAt(0) !== char ? char + value : value;
                        } else {
                            url[part] = value;
                        }
                        break;

                    case 'username':
                    case 'password':
                        url[part] = encodeURIComponent(value);
                        break;

                    case 'auth':
                        var index = value.indexOf(':');

                        if (~index) {
                            url.username = value.slice(0, index);
                            url.username = encodeURIComponent(decodeURIComponent(url.username));

                            url.password = value.slice(index + 1);
                            url.password = encodeURIComponent(decodeURIComponent(url.password));
                        } else {
                            url.username = encodeURIComponent(decodeURIComponent(value));
                        }
                }

                for (var i = 0; i < rules.length; i++) {
                    var ins = rules[i];

                    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
                }

                url.auth = url.password ? url.username + ':' + url.password : url.username;

                url.origin =
                    url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
                        ? url.protocol + '//' + url.host
                        : 'null';

                url.href = url.toString();

                return url;
            }

            /**
             * Transform the properties back in to a valid and full URL string.
             *
             * @param {Function} stringify Optional query stringify function.
             * @returns {String} Compiled version of the URL.
             * @public
             */
            function toString(stringify) {
                if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

                var query,
                    url = this,
                    host = url.host,
                    protocol = url.protocol;

                if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

                var result =
                    protocol +
                    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

                if (url.username) {
                    result += url.username;
                    if (url.password) result += ':' + url.password;
                    result += '@';
                } else if (url.password) {
                    result += ':' + url.password;
                    result += '@';
                } else if (
                    url.protocol !== 'file:' &&
                    isSpecial(url.protocol) &&
                    !host &&
                    url.pathname !== '/'
                ) {
                    //
                    // Add back the empty userinfo, otherwise the original invalid URL
                    // might be transformed into a valid one with `url.pathname` as host.
                    //
                    result += '@';
                }

                //
                // Trailing colon is removed from `url.host` when it is parsed. If it still
                // ends with a colon, then add back the trailing colon that was removed. This
                // prevents an invalid URL from being transformed into a valid one.
                //
                if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
                    host += ':';
                }

                result += host + url.pathname;

                query = 'object' === typeof url.query ? stringify(url.query) : url.query;
                if (query) result += '?' !== query.charAt(0) ? '?' + query : query;

                if (url.hash) result += url.hash;

                return result;
            }

            Url.prototype = { set: set, toString: toString };

            //
            // Expose the URL parser and some additional properties that might be useful for
            // others or testing.
            //
            Url.extractProtocol = extractProtocol;
            Url.location = lolcation;
            Url.trimLeft = trimLeft;
            Url.qs = qs;

            module.exports = Url;

            /***/
        },
        /* 52 */
        /***/ (module) => {
            'use strict';

            /**
             * Check if we're required to add a port number.
             *
             * @see https://url.spec.whatwg.org/#default-port
             * @param {Number|String} port Port number we need to check
             * @param {String} protocol Protocol we need to check against.
             * @returns {Boolean} Is it a default port for the given protocol
             * @api private
             */
            module.exports = function required(port, protocol) {
                protocol = protocol.split(':')[0];
                port = +port;

                if (!port) return false;

                switch (protocol) {
                    case 'http':
                    case 'ws':
                        return port !== 80;

                    case 'https':
                    case 'wss':
                        return port !== 443;

                    case 'ftp':
                        return port !== 21;

                    case 'gopher':
                        return port !== 70;

                    case 'file':
                        return false;
                }

                return port !== 0;
            };

            /***/
        },
        /* 53 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            var has = Object.prototype.hasOwnProperty,
                undef;

            /**
             * Decode a URI encoded string.
             *
             * @param {String} input The URI encoded string.
             * @returns {String|Null} The decoded string.
             * @api private
             */
            function decode(input) {
                try {
                    return decodeURIComponent(input.replace(/\+/g, ' '));
                } catch (e) {
                    return null;
                }
            }

            /**
             * Attempts to encode a given input.
             *
             * @param {String} input The string that needs to be encoded.
             * @returns {String|Null} The encoded string.
             * @api private
             */
            function encode(input) {
                try {
                    return encodeURIComponent(input);
                } catch (e) {
                    return null;
                }
            }

            /**
             * Simple query string parser.
             *
             * @param {String} query The query string that needs to be parsed.
             * @returns {Object}
             * @api public
             */
            function querystring(query) {
                var parser = /([^=?#&]+)=?([^&]*)/g,
                    result = {},
                    part;

                while ((part = parser.exec(query))) {
                    var key = decode(part[1]),
                        value = decode(part[2]);

                    //
                    // Prevent overriding of existing properties. This ensures that build-in
                    // methods like `toString` or __proto__ are not overriden by malicious
                    // querystrings.
                    //
                    // In the case if failed decoding, we want to omit the key/value pairs
                    // from the result.
                    //
                    if (key === null || value === null || key in result) continue;
                    result[key] = value;
                }

                return result;
            }

            /**
             * Transform a query string to an object.
             *
             * @param {Object} obj Object that should be transformed.
             * @param {String} prefix Optional prefix.
             * @returns {String}
             * @api public
             */
            function querystringify(obj, prefix) {
                prefix = prefix || '';

                var pairs = [],
                    value,
                    key;

                //
                // Optionally prefix with a '?' if needed
                //
                if ('string' !== typeof prefix) prefix = '?';

                for (key in obj) {
                    if (has.call(obj, key)) {
                        value = obj[key];

                        //
                        // Edge cases where we actually want to encode the value to an empty
                        // string instead of the stringified value.
                        //
                        if (!value && (value === null || value === undef || isNaN(value))) {
                            value = '';
                        }

                        key = encode(key);
                        value = encode(value);

                        //
                        // If we failed to encode the strings, we should bail out as we don't
                        // want to add invalid strings to the query.
                        //
                        if (key === null || value === null) continue;
                        pairs.push(key + '=' + value);
                    }
                }

                return pairs.length ? prefix + pairs.join('&') : '';
            }

            //
            // Expose the module.
            //
            exports.stringify = querystringify;
            exports.parse = querystring;

            /***/
        },
        /* 54 */
        /***/ function (module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function (name, context, definition) {
                if (true && module.exports) module.exports = definition();
                else if (true)
                    !((__WEBPACK_AMD_DEFINE_FACTORY__ = definition),
                    (__WEBPACK_AMD_DEFINE_RESULT__ =
                        typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
                            ? __WEBPACK_AMD_DEFINE_FACTORY__.call(
                                  exports,
                                  __webpack_require__,
                                  exports,
                                  module
                              )
                            : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                        (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                else {
                }
            })('urljoin', this, function () {
                function normalize(strArray) {
                    var resultArray = [];
                    if (strArray.length === 0) {
                        return '';
                    }

                    if (typeof strArray[0] !== 'string') {
                        throw new TypeError('Url must be a string. Received ' + strArray[0]);
                    }

                    // If the first part is a plain protocol, we combine it with the next part.
                    if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
                        var first = strArray.shift();
                        strArray[0] = first + strArray[0];
                    }

                    // There must be two or three slashes in the file protocol, two slashes in anything else.
                    if (strArray[0].match(/^file:\/\/\//)) {
                        strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
                    } else {
                        strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
                    }

                    for (var i = 0; i < strArray.length; i++) {
                        var component = strArray[i];

                        if (typeof component !== 'string') {
                            throw new TypeError('Url must be a string. Received ' + component);
                        }

                        if (component === '') {
                            continue;
                        }

                        if (i > 0) {
                            // Removing the starting slashes for each component but the first.
                            component = component.replace(/^[\/]+/, '');
                        }
                        if (i < strArray.length - 1) {
                            // Removing the ending slashes for each component but the last.
                            component = component.replace(/[\/]+$/, '');
                        } else {
                            // For the last component we will combine multiple slashes to a single one.
                            component = component.replace(/[\/]+$/, '/');
                        }

                        resultArray.push(component);
                    }

                    var str = resultArray.join('/');
                    // Each input component is now separated by a single slash except the possible first plain protocol part.

                    // remove trailing slash before parameters or hash
                    str = str.replace(/\/(\?|&|#[^!])/g, '$1');

                    // replace ? in parameters with &
                    var parts = str.split('?');
                    str = parts.shift() + (parts.length > 0 ? '?' : '') + parts.join('&');

                    return str;
                }

                return function () {
                    var input;

                    if (typeof arguments[0] === 'object') {
                        input = arguments[0];
                    } else {
                        input = [].slice.call(arguments);
                    }

                    return normalize(input);
                };
            });

            /***/
        },
        /* 55 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.normalisePath = exports.getAllDirectories = exports.encodePath = void 0;
            var path_posix_1 = __webpack_require__(56);
            var SEP_PATH_POSIX = '__PATH_SEPARATOR_POSIX__';
            var SEP_PATH_WINDOWS = '__PATH_SEPARATOR_WINDOWS__';
            function encodePath(path) {
                var replaced = path
                    .replace(/\//g, SEP_PATH_POSIX)
                    .replace(/\\\\/g, SEP_PATH_WINDOWS);
                var formatted = encodeURIComponent(replaced);
                return formatted
                    .split(SEP_PATH_WINDOWS)
                    .join('\\\\')
                    .split(SEP_PATH_POSIX)
                    .join('/');
            }
            exports.encodePath = encodePath;
            function getAllDirectories(path) {
                if (!path || path === '/') return [];
                var currentPath = path;
                var output = [];
                do {
                    output.push(currentPath);
                    currentPath = (0, path_posix_1.dirname)(currentPath);
                } while (currentPath && currentPath !== '/');
                return output;
            }
            exports.getAllDirectories = getAllDirectories;
            function normalisePath(pathStr) {
                var normalisedPath = pathStr;
                if (normalisedPath[0] !== '/') {
                    normalisedPath = '/' + normalisedPath;
                }
                if (/^.+\/$/.test(normalisedPath)) {
                    normalisedPath = normalisedPath.substr(0, normalisedPath.length - 1);
                }
                return normalisedPath;
            }
            exports.normalisePath = normalisePath;

            /***/
        },
        /* 56 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.

            var util = __webpack_require__(16);
            var isString = function (x) {
                return typeof x === 'string';
            };

            // resolves . and .. elements in a path array with directory names there
            // must be no slashes or device names (c:\) in the array
            // (so also no leading and trailing slashes - it does not distinguish
            // relative and absolute paths)
            function normalizeArray(parts, allowAboveRoot) {
                var res = [];
                for (var i = 0; i < parts.length; i++) {
                    var p = parts[i];

                    // ignore empty parts
                    if (!p || p === '.') continue;

                    if (p === '..') {
                        if (res.length && res[res.length - 1] !== '..') {
                            res.pop();
                        } else if (allowAboveRoot) {
                            res.push('..');
                        }
                    } else {
                        res.push(p);
                    }
                }

                return res;
            }

            // Split a filename into [root, dir, basename, ext], unix version
            // 'root' is just a slash, or nothing.
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            var posix = {};

            function posixSplitPath(filename) {
                return splitPathRe.exec(filename).slice(1);
            }

            // path.resolve([from ...], to)
            // posix version
            posix.resolve = function () {
                var resolvedPath = '',
                    resolvedAbsolute = false;

                for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                    var path = i >= 0 ? arguments[i] : process.cwd();

                    // Skip empty and invalid entries
                    if (!isString(path)) {
                        throw new TypeError('Arguments to path.resolve must be strings');
                    } else if (!path) {
                        continue;
                    }

                    resolvedPath = path + '/' + resolvedPath;
                    resolvedAbsolute = path.charAt(0) === '/';
                }

                // At this point the path should be resolved to a full absolute path, but
                // handle relative paths to be safe (might happen when process.cwd() fails)

                // Normalize the path
                resolvedPath = normalizeArray(resolvedPath.split('/'), !resolvedAbsolute).join('/');

                return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
            };

            // path.normalize(path)
            // posix version
            posix.normalize = function (path) {
                var isAbsolute = posix.isAbsolute(path),
                    trailingSlash = path.substr(-1) === '/';

                // Normalize the path
                path = normalizeArray(path.split('/'), !isAbsolute).join('/');

                if (!path && !isAbsolute) {
                    path = '.';
                }
                if (path && trailingSlash) {
                    path += '/';
                }

                return (isAbsolute ? '/' : '') + path;
            };

            // posix version
            posix.isAbsolute = function (path) {
                return path.charAt(0) === '/';
            };

            // posix version
            posix.join = function () {
                var path = '';
                for (var i = 0; i < arguments.length; i++) {
                    var segment = arguments[i];
                    if (!isString(segment)) {
                        throw new TypeError('Arguments to path.join must be strings');
                    }
                    if (segment) {
                        if (!path) {
                            path += segment;
                        } else {
                            path += '/' + segment;
                        }
                    }
                }
                return posix.normalize(path);
            };

            // path.relative(from, to)
            // posix version
            posix.relative = function (from, to) {
                from = posix.resolve(from).substr(1);
                to = posix.resolve(to).substr(1);

                function trim(arr) {
                    var start = 0;
                    for (; start < arr.length; start++) {
                        if (arr[start] !== '') break;
                    }

                    var end = arr.length - 1;
                    for (; end >= 0; end--) {
                        if (arr[end] !== '') break;
                    }

                    if (start > end) return [];
                    return arr.slice(start, end + 1);
                }

                var fromParts = trim(from.split('/'));
                var toParts = trim(to.split('/'));

                var length = Math.min(fromParts.length, toParts.length);
                var samePartsLength = length;
                for (var i = 0; i < length; i++) {
                    if (fromParts[i] !== toParts[i]) {
                        samePartsLength = i;
                        break;
                    }
                }

                var outputParts = [];
                for (var i = samePartsLength; i < fromParts.length; i++) {
                    outputParts.push('..');
                }

                outputParts = outputParts.concat(toParts.slice(samePartsLength));

                return outputParts.join('/');
            };

            posix._makeLong = function (path) {
                return path;
            };

            posix.dirname = function (path) {
                var result = posixSplitPath(path),
                    root = result[0],
                    dir = result[1];

                if (!root && !dir) {
                    // No dirname whatsoever
                    return '.';
                }

                if (dir) {
                    // It has a dirname, strip trailing slash
                    dir = dir.substr(0, dir.length - 1);
                }

                return root + dir;
            };

            posix.basename = function (path, ext) {
                var f = posixSplitPath(path)[2];
                // TODO: make this comparison case-insensitive on windows?
                if (ext && f.substr(-1 * ext.length) === ext) {
                    f = f.substr(0, f.length - ext.length);
                }
                return f;
            };

            posix.extname = function (path) {
                return posixSplitPath(path)[3];
            };

            posix.format = function (pathObject) {
                if (!util.isObject(pathObject)) {
                    throw new TypeError(
                        "Parameter 'pathObject' must be an object, not " + typeof pathObject
                    );
                }

                var root = pathObject.root || '';

                if (!isString(root)) {
                    throw new TypeError(
                        "'pathObject.root' must be a string or undefined, not " +
                            typeof pathObject.root
                    );
                }

                var dir = pathObject.dir ? pathObject.dir + posix.sep : '';
                var base = pathObject.base || '';
                return dir + base;
            };

            posix.parse = function (pathString) {
                if (!isString(pathString)) {
                    throw new TypeError(
                        "Parameter 'pathString' must be a string, not " + typeof pathString
                    );
                }
                var allParts = posixSplitPath(pathString);
                if (!allParts || allParts.length !== 4) {
                    throw new TypeError("Invalid path '" + pathString + "'");
                }
                allParts[1] = allParts[1] || '';
                allParts[2] = allParts[2] || '';
                allParts[3] = allParts[3] || '';

                return {
                    root: allParts[0],
                    dir: allParts[0] + allParts[1].slice(0, allParts[1].length - 1),
                    base: allParts[2],
                    ext: allParts[3],
                    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
                };
            };

            posix.sep = '/';
            posix.delimiter = ':';

            module.exports = posix;

            /***/
        },
        /* 57 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.setupAuth = void 0;
            var layerr_1 = __webpack_require__(58);
            var digest_1 = __webpack_require__(63);
            var basic_1 = __webpack_require__(69);
            var oauth_1 = __webpack_require__(73);
            var types_1 = __webpack_require__(74);
            function setupAuth(context, username, password, oauthToken) {
                switch (context.authType) {
                    case types_1.AuthType.Digest:
                        context.digest = (0, digest_1.createDigestContext)(username, password);
                        break;
                    case types_1.AuthType.None:
                        // Do nothing
                        break;
                    case types_1.AuthType.Password:
                        context.headers.Authorization = (0, basic_1.generateBasicAuthHeader)(
                            username,
                            password
                        );
                        break;
                    case types_1.AuthType.Token:
                        context.headers.Authorization = (0, oauth_1.generateTokenAuthHeader)(
                            oauthToken
                        );
                        break;
                    default:
                        throw new layerr_1.Layerr(
                            {
                                info: {
                                    code: types_1.ErrorCode.InvalidAuthType
                                }
                            },
                            'Invalid auth type: '.concat(context.authType)
                        );
                }
            }
            exports.setupAuth = setupAuth;

            /***/
        },
        /* 58 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          Object.defineProperty(o, k2, {
                              enumerable: true,
                              get: function () {
                                  return m[k];
                              }
                          });
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __exportStar =
                (this && this.__exportStar) ||
                function (m, exports) {
                    for (var p in m)
                        if (p !== 'default' && !Object.prototype.hasOwnProperty.call(exports, p))
                            __createBinding(exports, m, p);
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.Layerr = void 0;
            var layerr_1 = __webpack_require__(59);
            Object.defineProperty(exports, 'Layerr', {
                enumerable: true,
                get: function () {
                    return layerr_1.Layerr;
                }
            });
            __exportStar(__webpack_require__(62), exports);

            /***/
        },
        /* 59 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.Layerr = void 0;
            const error_1 = __webpack_require__(60);
            const tools_1 = __webpack_require__(61);
            function Layerr(errorOptionsOrMessage, messageText) {
                const args = [...arguments];
                if (this instanceof Layerr === false) {
                    throw new Error(
                        "Cannot invoke 'Layerr' like a function: It must be called with 'new'"
                    );
                }
                const { options, shortMessage } = tools_1.parseArguments(args);
                this.name = 'Layerr';
                if (options.name && typeof options.name === 'string') {
                    this.name = options.name;
                }
                let message = shortMessage;
                if (options.cause) {
                    Object.defineProperty(this, '_cause', { value: options.cause });
                    message = `${message}: ${options.cause.message}`;
                }
                this.message = message;
                Object.defineProperty(this, '_info', { value: {} });
                if (options.info && typeof options.info === 'object') {
                    Object.assign(this._info, options.info);
                }
                Error.call(this, message);
                if (Error.captureStackTrace) {
                    const ctor = options.constructorOpt || this.constructor;
                    Error.captureStackTrace(this, ctor);
                }
                return this;
            }
            exports.Layerr = Layerr;
            error_1.inherit(Layerr, Error);
            Layerr.prototype.cause = function _getCause() {
                return Layerr.cause(this) || undefined;
            };
            Layerr.prototype.toString = function _toString() {
                let output = this.name || this.constructor.name || this.constructor.prototype.name;
                if (this.message) {
                    output = `${output}: ${this.message}`;
                }
                return output;
            };
            Layerr.cause = function __getCause(err) {
                error_1.assertError(err);
                return error_1.isError(err._cause) ? err._cause : null;
            };
            Layerr.fullStack = function __getFullStack(err) {
                error_1.assertError(err);
                const cause = Layerr.cause(err);
                if (cause) {
                    return `${err.stack}\ncaused by: ${Layerr.fullStack(cause)}`;
                }
                return err.stack;
            };
            Layerr.info = function __getInfo(err) {
                error_1.assertError(err);
                const output = {};
                const cause = Layerr.cause(err);
                if (cause) {
                    Object.assign(output, Layerr.info(cause));
                }
                if (err._info) {
                    Object.assign(output, err._info);
                }
                return output;
            };

            /***/
        },
        /* 60 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.isError = exports.inherit = exports.assertError = void 0;
            function assertError(err) {
                if (!isError(err)) {
                    throw new Error('Parameter was not an error');
                }
            }
            exports.assertError = assertError;
            function inherit(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            }
            exports.inherit = inherit;
            function isError(err) {
                return objectToString(err) === '[object Error]' || err instanceof Error;
            }
            exports.isError = isError;
            function objectToString(obj) {
                return Object.prototype.toString.call(obj);
            }

            /***/
        },
        /* 61 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.parseArguments = void 0;
            const error_1 = __webpack_require__(60);
            function parseArguments(args) {
                let options,
                    shortMessage = '';
                if (args.length === 0) {
                    options = {};
                } else if (error_1.isError(args[0])) {
                    options = {
                        cause: args[0]
                    };
                    shortMessage = args.slice(1).join(' ') || '';
                } else if (args[0] && typeof args[0] === 'object') {
                    options = Object.assign({}, args[0]);
                    shortMessage = args.slice(1).join(' ') || '';
                } else if (typeof args[0] === 'string') {
                    options = {};
                    shortMessage = shortMessage = args.join(' ') || '';
                } else {
                    throw new Error('Invalid arguments passed to Layerr');
                }
                return {
                    options,
                    shortMessage
                };
            }
            exports.parseArguments = parseArguments;

            /***/
        },
        /* 62 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });

            /***/
        },
        /* 63 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.parseDigestAuth =
                exports.generateDigestAuthHeader =
                exports.createDigestContext =
                    void 0;
            var md5_1 = __importDefault(__webpack_require__(64));
            var crypto_1 = __webpack_require__(68);
            var NONCE_CHARS = 'abcdef0123456789';
            var NONCE_SIZE = 32;
            function createDigestContext(username, password) {
                return {
                    username: username,
                    password: password,
                    nc: 0,
                    algorithm: 'md5',
                    hasDigestAuth: false
                };
            }
            exports.createDigestContext = createDigestContext;
            function generateDigestAuthHeader(options, digest) {
                var url = options.url.replace('//', '');
                var uri = url.indexOf('/') == -1 ? '/' : url.slice(url.indexOf('/'));
                var method = options.method ? options.method.toUpperCase() : 'GET';
                var qop = /(^|,)\s*auth\s*($|,)/.test(digest.qop) ? 'auth' : false;
                var ncString = '00000000'.concat(digest.nc).slice(-8);
                var ha1 = (0, crypto_1.ha1Compute)(
                    digest.algorithm,
                    digest.username,
                    digest.realm,
                    digest.password,
                    digest.nonce,
                    digest.cnonce
                );
                var ha2 = (0, md5_1.default)(''.concat(method, ':').concat(uri));
                var digestResponse = qop
                    ? (0, md5_1.default)(
                          ''
                              .concat(ha1, ':')
                              .concat(digest.nonce, ':')
                              .concat(ncString, ':')
                              .concat(digest.cnonce, ':')
                              .concat(qop, ':')
                              .concat(ha2)
                      )
                    : (0, md5_1.default)(''.concat(ha1, ':').concat(digest.nonce, ':').concat(ha2));
                var authValues = {
                    username: digest.username,
                    realm: digest.realm,
                    nonce: digest.nonce,
                    uri: uri,
                    qop: qop,
                    response: digestResponse,
                    nc: ncString,
                    cnonce: digest.cnonce,
                    algorithm: digest.algorithm,
                    opaque: digest.opaque
                };
                var authHeader = [];
                for (var k in authValues) {
                    if (authValues[k]) {
                        if (k === 'qop' || k === 'nc' || k === 'algorithm') {
                            authHeader.push(''.concat(k, '=').concat(authValues[k]));
                        } else {
                            authHeader.push(''.concat(k, '="').concat(authValues[k], '"'));
                        }
                    }
                }
                return 'Digest '.concat(authHeader.join(', '));
            }
            exports.generateDigestAuthHeader = generateDigestAuthHeader;
            function makeNonce() {
                var uid = '';
                for (var i = 0; i < NONCE_SIZE; ++i) {
                    uid = ''
                        .concat(uid)
                        .concat(NONCE_CHARS[Math.floor(Math.random() * NONCE_CHARS.length)]);
                }
                return uid;
            }
            function parseDigestAuth(response, _digest) {
                var authHeader = response.headers['www-authenticate'] || '';
                if (authHeader.split(/\s/)[0].toLowerCase() !== 'digest') {
                    return false;
                }
                var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
                for (;;) {
                    var match = re.exec(authHeader);
                    if (!match) {
                        break;
                    }
                    _digest[match[1]] = match[2] || match[3];
                }
                _digest.nc += 1;
                _digest.cnonce = makeNonce();
                return true;
            }
            exports.parseDigestAuth = parseDigestAuth;

            /***/
        },
        /* 64 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            (function () {
                var crypt = __webpack_require__(65),
                    utf8 = __webpack_require__(66).utf8,
                    isBuffer = __webpack_require__(67),
                    bin = __webpack_require__(66).bin,
                    // The core
                    md5 = function (message, options) {
                        // Convert to byte array
                        if (message.constructor == String)
                            if (options && options.encoding === 'binary')
                                message = bin.stringToBytes(message);
                            else message = utf8.stringToBytes(message);
                        else if (isBuffer(message))
                            message = Array.prototype.slice.call(message, 0);
                        else if (!Array.isArray(message) && message.constructor !== Uint8Array)
                            message = message.toString();
                        // else, assume byte array already

                        var m = crypt.bytesToWords(message),
                            l = message.length * 8,
                            a = 1732584193,
                            b = -271733879,
                            c = -1732584194,
                            d = 271733878;

                        // Swap endian
                        for (var i = 0; i < m.length; i++) {
                            m[i] =
                                (((m[i] << 8) | (m[i] >>> 24)) & 0x00ff00ff) |
                                (((m[i] << 24) | (m[i] >>> 8)) & 0xff00ff00);
                        }

                        // Padding
                        m[l >>> 5] |= 0x80 << l % 32;
                        m[(((l + 64) >>> 9) << 4) + 14] = l;

                        // Method shortcuts
                        var FF = md5._ff,
                            GG = md5._gg,
                            HH = md5._hh,
                            II = md5._ii;

                        for (var i = 0; i < m.length; i += 16) {
                            var aa = a,
                                bb = b,
                                cc = c,
                                dd = d;

                            a = FF(a, b, c, d, m[i + 0], 7, -680876936);
                            d = FF(d, a, b, c, m[i + 1], 12, -389564586);
                            c = FF(c, d, a, b, m[i + 2], 17, 606105819);
                            b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
                            a = FF(a, b, c, d, m[i + 4], 7, -176418897);
                            d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
                            c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
                            b = FF(b, c, d, a, m[i + 7], 22, -45705983);
                            a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
                            d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
                            c = FF(c, d, a, b, m[i + 10], 17, -42063);
                            b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
                            a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
                            d = FF(d, a, b, c, m[i + 13], 12, -40341101);
                            c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
                            b = FF(b, c, d, a, m[i + 15], 22, 1236535329);

                            a = GG(a, b, c, d, m[i + 1], 5, -165796510);
                            d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
                            c = GG(c, d, a, b, m[i + 11], 14, 643717713);
                            b = GG(b, c, d, a, m[i + 0], 20, -373897302);
                            a = GG(a, b, c, d, m[i + 5], 5, -701558691);
                            d = GG(d, a, b, c, m[i + 10], 9, 38016083);
                            c = GG(c, d, a, b, m[i + 15], 14, -660478335);
                            b = GG(b, c, d, a, m[i + 4], 20, -405537848);
                            a = GG(a, b, c, d, m[i + 9], 5, 568446438);
                            d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
                            c = GG(c, d, a, b, m[i + 3], 14, -187363961);
                            b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
                            a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
                            d = GG(d, a, b, c, m[i + 2], 9, -51403784);
                            c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
                            b = GG(b, c, d, a, m[i + 12], 20, -1926607734);

                            a = HH(a, b, c, d, m[i + 5], 4, -378558);
                            d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
                            c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
                            b = HH(b, c, d, a, m[i + 14], 23, -35309556);
                            a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
                            d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
                            c = HH(c, d, a, b, m[i + 7], 16, -155497632);
                            b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
                            a = HH(a, b, c, d, m[i + 13], 4, 681279174);
                            d = HH(d, a, b, c, m[i + 0], 11, -358537222);
                            c = HH(c, d, a, b, m[i + 3], 16, -722521979);
                            b = HH(b, c, d, a, m[i + 6], 23, 76029189);
                            a = HH(a, b, c, d, m[i + 9], 4, -640364487);
                            d = HH(d, a, b, c, m[i + 12], 11, -421815835);
                            c = HH(c, d, a, b, m[i + 15], 16, 530742520);
                            b = HH(b, c, d, a, m[i + 2], 23, -995338651);

                            a = II(a, b, c, d, m[i + 0], 6, -198630844);
                            d = II(d, a, b, c, m[i + 7], 10, 1126891415);
                            c = II(c, d, a, b, m[i + 14], 15, -1416354905);
                            b = II(b, c, d, a, m[i + 5], 21, -57434055);
                            a = II(a, b, c, d, m[i + 12], 6, 1700485571);
                            d = II(d, a, b, c, m[i + 3], 10, -1894986606);
                            c = II(c, d, a, b, m[i + 10], 15, -1051523);
                            b = II(b, c, d, a, m[i + 1], 21, -2054922799);
                            a = II(a, b, c, d, m[i + 8], 6, 1873313359);
                            d = II(d, a, b, c, m[i + 15], 10, -30611744);
                            c = II(c, d, a, b, m[i + 6], 15, -1560198380);
                            b = II(b, c, d, a, m[i + 13], 21, 1309151649);
                            a = II(a, b, c, d, m[i + 4], 6, -145523070);
                            d = II(d, a, b, c, m[i + 11], 10, -1120210379);
                            c = II(c, d, a, b, m[i + 2], 15, 718787259);
                            b = II(b, c, d, a, m[i + 9], 21, -343485551);

                            a = (a + aa) >>> 0;
                            b = (b + bb) >>> 0;
                            c = (c + cc) >>> 0;
                            d = (d + dd) >>> 0;
                        }

                        return crypt.endian([a, b, c, d]);
                    };

                // Auxiliary functions
                md5._ff = function (a, b, c, d, x, s, t) {
                    var n = a + ((b & c) | (~b & d)) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                };
                md5._gg = function (a, b, c, d, x, s, t) {
                    var n = a + ((b & d) | (c & ~d)) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                };
                md5._hh = function (a, b, c, d, x, s, t) {
                    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                };
                md5._ii = function (a, b, c, d, x, s, t) {
                    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                };

                // Package private blocksize
                md5._blocksize = 16;
                md5._digestsize = 16;

                module.exports = function (message, options) {
                    if (message === undefined || message === null)
                        throw new Error('Illegal argument ' + message);

                    var digestbytes = crypt.wordsToBytes(md5(message, options));
                    return options && options.asBytes
                        ? digestbytes
                        : options && options.asString
                        ? bin.bytesToString(digestbytes)
                        : crypt.bytesToHex(digestbytes);
                };
            })();

            /***/
        },
        /* 65 */
        /***/ (module) => {
            (function () {
                var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
                    crypt = {
                        // Bit-wise rotation left
                        rotl: function (n, b) {
                            return (n << b) | (n >>> (32 - b));
                        },

                        // Bit-wise rotation right
                        rotr: function (n, b) {
                            return (n << (32 - b)) | (n >>> b);
                        },

                        // Swap big-endian to little-endian and vice versa
                        endian: function (n) {
                            // If number given, swap endian
                            if (n.constructor == Number) {
                                return (
                                    (crypt.rotl(n, 8) & 0x00ff00ff) |
                                    (crypt.rotl(n, 24) & 0xff00ff00)
                                );
                            }

                            // Else, assume array and swap all items
                            for (var i = 0; i < n.length; i++) n[i] = crypt.endian(n[i]);
                            return n;
                        },

                        // Generate an array of any length of random bytes
                        randomBytes: function (n) {
                            for (var bytes = []; n > 0; n--)
                                bytes.push(Math.floor(Math.random() * 256));
                            return bytes;
                        },

                        // Convert a byte array to big-endian 32-bit words
                        bytesToWords: function (bytes) {
                            for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
                                words[b >>> 5] |= bytes[i] << (24 - (b % 32));
                            return words;
                        },

                        // Convert big-endian 32-bit words to a byte array
                        wordsToBytes: function (words) {
                            for (var bytes = [], b = 0; b < words.length * 32; b += 8)
                                bytes.push((words[b >>> 5] >>> (24 - (b % 32))) & 0xff);
                            return bytes;
                        },

                        // Convert a byte array to a hex string
                        bytesToHex: function (bytes) {
                            for (var hex = [], i = 0; i < bytes.length; i++) {
                                hex.push((bytes[i] >>> 4).toString(16));
                                hex.push((bytes[i] & 0xf).toString(16));
                            }
                            return hex.join('');
                        },

                        // Convert a hex string to a byte array
                        hexToBytes: function (hex) {
                            for (var bytes = [], c = 0; c < hex.length; c += 2)
                                bytes.push(parseInt(hex.substr(c, 2), 16));
                            return bytes;
                        },

                        // Convert a byte array to a base-64 string
                        bytesToBase64: function (bytes) {
                            for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                                var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
                                for (var j = 0; j < 4; j++)
                                    if (i * 8 + j * 6 <= bytes.length * 8)
                                        base64.push(
                                            base64map.charAt((triplet >>> (6 * (3 - j))) & 0x3f)
                                        );
                                    else base64.push('=');
                            }
                            return base64.join('');
                        },

                        // Convert a base-64 string to a byte array
                        base64ToBytes: function (base64) {
                            // Remove non-base-64 characters
                            base64 = base64.replace(/[^A-Z0-9+\/]/gi, '');

                            for (
                                var bytes = [], i = 0, imod4 = 0;
                                i < base64.length;
                                imod4 = ++i % 4
                            ) {
                                if (imod4 == 0) continue;
                                bytes.push(
                                    ((base64map.indexOf(base64.charAt(i - 1)) &
                                        (Math.pow(2, -2 * imod4 + 8) - 1)) <<
                                        (imod4 * 2)) |
                                        (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2))
                                );
                            }
                            return bytes;
                        }
                    };

                module.exports = crypt;
            })();

            /***/
        },
        /* 66 */
        /***/ (module) => {
            var charenc = {
                // UTF-8 encoding
                utf8: {
                    // Convert a string to a byte array
                    stringToBytes: function (str) {
                        return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
                    },

                    // Convert a byte array to a string
                    bytesToString: function (bytes) {
                        return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
                    }
                },

                // Binary encoding
                bin: {
                    // Convert a string to a byte array
                    stringToBytes: function (str) {
                        for (var bytes = [], i = 0; i < str.length; i++)
                            bytes.push(str.charCodeAt(i) & 0xff);
                        return bytes;
                    },

                    // Convert a byte array to a string
                    bytesToString: function (bytes) {
                        for (var str = [], i = 0; i < bytes.length; i++)
                            str.push(String.fromCharCode(bytes[i]));
                        return str.join('');
                    }
                }
            };

            module.exports = charenc;

            /***/
        },
        /* 67 */
        /***/ (module) => {
            /*!
             * Determine if an object is a Buffer
             *
             * @author   Feross Aboukhadijeh <https://feross.org>
             * @license  MIT
             */

            // The _isBuffer check is for Safari 5-7 support, because it's missing
            // Object.prototype.constructor. Remove this eventually
            module.exports = function (obj) {
                return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
            };

            function isBuffer(obj) {
                return (
                    !!obj.constructor &&
                    typeof obj.constructor.isBuffer === 'function' &&
                    obj.constructor.isBuffer(obj)
                );
            }

            // For Node v0.10 support. Remove this eventually.
            function isSlowBuffer(obj) {
                return (
                    typeof obj.readFloatLE === 'function' &&
                    typeof obj.slice === 'function' &&
                    isBuffer(obj.slice(0, 0))
                );
            }

            /***/
        },
        /* 68 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.ha1Compute = void 0;
            var md5_1 = __importDefault(__webpack_require__(64));
            function ha1Compute(algorithm, user, realm, pass, nonce, cnonce) {
                var ha1 = (0, md5_1.default)(''.concat(user, ':').concat(realm, ':').concat(pass));
                if (algorithm && algorithm.toLowerCase() === 'md5-sess') {
                    return (0, md5_1.default)(
                        ''.concat(ha1, ':').concat(nonce, ':').concat(cnonce)
                    );
                }
                return ha1;
            }
            exports.ha1Compute = ha1Compute;

            /***/
        },
        /* 69 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.generateBasicAuthHeader = void 0;
            var encode_1 = __webpack_require__(70);
            function generateBasicAuthHeader(username, password) {
                var encoded = (0, encode_1.toBase64)(''.concat(username, ':').concat(password));
                return 'Basic '.concat(encoded);
            }
            exports.generateBasicAuthHeader = generateBasicAuthHeader;

            /***/
        },
        /* 70 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.toBase64 = exports.fromBase64 = exports.decodeHTMLEntities = void 0;
            var base_64_1 = __webpack_require__(71);
            function decodeHTMLEntities(text) {
                if (typeof WEB === 'undefined') {
                    // Node
                    var he = __webpack_require__(72);
                    return he.decode(text);
                } else {
                    // Nasty browser way
                    var txt = document.createElement('textarea');
                    txt.innerHTML = text;
                    return txt.value;
                }
            }
            exports.decodeHTMLEntities = decodeHTMLEntities;
            function fromBase64(text) {
                return (0, base_64_1.decode)(text);
            }
            exports.fromBase64 = fromBase64;
            function toBase64(text) {
                return (0, base_64_1.encode)(text);
            }
            exports.toBase64 = toBase64;

            /***/
        },
        /* 71 */
        /***/ function (module, exports, __webpack_require__) {
            /* module decorator */ module = __webpack_require__.nmd(module);
            var __WEBPACK_AMD_DEFINE_RESULT__ /*! https://mths.be/base64 v1.0.0 by @mathias | MIT license */;
            (function (root) {
                // Detect free variables `exports`.
                var freeExports = true && exports;

                // Detect free variable `module`.
                var freeModule = true && module && module.exports == freeExports && module;

                // Detect free variable `global`, from Node.js or Browserified code, and use
                // it as `root`.
                var freeGlobal = typeof global == 'object' && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                    root = freeGlobal;
                }

                /*--------------------------------------------------------------------------*/

                var InvalidCharacterError = function (message) {
                    this.message = message;
                };
                InvalidCharacterError.prototype = new Error();
                InvalidCharacterError.prototype.name = 'InvalidCharacterError';

                var error = function (message) {
                    // Note: the error messages used throughout this file match those used by
                    // the native `atob`/`btoa` implementation in Chromium.
                    throw new InvalidCharacterError(message);
                };

                var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                // http://whatwg.org/html/common-microsyntaxes.html#space-character
                var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;

                // `decode` is designed to be fully compatible with `atob` as described in the
                // HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
                // The optimized base64-decoding algorithm used is based on @atk’s excellent
                // implementation. https://gist.github.com/atk/1020396
                var decode = function (input) {
                    input = String(input).replace(REGEX_SPACE_CHARACTERS, '');
                    var length = input.length;
                    if (length % 4 == 0) {
                        input = input.replace(/==?$/, '');
                        length = input.length;
                    }
                    if (
                        length % 4 == 1 ||
                        // http://whatwg.org/C#alphanumeric-ascii-characters
                        /[^+a-zA-Z0-9/]/.test(input)
                    ) {
                        error(
                            'Invalid character: the string to be decoded is not correctly encoded.'
                        );
                    }
                    var bitCounter = 0;
                    var bitStorage;
                    var buffer;
                    var output = '';
                    var position = -1;
                    while (++position < length) {
                        buffer = TABLE.indexOf(input.charAt(position));
                        bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
                        // Unless this is the first of a group of 4 characters…
                        if (bitCounter++ % 4) {
                            // …convert the first 8 bits to a single ASCII character.
                            output += String.fromCharCode(
                                0xff & (bitStorage >> ((-2 * bitCounter) & 6))
                            );
                        }
                    }
                    return output;
                };

                // `encode` is designed to be fully compatible with `btoa` as described in the
                // HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa
                var encode = function (input) {
                    input = String(input);
                    if (/[^\0-\xFF]/.test(input)) {
                        // Note: no need to special-case astral symbols here, as surrogates are
                        // matched, and the input is supposed to only contain ASCII anyway.
                        error(
                            'The string to be encoded contains characters outside of the ' +
                                'Latin1 range.'
                        );
                    }
                    var padding = input.length % 3;
                    var output = '';
                    var position = -1;
                    var a;
                    var b;
                    var c;
                    var buffer;
                    // Make sure any padding is handled outside of the loop.
                    var length = input.length - padding;

                    while (++position < length) {
                        // Read three bytes, i.e. 24 bits.
                        a = input.charCodeAt(position) << 16;
                        b = input.charCodeAt(++position) << 8;
                        c = input.charCodeAt(++position);
                        buffer = a + b + c;
                        // Turn the 24 bits into four chunks of 6 bits each, and append the
                        // matching character for each of them to the output.
                        output +=
                            TABLE.charAt((buffer >> 18) & 0x3f) +
                            TABLE.charAt((buffer >> 12) & 0x3f) +
                            TABLE.charAt((buffer >> 6) & 0x3f) +
                            TABLE.charAt(buffer & 0x3f);
                    }

                    if (padding == 2) {
                        a = input.charCodeAt(position) << 8;
                        b = input.charCodeAt(++position);
                        buffer = a + b;
                        output +=
                            TABLE.charAt(buffer >> 10) +
                            TABLE.charAt((buffer >> 4) & 0x3f) +
                            TABLE.charAt((buffer << 2) & 0x3f) +
                            '=';
                    } else if (padding == 1) {
                        buffer = input.charCodeAt(position);
                        output +=
                            TABLE.charAt(buffer >> 2) + TABLE.charAt((buffer << 4) & 0x3f) + '==';
                    }

                    return output;
                };

                var base64 = {
                    encode: encode,
                    decode: decode,
                    version: '1.0.0'
                };

                // Some AMD build optimizers, like r.js, check for specific condition patterns
                // like the following:
                if (true) {
                    !((__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                        return base64;
                    }.call(exports, __webpack_require__, exports, module)),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                        (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {
                    var key;
                }
            })(this);

            /***/
        },
        /* 72 */
        /***/ function (module, exports, __webpack_require__) {
            /* module decorator */ module = __webpack_require__.nmd(module);
            var __WEBPACK_AMD_DEFINE_RESULT__ /*! https://mths.be/he v1.2.0 by @mathias | MIT license */;
            (function (root) {
                // Detect free variables `exports`.
                var freeExports = true && exports;

                // Detect free variable `module`.
                var freeModule = true && module && module.exports == freeExports && module;

                // Detect free variable `global`, from Node.js or Browserified code,
                // and use it as `root`.
                var freeGlobal = typeof global == 'object' && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                    root = freeGlobal;
                }

                /*--------------------------------------------------------------------------*/

                // All astral symbols.
                var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
                // All ASCII symbols (not just printable ASCII) except those listed in the
                // first column of the overrides table.
                // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
                var regexAsciiWhitelist = /[\x01-\x7F]/g;
                // All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
                // code points listed in the first column of the overrides table on
                // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
                var regexBmpWhitelist =
                    /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

                var regexEncodeNonAscii =
                    /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
                var encodeMap = {
                    '\xAD': 'shy',
                    '\u200C': 'zwnj',
                    '\u200D': 'zwj',
                    '\u200E': 'lrm',
                    '\u2063': 'ic',
                    '\u2062': 'it',
                    '\u2061': 'af',
                    '\u200F': 'rlm',
                    '\u200B': 'ZeroWidthSpace',
                    '\u2060': 'NoBreak',
                    '\u0311': 'DownBreve',
                    '\u20DB': 'tdot',
                    '\u20DC': 'DotDot',
                    '\t': 'Tab',
                    '\n': 'NewLine',
                    '\u2008': 'puncsp',
                    '\u205F': 'MediumSpace',
                    '\u2009': 'thinsp',
                    '\u200A': 'hairsp',
                    '\u2004': 'emsp13',
                    '\u2002': 'ensp',
                    '\u2005': 'emsp14',
                    '\u2003': 'emsp',
                    '\u2007': 'numsp',
                    '\xA0': 'nbsp',
                    '\u205F\u200A': 'ThickSpace',
                    '\u203E': 'oline',
                    _: 'lowbar',
                    '\u2010': 'dash',
                    '\u2013': 'ndash',
                    '\u2014': 'mdash',
                    '\u2015': 'horbar',
                    ',': 'comma',
                    ';': 'semi',
                    '\u204F': 'bsemi',
                    ':': 'colon',
                    '\u2A74': 'Colone',
                    '!': 'excl',
                    '\xA1': 'iexcl',
                    '?': 'quest',
                    '\xBF': 'iquest',
                    '.': 'period',
                    '\u2025': 'nldr',
                    '\u2026': 'mldr',
                    '\xB7': 'middot',
                    "'": 'apos',
                    '\u2018': 'lsquo',
                    '\u2019': 'rsquo',
                    '\u201A': 'sbquo',
                    '\u2039': 'lsaquo',
                    '\u203A': 'rsaquo',
                    '"': 'quot',
                    '\u201C': 'ldquo',
                    '\u201D': 'rdquo',
                    '\u201E': 'bdquo',
                    '\xAB': 'laquo',
                    '\xBB': 'raquo',
                    '(': 'lpar',
                    ')': 'rpar',
                    '[': 'lsqb',
                    ']': 'rsqb',
                    '{': 'lcub',
                    '}': 'rcub',
                    '\u2308': 'lceil',
                    '\u2309': 'rceil',
                    '\u230A': 'lfloor',
                    '\u230B': 'rfloor',
                    '\u2985': 'lopar',
                    '\u2986': 'ropar',
                    '\u298B': 'lbrke',
                    '\u298C': 'rbrke',
                    '\u298D': 'lbrkslu',
                    '\u298E': 'rbrksld',
                    '\u298F': 'lbrksld',
                    '\u2990': 'rbrkslu',
                    '\u2991': 'langd',
                    '\u2992': 'rangd',
                    '\u2993': 'lparlt',
                    '\u2994': 'rpargt',
                    '\u2995': 'gtlPar',
                    '\u2996': 'ltrPar',
                    '\u27E6': 'lobrk',
                    '\u27E7': 'robrk',
                    '\u27E8': 'lang',
                    '\u27E9': 'rang',
                    '\u27EA': 'Lang',
                    '\u27EB': 'Rang',
                    '\u27EC': 'loang',
                    '\u27ED': 'roang',
                    '\u2772': 'lbbrk',
                    '\u2773': 'rbbrk',
                    '\u2016': 'Vert',
                    '\xA7': 'sect',
                    '\xB6': 'para',
                    '@': 'commat',
                    '*': 'ast',
                    '/': 'sol',
                    undefined: null,
                    '&': 'amp',
                    '#': 'num',
                    '%': 'percnt',
                    '\u2030': 'permil',
                    '\u2031': 'pertenk',
                    '\u2020': 'dagger',
                    '\u2021': 'Dagger',
                    '\u2022': 'bull',
                    '\u2043': 'hybull',
                    '\u2032': 'prime',
                    '\u2033': 'Prime',
                    '\u2034': 'tprime',
                    '\u2057': 'qprime',
                    '\u2035': 'bprime',
                    '\u2041': 'caret',
                    '`': 'grave',
                    '\xB4': 'acute',
                    '\u02DC': 'tilde',
                    '^': 'Hat',
                    '\xAF': 'macr',
                    '\u02D8': 'breve',
                    '\u02D9': 'dot',
                    '\xA8': 'die',
                    '\u02DA': 'ring',
                    '\u02DD': 'dblac',
                    '\xB8': 'cedil',
                    '\u02DB': 'ogon',
                    '\u02C6': 'circ',
                    '\u02C7': 'caron',
                    '\xB0': 'deg',
                    '\xA9': 'copy',
                    '\xAE': 'reg',
                    '\u2117': 'copysr',
                    '\u2118': 'wp',
                    '\u211E': 'rx',
                    '\u2127': 'mho',
                    '\u2129': 'iiota',
                    '\u2190': 'larr',
                    '\u219A': 'nlarr',
                    '\u2192': 'rarr',
                    '\u219B': 'nrarr',
                    '\u2191': 'uarr',
                    '\u2193': 'darr',
                    '\u2194': 'harr',
                    '\u21AE': 'nharr',
                    '\u2195': 'varr',
                    '\u2196': 'nwarr',
                    '\u2197': 'nearr',
                    '\u2198': 'searr',
                    '\u2199': 'swarr',
                    '\u219D': 'rarrw',
                    '\u219D\u0338': 'nrarrw',
                    '\u219E': 'Larr',
                    '\u219F': 'Uarr',
                    '\u21A0': 'Rarr',
                    '\u21A1': 'Darr',
                    '\u21A2': 'larrtl',
                    '\u21A3': 'rarrtl',
                    '\u21A4': 'mapstoleft',
                    '\u21A5': 'mapstoup',
                    '\u21A6': 'map',
                    '\u21A7': 'mapstodown',
                    '\u21A9': 'larrhk',
                    '\u21AA': 'rarrhk',
                    '\u21AB': 'larrlp',
                    '\u21AC': 'rarrlp',
                    '\u21AD': 'harrw',
                    '\u21B0': 'lsh',
                    '\u21B1': 'rsh',
                    '\u21B2': 'ldsh',
                    '\u21B3': 'rdsh',
                    '\u21B5': 'crarr',
                    '\u21B6': 'cularr',
                    '\u21B7': 'curarr',
                    '\u21BA': 'olarr',
                    '\u21BB': 'orarr',
                    '\u21BC': 'lharu',
                    '\u21BD': 'lhard',
                    '\u21BE': 'uharr',
                    '\u21BF': 'uharl',
                    '\u21C0': 'rharu',
                    '\u21C1': 'rhard',
                    '\u21C2': 'dharr',
                    '\u21C3': 'dharl',
                    '\u21C4': 'rlarr',
                    '\u21C5': 'udarr',
                    '\u21C6': 'lrarr',
                    '\u21C7': 'llarr',
                    '\u21C8': 'uuarr',
                    '\u21C9': 'rrarr',
                    '\u21CA': 'ddarr',
                    '\u21CB': 'lrhar',
                    '\u21CC': 'rlhar',
                    '\u21D0': 'lArr',
                    '\u21CD': 'nlArr',
                    '\u21D1': 'uArr',
                    '\u21D2': 'rArr',
                    '\u21CF': 'nrArr',
                    '\u21D3': 'dArr',
                    '\u21D4': 'iff',
                    '\u21CE': 'nhArr',
                    '\u21D5': 'vArr',
                    '\u21D6': 'nwArr',
                    '\u21D7': 'neArr',
                    '\u21D8': 'seArr',
                    '\u21D9': 'swArr',
                    '\u21DA': 'lAarr',
                    '\u21DB': 'rAarr',
                    '\u21DD': 'zigrarr',
                    '\u21E4': 'larrb',
                    '\u21E5': 'rarrb',
                    '\u21F5': 'duarr',
                    '\u21FD': 'loarr',
                    '\u21FE': 'roarr',
                    '\u21FF': 'hoarr',
                    '\u2200': 'forall',
                    '\u2201': 'comp',
                    '\u2202': 'part',
                    '\u2202\u0338': 'npart',
                    '\u2203': 'exist',
                    '\u2204': 'nexist',
                    '\u2205': 'empty',
                    '\u2207': 'Del',
                    '\u2208': 'in',
                    '\u2209': 'notin',
                    '\u220B': 'ni',
                    '\u220C': 'notni',
                    '\u03F6': 'bepsi',
                    '\u220F': 'prod',
                    '\u2210': 'coprod',
                    '\u2211': 'sum',
                    '+': 'plus',
                    '\xB1': 'pm',
                    '\xF7': 'div',
                    '\xD7': 'times',
                    '<': 'lt',
                    '\u226E': 'nlt',
                    '<\u20D2': 'nvlt',
                    '=': 'equals',
                    '\u2260': 'ne',
                    '=\u20E5': 'bne',
                    '\u2A75': 'Equal',
                    '>': 'gt',
                    '\u226F': 'ngt',
                    '>\u20D2': 'nvgt',
                    '\xAC': 'not',
                    '|': 'vert',
                    '\xA6': 'brvbar',
                    '\u2212': 'minus',
                    '\u2213': 'mp',
                    '\u2214': 'plusdo',
                    '\u2044': 'frasl',
                    '\u2216': 'setmn',
                    '\u2217': 'lowast',
                    '\u2218': 'compfn',
                    '\u221A': 'Sqrt',
                    '\u221D': 'prop',
                    '\u221E': 'infin',
                    '\u221F': 'angrt',
                    '\u2220': 'ang',
                    '\u2220\u20D2': 'nang',
                    '\u2221': 'angmsd',
                    '\u2222': 'angsph',
                    '\u2223': 'mid',
                    '\u2224': 'nmid',
                    '\u2225': 'par',
                    '\u2226': 'npar',
                    '\u2227': 'and',
                    '\u2228': 'or',
                    '\u2229': 'cap',
                    '\u2229\uFE00': 'caps',
                    '\u222A': 'cup',
                    '\u222A\uFE00': 'cups',
                    '\u222B': 'int',
                    '\u222C': 'Int',
                    '\u222D': 'tint',
                    '\u2A0C': 'qint',
                    '\u222E': 'oint',
                    '\u222F': 'Conint',
                    '\u2230': 'Cconint',
                    '\u2231': 'cwint',
                    '\u2232': 'cwconint',
                    '\u2233': 'awconint',
                    '\u2234': 'there4',
                    '\u2235': 'becaus',
                    '\u2236': 'ratio',
                    '\u2237': 'Colon',
                    '\u2238': 'minusd',
                    '\u223A': 'mDDot',
                    '\u223B': 'homtht',
                    '\u223C': 'sim',
                    '\u2241': 'nsim',
                    '\u223C\u20D2': 'nvsim',
                    '\u223D': 'bsim',
                    '\u223D\u0331': 'race',
                    '\u223E': 'ac',
                    '\u223E\u0333': 'acE',
                    '\u223F': 'acd',
                    '\u2240': 'wr',
                    '\u2242': 'esim',
                    '\u2242\u0338': 'nesim',
                    '\u2243': 'sime',
                    '\u2244': 'nsime',
                    '\u2245': 'cong',
                    '\u2247': 'ncong',
                    '\u2246': 'simne',
                    '\u2248': 'ap',
                    '\u2249': 'nap',
                    '\u224A': 'ape',
                    '\u224B': 'apid',
                    '\u224B\u0338': 'napid',
                    '\u224C': 'bcong',
                    '\u224D': 'CupCap',
                    '\u226D': 'NotCupCap',
                    '\u224D\u20D2': 'nvap',
                    '\u224E': 'bump',
                    '\u224E\u0338': 'nbump',
                    '\u224F': 'bumpe',
                    '\u224F\u0338': 'nbumpe',
                    '\u2250': 'doteq',
                    '\u2250\u0338': 'nedot',
                    '\u2251': 'eDot',
                    '\u2252': 'efDot',
                    '\u2253': 'erDot',
                    '\u2254': 'colone',
                    '\u2255': 'ecolon',
                    '\u2256': 'ecir',
                    '\u2257': 'cire',
                    '\u2259': 'wedgeq',
                    '\u225A': 'veeeq',
                    '\u225C': 'trie',
                    '\u225F': 'equest',
                    '\u2261': 'equiv',
                    '\u2262': 'nequiv',
                    '\u2261\u20E5': 'bnequiv',
                    '\u2264': 'le',
                    '\u2270': 'nle',
                    '\u2264\u20D2': 'nvle',
                    '\u2265': 'ge',
                    '\u2271': 'nge',
                    '\u2265\u20D2': 'nvge',
                    '\u2266': 'lE',
                    '\u2266\u0338': 'nlE',
                    '\u2267': 'gE',
                    '\u2267\u0338': 'ngE',
                    '\u2268\uFE00': 'lvnE',
                    '\u2268': 'lnE',
                    '\u2269': 'gnE',
                    '\u2269\uFE00': 'gvnE',
                    '\u226A': 'll',
                    '\u226A\u0338': 'nLtv',
                    '\u226A\u20D2': 'nLt',
                    '\u226B': 'gg',
                    '\u226B\u0338': 'nGtv',
                    '\u226B\u20D2': 'nGt',
                    '\u226C': 'twixt',
                    '\u2272': 'lsim',
                    '\u2274': 'nlsim',
                    '\u2273': 'gsim',
                    '\u2275': 'ngsim',
                    '\u2276': 'lg',
                    '\u2278': 'ntlg',
                    '\u2277': 'gl',
                    '\u2279': 'ntgl',
                    '\u227A': 'pr',
                    '\u2280': 'npr',
                    '\u227B': 'sc',
                    '\u2281': 'nsc',
                    '\u227C': 'prcue',
                    '\u22E0': 'nprcue',
                    '\u227D': 'sccue',
                    '\u22E1': 'nsccue',
                    '\u227E': 'prsim',
                    '\u227F': 'scsim',
                    '\u227F\u0338': 'NotSucceedsTilde',
                    '\u2282': 'sub',
                    '\u2284': 'nsub',
                    '\u2282\u20D2': 'vnsub',
                    '\u2283': 'sup',
                    '\u2285': 'nsup',
                    '\u2283\u20D2': 'vnsup',
                    '\u2286': 'sube',
                    '\u2288': 'nsube',
                    '\u2287': 'supe',
                    '\u2289': 'nsupe',
                    '\u228A\uFE00': 'vsubne',
                    '\u228A': 'subne',
                    '\u228B\uFE00': 'vsupne',
                    '\u228B': 'supne',
                    '\u228D': 'cupdot',
                    '\u228E': 'uplus',
                    '\u228F': 'sqsub',
                    '\u228F\u0338': 'NotSquareSubset',
                    '\u2290': 'sqsup',
                    '\u2290\u0338': 'NotSquareSuperset',
                    '\u2291': 'sqsube',
                    '\u22E2': 'nsqsube',
                    '\u2292': 'sqsupe',
                    '\u22E3': 'nsqsupe',
                    '\u2293': 'sqcap',
                    '\u2293\uFE00': 'sqcaps',
                    '\u2294': 'sqcup',
                    '\u2294\uFE00': 'sqcups',
                    '\u2295': 'oplus',
                    '\u2296': 'ominus',
                    '\u2297': 'otimes',
                    '\u2298': 'osol',
                    '\u2299': 'odot',
                    '\u229A': 'ocir',
                    '\u229B': 'oast',
                    '\u229D': 'odash',
                    '\u229E': 'plusb',
                    '\u229F': 'minusb',
                    '\u22A0': 'timesb',
                    '\u22A1': 'sdotb',
                    '\u22A2': 'vdash',
                    '\u22AC': 'nvdash',
                    '\u22A3': 'dashv',
                    '\u22A4': 'top',
                    '\u22A5': 'bot',
                    '\u22A7': 'models',
                    '\u22A8': 'vDash',
                    '\u22AD': 'nvDash',
                    '\u22A9': 'Vdash',
                    '\u22AE': 'nVdash',
                    '\u22AA': 'Vvdash',
                    '\u22AB': 'VDash',
                    '\u22AF': 'nVDash',
                    '\u22B0': 'prurel',
                    '\u22B2': 'vltri',
                    '\u22EA': 'nltri',
                    '\u22B3': 'vrtri',
                    '\u22EB': 'nrtri',
                    '\u22B4': 'ltrie',
                    '\u22EC': 'nltrie',
                    '\u22B4\u20D2': 'nvltrie',
                    '\u22B5': 'rtrie',
                    '\u22ED': 'nrtrie',
                    '\u22B5\u20D2': 'nvrtrie',
                    '\u22B6': 'origof',
                    '\u22B7': 'imof',
                    '\u22B8': 'mumap',
                    '\u22B9': 'hercon',
                    '\u22BA': 'intcal',
                    '\u22BB': 'veebar',
                    '\u22BD': 'barvee',
                    '\u22BE': 'angrtvb',
                    '\u22BF': 'lrtri',
                    '\u22C0': 'Wedge',
                    '\u22C1': 'Vee',
                    '\u22C2': 'xcap',
                    '\u22C3': 'xcup',
                    '\u22C4': 'diam',
                    '\u22C5': 'sdot',
                    '\u22C6': 'Star',
                    '\u22C7': 'divonx',
                    '\u22C8': 'bowtie',
                    '\u22C9': 'ltimes',
                    '\u22CA': 'rtimes',
                    '\u22CB': 'lthree',
                    '\u22CC': 'rthree',
                    '\u22CD': 'bsime',
                    '\u22CE': 'cuvee',
                    '\u22CF': 'cuwed',
                    '\u22D0': 'Sub',
                    '\u22D1': 'Sup',
                    '\u22D2': 'Cap',
                    '\u22D3': 'Cup',
                    '\u22D4': 'fork',
                    '\u22D5': 'epar',
                    '\u22D6': 'ltdot',
                    '\u22D7': 'gtdot',
                    '\u22D8': 'Ll',
                    '\u22D8\u0338': 'nLl',
                    '\u22D9': 'Gg',
                    '\u22D9\u0338': 'nGg',
                    '\u22DA\uFE00': 'lesg',
                    '\u22DA': 'leg',
                    '\u22DB': 'gel',
                    '\u22DB\uFE00': 'gesl',
                    '\u22DE': 'cuepr',
                    '\u22DF': 'cuesc',
                    '\u22E6': 'lnsim',
                    '\u22E7': 'gnsim',
                    '\u22E8': 'prnsim',
                    '\u22E9': 'scnsim',
                    '\u22EE': 'vellip',
                    '\u22EF': 'ctdot',
                    '\u22F0': 'utdot',
                    '\u22F1': 'dtdot',
                    '\u22F2': 'disin',
                    '\u22F3': 'isinsv',
                    '\u22F4': 'isins',
                    '\u22F5': 'isindot',
                    '\u22F5\u0338': 'notindot',
                    '\u22F6': 'notinvc',
                    '\u22F7': 'notinvb',
                    '\u22F9': 'isinE',
                    '\u22F9\u0338': 'notinE',
                    '\u22FA': 'nisd',
                    '\u22FB': 'xnis',
                    '\u22FC': 'nis',
                    '\u22FD': 'notnivc',
                    '\u22FE': 'notnivb',
                    '\u2305': 'barwed',
                    '\u2306': 'Barwed',
                    '\u230C': 'drcrop',
                    '\u230D': 'dlcrop',
                    '\u230E': 'urcrop',
                    '\u230F': 'ulcrop',
                    '\u2310': 'bnot',
                    '\u2312': 'profline',
                    '\u2313': 'profsurf',
                    '\u2315': 'telrec',
                    '\u2316': 'target',
                    '\u231C': 'ulcorn',
                    '\u231D': 'urcorn',
                    '\u231E': 'dlcorn',
                    '\u231F': 'drcorn',
                    '\u2322': 'frown',
                    '\u2323': 'smile',
                    '\u232D': 'cylcty',
                    '\u232E': 'profalar',
                    '\u2336': 'topbot',
                    '\u233D': 'ovbar',
                    '\u233F': 'solbar',
                    '\u237C': 'angzarr',
                    '\u23B0': 'lmoust',
                    '\u23B1': 'rmoust',
                    '\u23B4': 'tbrk',
                    '\u23B5': 'bbrk',
                    '\u23B6': 'bbrktbrk',
                    '\u23DC': 'OverParenthesis',
                    '\u23DD': 'UnderParenthesis',
                    '\u23DE': 'OverBrace',
                    '\u23DF': 'UnderBrace',
                    '\u23E2': 'trpezium',
                    '\u23E7': 'elinters',
                    '\u2423': 'blank',
                    '\u2500': 'boxh',
                    '\u2502': 'boxv',
                    '\u250C': 'boxdr',
                    '\u2510': 'boxdl',
                    '\u2514': 'boxur',
                    '\u2518': 'boxul',
                    '\u251C': 'boxvr',
                    '\u2524': 'boxvl',
                    '\u252C': 'boxhd',
                    '\u2534': 'boxhu',
                    '\u253C': 'boxvh',
                    '\u2550': 'boxH',
                    '\u2551': 'boxV',
                    '\u2552': 'boxdR',
                    '\u2553': 'boxDr',
                    '\u2554': 'boxDR',
                    '\u2555': 'boxdL',
                    '\u2556': 'boxDl',
                    '\u2557': 'boxDL',
                    '\u2558': 'boxuR',
                    '\u2559': 'boxUr',
                    '\u255A': 'boxUR',
                    '\u255B': 'boxuL',
                    '\u255C': 'boxUl',
                    '\u255D': 'boxUL',
                    '\u255E': 'boxvR',
                    '\u255F': 'boxVr',
                    '\u2560': 'boxVR',
                    '\u2561': 'boxvL',
                    '\u2562': 'boxVl',
                    '\u2563': 'boxVL',
                    '\u2564': 'boxHd',
                    '\u2565': 'boxhD',
                    '\u2566': 'boxHD',
                    '\u2567': 'boxHu',
                    '\u2568': 'boxhU',
                    '\u2569': 'boxHU',
                    '\u256A': 'boxvH',
                    '\u256B': 'boxVh',
                    '\u256C': 'boxVH',
                    '\u2580': 'uhblk',
                    '\u2584': 'lhblk',
                    '\u2588': 'block',
                    '\u2591': 'blk14',
                    '\u2592': 'blk12',
                    '\u2593': 'blk34',
                    '\u25A1': 'squ',
                    '\u25AA': 'squf',
                    '\u25AB': 'EmptyVerySmallSquare',
                    '\u25AD': 'rect',
                    '\u25AE': 'marker',
                    '\u25B1': 'fltns',
                    '\u25B3': 'xutri',
                    '\u25B4': 'utrif',
                    '\u25B5': 'utri',
                    '\u25B8': 'rtrif',
                    '\u25B9': 'rtri',
                    '\u25BD': 'xdtri',
                    '\u25BE': 'dtrif',
                    '\u25BF': 'dtri',
                    '\u25C2': 'ltrif',
                    '\u25C3': 'ltri',
                    '\u25CA': 'loz',
                    '\u25CB': 'cir',
                    '\u25EC': 'tridot',
                    '\u25EF': 'xcirc',
                    '\u25F8': 'ultri',
                    '\u25F9': 'urtri',
                    '\u25FA': 'lltri',
                    '\u25FB': 'EmptySmallSquare',
                    '\u25FC': 'FilledSmallSquare',
                    '\u2605': 'starf',
                    '\u2606': 'star',
                    '\u260E': 'phone',
                    '\u2640': 'female',
                    '\u2642': 'male',
                    '\u2660': 'spades',
                    '\u2663': 'clubs',
                    '\u2665': 'hearts',
                    '\u2666': 'diams',
                    '\u266A': 'sung',
                    '\u2713': 'check',
                    '\u2717': 'cross',
                    '\u2720': 'malt',
                    '\u2736': 'sext',
                    '\u2758': 'VerticalSeparator',
                    '\u27C8': 'bsolhsub',
                    '\u27C9': 'suphsol',
                    '\u27F5': 'xlarr',
                    '\u27F6': 'xrarr',
                    '\u27F7': 'xharr',
                    '\u27F8': 'xlArr',
                    '\u27F9': 'xrArr',
                    '\u27FA': 'xhArr',
                    '\u27FC': 'xmap',
                    '\u27FF': 'dzigrarr',
                    '\u2902': 'nvlArr',
                    '\u2903': 'nvrArr',
                    '\u2904': 'nvHarr',
                    '\u2905': 'Map',
                    '\u290C': 'lbarr',
                    '\u290D': 'rbarr',
                    '\u290E': 'lBarr',
                    '\u290F': 'rBarr',
                    '\u2910': 'RBarr',
                    '\u2911': 'DDotrahd',
                    '\u2912': 'UpArrowBar',
                    '\u2913': 'DownArrowBar',
                    '\u2916': 'Rarrtl',
                    '\u2919': 'latail',
                    '\u291A': 'ratail',
                    '\u291B': 'lAtail',
                    '\u291C': 'rAtail',
                    '\u291D': 'larrfs',
                    '\u291E': 'rarrfs',
                    '\u291F': 'larrbfs',
                    '\u2920': 'rarrbfs',
                    '\u2923': 'nwarhk',
                    '\u2924': 'nearhk',
                    '\u2925': 'searhk',
                    '\u2926': 'swarhk',
                    '\u2927': 'nwnear',
                    '\u2928': 'toea',
                    '\u2929': 'tosa',
                    '\u292A': 'swnwar',
                    '\u2933': 'rarrc',
                    '\u2933\u0338': 'nrarrc',
                    '\u2935': 'cudarrr',
                    '\u2936': 'ldca',
                    '\u2937': 'rdca',
                    '\u2938': 'cudarrl',
                    '\u2939': 'larrpl',
                    '\u293C': 'curarrm',
                    '\u293D': 'cularrp',
                    '\u2945': 'rarrpl',
                    '\u2948': 'harrcir',
                    '\u2949': 'Uarrocir',
                    '\u294A': 'lurdshar',
                    '\u294B': 'ldrushar',
                    '\u294E': 'LeftRightVector',
                    '\u294F': 'RightUpDownVector',
                    '\u2950': 'DownLeftRightVector',
                    '\u2951': 'LeftUpDownVector',
                    '\u2952': 'LeftVectorBar',
                    '\u2953': 'RightVectorBar',
                    '\u2954': 'RightUpVectorBar',
                    '\u2955': 'RightDownVectorBar',
                    '\u2956': 'DownLeftVectorBar',
                    '\u2957': 'DownRightVectorBar',
                    '\u2958': 'LeftUpVectorBar',
                    '\u2959': 'LeftDownVectorBar',
                    '\u295A': 'LeftTeeVector',
                    '\u295B': 'RightTeeVector',
                    '\u295C': 'RightUpTeeVector',
                    '\u295D': 'RightDownTeeVector',
                    '\u295E': 'DownLeftTeeVector',
                    '\u295F': 'DownRightTeeVector',
                    '\u2960': 'LeftUpTeeVector',
                    '\u2961': 'LeftDownTeeVector',
                    '\u2962': 'lHar',
                    '\u2963': 'uHar',
                    '\u2964': 'rHar',
                    '\u2965': 'dHar',
                    '\u2966': 'luruhar',
                    '\u2967': 'ldrdhar',
                    '\u2968': 'ruluhar',
                    '\u2969': 'rdldhar',
                    '\u296A': 'lharul',
                    '\u296B': 'llhard',
                    '\u296C': 'rharul',
                    '\u296D': 'lrhard',
                    '\u296E': 'udhar',
                    '\u296F': 'duhar',
                    '\u2970': 'RoundImplies',
                    '\u2971': 'erarr',
                    '\u2972': 'simrarr',
                    '\u2973': 'larrsim',
                    '\u2974': 'rarrsim',
                    '\u2975': 'rarrap',
                    '\u2976': 'ltlarr',
                    '\u2978': 'gtrarr',
                    '\u2979': 'subrarr',
                    '\u297B': 'suplarr',
                    '\u297C': 'lfisht',
                    '\u297D': 'rfisht',
                    '\u297E': 'ufisht',
                    '\u297F': 'dfisht',
                    '\u299A': 'vzigzag',
                    '\u299C': 'vangrt',
                    '\u299D': 'angrtvbd',
                    '\u29A4': 'ange',
                    '\u29A5': 'range',
                    '\u29A6': 'dwangle',
                    '\u29A7': 'uwangle',
                    '\u29A8': 'angmsdaa',
                    '\u29A9': 'angmsdab',
                    '\u29AA': 'angmsdac',
                    '\u29AB': 'angmsdad',
                    '\u29AC': 'angmsdae',
                    '\u29AD': 'angmsdaf',
                    '\u29AE': 'angmsdag',
                    '\u29AF': 'angmsdah',
                    '\u29B0': 'bemptyv',
                    '\u29B1': 'demptyv',
                    '\u29B2': 'cemptyv',
                    '\u29B3': 'raemptyv',
                    '\u29B4': 'laemptyv',
                    '\u29B5': 'ohbar',
                    '\u29B6': 'omid',
                    '\u29B7': 'opar',
                    '\u29B9': 'operp',
                    '\u29BB': 'olcross',
                    '\u29BC': 'odsold',
                    '\u29BE': 'olcir',
                    '\u29BF': 'ofcir',
                    '\u29C0': 'olt',
                    '\u29C1': 'ogt',
                    '\u29C2': 'cirscir',
                    '\u29C3': 'cirE',
                    '\u29C4': 'solb',
                    '\u29C5': 'bsolb',
                    '\u29C9': 'boxbox',
                    '\u29CD': 'trisb',
                    '\u29CE': 'rtriltri',
                    '\u29CF': 'LeftTriangleBar',
                    '\u29CF\u0338': 'NotLeftTriangleBar',
                    '\u29D0': 'RightTriangleBar',
                    '\u29D0\u0338': 'NotRightTriangleBar',
                    '\u29DC': 'iinfin',
                    '\u29DD': 'infintie',
                    '\u29DE': 'nvinfin',
                    '\u29E3': 'eparsl',
                    '\u29E4': 'smeparsl',
                    '\u29E5': 'eqvparsl',
                    '\u29EB': 'lozf',
                    '\u29F4': 'RuleDelayed',
                    '\u29F6': 'dsol',
                    '\u2A00': 'xodot',
                    '\u2A01': 'xoplus',
                    '\u2A02': 'xotime',
                    '\u2A04': 'xuplus',
                    '\u2A06': 'xsqcup',
                    '\u2A0D': 'fpartint',
                    '\u2A10': 'cirfnint',
                    '\u2A11': 'awint',
                    '\u2A12': 'rppolint',
                    '\u2A13': 'scpolint',
                    '\u2A14': 'npolint',
                    '\u2A15': 'pointint',
                    '\u2A16': 'quatint',
                    '\u2A17': 'intlarhk',
                    '\u2A22': 'pluscir',
                    '\u2A23': 'plusacir',
                    '\u2A24': 'simplus',
                    '\u2A25': 'plusdu',
                    '\u2A26': 'plussim',
                    '\u2A27': 'plustwo',
                    '\u2A29': 'mcomma',
                    '\u2A2A': 'minusdu',
                    '\u2A2D': 'loplus',
                    '\u2A2E': 'roplus',
                    '\u2A2F': 'Cross',
                    '\u2A30': 'timesd',
                    '\u2A31': 'timesbar',
                    '\u2A33': 'smashp',
                    '\u2A34': 'lotimes',
                    '\u2A35': 'rotimes',
                    '\u2A36': 'otimesas',
                    '\u2A37': 'Otimes',
                    '\u2A38': 'odiv',
                    '\u2A39': 'triplus',
                    '\u2A3A': 'triminus',
                    '\u2A3B': 'tritime',
                    '\u2A3C': 'iprod',
                    '\u2A3F': 'amalg',
                    '\u2A40': 'capdot',
                    '\u2A42': 'ncup',
                    '\u2A43': 'ncap',
                    '\u2A44': 'capand',
                    '\u2A45': 'cupor',
                    '\u2A46': 'cupcap',
                    '\u2A47': 'capcup',
                    '\u2A48': 'cupbrcap',
                    '\u2A49': 'capbrcup',
                    '\u2A4A': 'cupcup',
                    '\u2A4B': 'capcap',
                    '\u2A4C': 'ccups',
                    '\u2A4D': 'ccaps',
                    '\u2A50': 'ccupssm',
                    '\u2A53': 'And',
                    '\u2A54': 'Or',
                    '\u2A55': 'andand',
                    '\u2A56': 'oror',
                    '\u2A57': 'orslope',
                    '\u2A58': 'andslope',
                    '\u2A5A': 'andv',
                    '\u2A5B': 'orv',
                    '\u2A5C': 'andd',
                    '\u2A5D': 'ord',
                    '\u2A5F': 'wedbar',
                    '\u2A66': 'sdote',
                    '\u2A6A': 'simdot',
                    '\u2A6D': 'congdot',
                    '\u2A6D\u0338': 'ncongdot',
                    '\u2A6E': 'easter',
                    '\u2A6F': 'apacir',
                    '\u2A70': 'apE',
                    '\u2A70\u0338': 'napE',
                    '\u2A71': 'eplus',
                    '\u2A72': 'pluse',
                    '\u2A73': 'Esim',
                    '\u2A77': 'eDDot',
                    '\u2A78': 'equivDD',
                    '\u2A79': 'ltcir',
                    '\u2A7A': 'gtcir',
                    '\u2A7B': 'ltquest',
                    '\u2A7C': 'gtquest',
                    '\u2A7D': 'les',
                    '\u2A7D\u0338': 'nles',
                    '\u2A7E': 'ges',
                    '\u2A7E\u0338': 'nges',
                    '\u2A7F': 'lesdot',
                    '\u2A80': 'gesdot',
                    '\u2A81': 'lesdoto',
                    '\u2A82': 'gesdoto',
                    '\u2A83': 'lesdotor',
                    '\u2A84': 'gesdotol',
                    '\u2A85': 'lap',
                    '\u2A86': 'gap',
                    '\u2A87': 'lne',
                    '\u2A88': 'gne',
                    '\u2A89': 'lnap',
                    '\u2A8A': 'gnap',
                    '\u2A8B': 'lEg',
                    '\u2A8C': 'gEl',
                    '\u2A8D': 'lsime',
                    '\u2A8E': 'gsime',
                    '\u2A8F': 'lsimg',
                    '\u2A90': 'gsiml',
                    '\u2A91': 'lgE',
                    '\u2A92': 'glE',
                    '\u2A93': 'lesges',
                    '\u2A94': 'gesles',
                    '\u2A95': 'els',
                    '\u2A96': 'egs',
                    '\u2A97': 'elsdot',
                    '\u2A98': 'egsdot',
                    '\u2A99': 'el',
                    '\u2A9A': 'eg',
                    '\u2A9D': 'siml',
                    '\u2A9E': 'simg',
                    '\u2A9F': 'simlE',
                    '\u2AA0': 'simgE',
                    '\u2AA1': 'LessLess',
                    '\u2AA1\u0338': 'NotNestedLessLess',
                    '\u2AA2': 'GreaterGreater',
                    '\u2AA2\u0338': 'NotNestedGreaterGreater',
                    '\u2AA4': 'glj',
                    '\u2AA5': 'gla',
                    '\u2AA6': 'ltcc',
                    '\u2AA7': 'gtcc',
                    '\u2AA8': 'lescc',
                    '\u2AA9': 'gescc',
                    '\u2AAA': 'smt',
                    '\u2AAB': 'lat',
                    '\u2AAC': 'smte',
                    '\u2AAC\uFE00': 'smtes',
                    '\u2AAD': 'late',
                    '\u2AAD\uFE00': 'lates',
                    '\u2AAE': 'bumpE',
                    '\u2AAF': 'pre',
                    '\u2AAF\u0338': 'npre',
                    '\u2AB0': 'sce',
                    '\u2AB0\u0338': 'nsce',
                    '\u2AB3': 'prE',
                    '\u2AB4': 'scE',
                    '\u2AB5': 'prnE',
                    '\u2AB6': 'scnE',
                    '\u2AB7': 'prap',
                    '\u2AB8': 'scap',
                    '\u2AB9': 'prnap',
                    '\u2ABA': 'scnap',
                    '\u2ABB': 'Pr',
                    '\u2ABC': 'Sc',
                    '\u2ABD': 'subdot',
                    '\u2ABE': 'supdot',
                    '\u2ABF': 'subplus',
                    '\u2AC0': 'supplus',
                    '\u2AC1': 'submult',
                    '\u2AC2': 'supmult',
                    '\u2AC3': 'subedot',
                    '\u2AC4': 'supedot',
                    '\u2AC5': 'subE',
                    '\u2AC5\u0338': 'nsubE',
                    '\u2AC6': 'supE',
                    '\u2AC6\u0338': 'nsupE',
                    '\u2AC7': 'subsim',
                    '\u2AC8': 'supsim',
                    '\u2ACB\uFE00': 'vsubnE',
                    '\u2ACB': 'subnE',
                    '\u2ACC\uFE00': 'vsupnE',
                    '\u2ACC': 'supnE',
                    '\u2ACF': 'csub',
                    '\u2AD0': 'csup',
                    '\u2AD1': 'csube',
                    '\u2AD2': 'csupe',
                    '\u2AD3': 'subsup',
                    '\u2AD4': 'supsub',
                    '\u2AD5': 'subsub',
                    '\u2AD6': 'supsup',
                    '\u2AD7': 'suphsub',
                    '\u2AD8': 'supdsub',
                    '\u2AD9': 'forkv',
                    '\u2ADA': 'topfork',
                    '\u2ADB': 'mlcp',
                    '\u2AE4': 'Dashv',
                    '\u2AE6': 'Vdashl',
                    '\u2AE7': 'Barv',
                    '\u2AE8': 'vBar',
                    '\u2AE9': 'vBarv',
                    '\u2AEB': 'Vbar',
                    '\u2AEC': 'Not',
                    '\u2AED': 'bNot',
                    '\u2AEE': 'rnmid',
                    '\u2AEF': 'cirmid',
                    '\u2AF0': 'midcir',
                    '\u2AF1': 'topcir',
                    '\u2AF2': 'nhpar',
                    '\u2AF3': 'parsim',
                    '\u2AFD': 'parsl',
                    '\u2AFD\u20E5': 'nparsl',
                    '\u266D': 'flat',
                    '\u266E': 'natur',
                    '\u266F': 'sharp',
                    '\xA4': 'curren',
                    '\xA2': 'cent',
                    $: 'dollar',
                    '\xA3': 'pound',
                    '\xA5': 'yen',
                    '\u20AC': 'euro',
                    '\xB9': 'sup1',
                    '\xBD': 'half',
                    '\u2153': 'frac13',
                    '\xBC': 'frac14',
                    '\u2155': 'frac15',
                    '\u2159': 'frac16',
                    '\u215B': 'frac18',
                    '\xB2': 'sup2',
                    '\u2154': 'frac23',
                    '\u2156': 'frac25',
                    '\xB3': 'sup3',
                    '\xBE': 'frac34',
                    '\u2157': 'frac35',
                    '\u215C': 'frac38',
                    '\u2158': 'frac45',
                    '\u215A': 'frac56',
                    '\u215D': 'frac58',
                    '\u215E': 'frac78',
                    '\uD835\uDCB6': 'ascr',
                    '\uD835\uDD52': 'aopf',
                    '\uD835\uDD1E': 'afr',
                    '\uD835\uDD38': 'Aopf',
                    '\uD835\uDD04': 'Afr',
                    '\uD835\uDC9C': 'Ascr',
                    '\xAA': 'ordf',
                    '\xE1': 'aacute',
                    '\xC1': 'Aacute',
                    '\xE0': 'agrave',
                    '\xC0': 'Agrave',
                    '\u0103': 'abreve',
                    '\u0102': 'Abreve',
                    '\xE2': 'acirc',
                    '\xC2': 'Acirc',
                    '\xE5': 'aring',
                    '\xC5': 'angst',
                    '\xE4': 'auml',
                    '\xC4': 'Auml',
                    '\xE3': 'atilde',
                    '\xC3': 'Atilde',
                    '\u0105': 'aogon',
                    '\u0104': 'Aogon',
                    '\u0101': 'amacr',
                    '\u0100': 'Amacr',
                    '\xE6': 'aelig',
                    '\xC6': 'AElig',
                    '\uD835\uDCB7': 'bscr',
                    '\uD835\uDD53': 'bopf',
                    '\uD835\uDD1F': 'bfr',
                    '\uD835\uDD39': 'Bopf',
                    '\u212C': 'Bscr',
                    '\uD835\uDD05': 'Bfr',
                    '\uD835\uDD20': 'cfr',
                    '\uD835\uDCB8': 'cscr',
                    '\uD835\uDD54': 'copf',
                    '\u212D': 'Cfr',
                    '\uD835\uDC9E': 'Cscr',
                    '\u2102': 'Copf',
                    '\u0107': 'cacute',
                    '\u0106': 'Cacute',
                    '\u0109': 'ccirc',
                    '\u0108': 'Ccirc',
                    '\u010D': 'ccaron',
                    '\u010C': 'Ccaron',
                    '\u010B': 'cdot',
                    '\u010A': 'Cdot',
                    '\xE7': 'ccedil',
                    '\xC7': 'Ccedil',
                    '\u2105': 'incare',
                    '\uD835\uDD21': 'dfr',
                    '\u2146': 'dd',
                    '\uD835\uDD55': 'dopf',
                    '\uD835\uDCB9': 'dscr',
                    '\uD835\uDC9F': 'Dscr',
                    '\uD835\uDD07': 'Dfr',
                    '\u2145': 'DD',
                    '\uD835\uDD3B': 'Dopf',
                    '\u010F': 'dcaron',
                    '\u010E': 'Dcaron',
                    '\u0111': 'dstrok',
                    '\u0110': 'Dstrok',
                    '\xF0': 'eth',
                    '\xD0': 'ETH',
                    '\u2147': 'ee',
                    '\u212F': 'escr',
                    '\uD835\uDD22': 'efr',
                    '\uD835\uDD56': 'eopf',
                    '\u2130': 'Escr',
                    '\uD835\uDD08': 'Efr',
                    '\uD835\uDD3C': 'Eopf',
                    '\xE9': 'eacute',
                    '\xC9': 'Eacute',
                    '\xE8': 'egrave',
                    '\xC8': 'Egrave',
                    '\xEA': 'ecirc',
                    '\xCA': 'Ecirc',
                    '\u011B': 'ecaron',
                    '\u011A': 'Ecaron',
                    '\xEB': 'euml',
                    '\xCB': 'Euml',
                    '\u0117': 'edot',
                    '\u0116': 'Edot',
                    '\u0119': 'eogon',
                    '\u0118': 'Eogon',
                    '\u0113': 'emacr',
                    '\u0112': 'Emacr',
                    '\uD835\uDD23': 'ffr',
                    '\uD835\uDD57': 'fopf',
                    '\uD835\uDCBB': 'fscr',
                    '\uD835\uDD09': 'Ffr',
                    '\uD835\uDD3D': 'Fopf',
                    '\u2131': 'Fscr',
                    '\uFB00': 'fflig',
                    '\uFB03': 'ffilig',
                    '\uFB04': 'ffllig',
                    '\uFB01': 'filig',
                    fj: 'fjlig',
                    '\uFB02': 'fllig',
                    '\u0192': 'fnof',
                    '\u210A': 'gscr',
                    '\uD835\uDD58': 'gopf',
                    '\uD835\uDD24': 'gfr',
                    '\uD835\uDCA2': 'Gscr',
                    '\uD835\uDD3E': 'Gopf',
                    '\uD835\uDD0A': 'Gfr',
                    '\u01F5': 'gacute',
                    '\u011F': 'gbreve',
                    '\u011E': 'Gbreve',
                    '\u011D': 'gcirc',
                    '\u011C': 'Gcirc',
                    '\u0121': 'gdot',
                    '\u0120': 'Gdot',
                    '\u0122': 'Gcedil',
                    '\uD835\uDD25': 'hfr',
                    '\u210E': 'planckh',
                    '\uD835\uDCBD': 'hscr',
                    '\uD835\uDD59': 'hopf',
                    '\u210B': 'Hscr',
                    '\u210C': 'Hfr',
                    '\u210D': 'Hopf',
                    '\u0125': 'hcirc',
                    '\u0124': 'Hcirc',
                    '\u210F': 'hbar',
                    '\u0127': 'hstrok',
                    '\u0126': 'Hstrok',
                    '\uD835\uDD5A': 'iopf',
                    '\uD835\uDD26': 'ifr',
                    '\uD835\uDCBE': 'iscr',
                    '\u2148': 'ii',
                    '\uD835\uDD40': 'Iopf',
                    '\u2110': 'Iscr',
                    '\u2111': 'Im',
                    '\xED': 'iacute',
                    '\xCD': 'Iacute',
                    '\xEC': 'igrave',
                    '\xCC': 'Igrave',
                    '\xEE': 'icirc',
                    '\xCE': 'Icirc',
                    '\xEF': 'iuml',
                    '\xCF': 'Iuml',
                    '\u0129': 'itilde',
                    '\u0128': 'Itilde',
                    '\u0130': 'Idot',
                    '\u012F': 'iogon',
                    '\u012E': 'Iogon',
                    '\u012B': 'imacr',
                    '\u012A': 'Imacr',
                    '\u0133': 'ijlig',
                    '\u0132': 'IJlig',
                    '\u0131': 'imath',
                    '\uD835\uDCBF': 'jscr',
                    '\uD835\uDD5B': 'jopf',
                    '\uD835\uDD27': 'jfr',
                    '\uD835\uDCA5': 'Jscr',
                    '\uD835\uDD0D': 'Jfr',
                    '\uD835\uDD41': 'Jopf',
                    '\u0135': 'jcirc',
                    '\u0134': 'Jcirc',
                    '\u0237': 'jmath',
                    '\uD835\uDD5C': 'kopf',
                    '\uD835\uDCC0': 'kscr',
                    '\uD835\uDD28': 'kfr',
                    '\uD835\uDCA6': 'Kscr',
                    '\uD835\uDD42': 'Kopf',
                    '\uD835\uDD0E': 'Kfr',
                    '\u0137': 'kcedil',
                    '\u0136': 'Kcedil',
                    '\uD835\uDD29': 'lfr',
                    '\uD835\uDCC1': 'lscr',
                    '\u2113': 'ell',
                    '\uD835\uDD5D': 'lopf',
                    '\u2112': 'Lscr',
                    '\uD835\uDD0F': 'Lfr',
                    '\uD835\uDD43': 'Lopf',
                    '\u013A': 'lacute',
                    '\u0139': 'Lacute',
                    '\u013E': 'lcaron',
                    '\u013D': 'Lcaron',
                    '\u013C': 'lcedil',
                    '\u013B': 'Lcedil',
                    '\u0142': 'lstrok',
                    '\u0141': 'Lstrok',
                    '\u0140': 'lmidot',
                    '\u013F': 'Lmidot',
                    '\uD835\uDD2A': 'mfr',
                    '\uD835\uDD5E': 'mopf',
                    '\uD835\uDCC2': 'mscr',
                    '\uD835\uDD10': 'Mfr',
                    '\uD835\uDD44': 'Mopf',
                    '\u2133': 'Mscr',
                    '\uD835\uDD2B': 'nfr',
                    '\uD835\uDD5F': 'nopf',
                    '\uD835\uDCC3': 'nscr',
                    '\u2115': 'Nopf',
                    '\uD835\uDCA9': 'Nscr',
                    '\uD835\uDD11': 'Nfr',
                    '\u0144': 'nacute',
                    '\u0143': 'Nacute',
                    '\u0148': 'ncaron',
                    '\u0147': 'Ncaron',
                    '\xF1': 'ntilde',
                    '\xD1': 'Ntilde',
                    '\u0146': 'ncedil',
                    '\u0145': 'Ncedil',
                    '\u2116': 'numero',
                    '\u014B': 'eng',
                    '\u014A': 'ENG',
                    '\uD835\uDD60': 'oopf',
                    '\uD835\uDD2C': 'ofr',
                    '\u2134': 'oscr',
                    '\uD835\uDCAA': 'Oscr',
                    '\uD835\uDD12': 'Ofr',
                    '\uD835\uDD46': 'Oopf',
                    '\xBA': 'ordm',
                    '\xF3': 'oacute',
                    '\xD3': 'Oacute',
                    '\xF2': 'ograve',
                    '\xD2': 'Ograve',
                    '\xF4': 'ocirc',
                    '\xD4': 'Ocirc',
                    '\xF6': 'ouml',
                    '\xD6': 'Ouml',
                    '\u0151': 'odblac',
                    '\u0150': 'Odblac',
                    '\xF5': 'otilde',
                    '\xD5': 'Otilde',
                    '\xF8': 'oslash',
                    '\xD8': 'Oslash',
                    '\u014D': 'omacr',
                    '\u014C': 'Omacr',
                    '\u0153': 'oelig',
                    '\u0152': 'OElig',
                    '\uD835\uDD2D': 'pfr',
                    '\uD835\uDCC5': 'pscr',
                    '\uD835\uDD61': 'popf',
                    '\u2119': 'Popf',
                    '\uD835\uDD13': 'Pfr',
                    '\uD835\uDCAB': 'Pscr',
                    '\uD835\uDD62': 'qopf',
                    '\uD835\uDD2E': 'qfr',
                    '\uD835\uDCC6': 'qscr',
                    '\uD835\uDCAC': 'Qscr',
                    '\uD835\uDD14': 'Qfr',
                    '\u211A': 'Qopf',
                    '\u0138': 'kgreen',
                    '\uD835\uDD2F': 'rfr',
                    '\uD835\uDD63': 'ropf',
                    '\uD835\uDCC7': 'rscr',
                    '\u211B': 'Rscr',
                    '\u211C': 'Re',
                    '\u211D': 'Ropf',
                    '\u0155': 'racute',
                    '\u0154': 'Racute',
                    '\u0159': 'rcaron',
                    '\u0158': 'Rcaron',
                    '\u0157': 'rcedil',
                    '\u0156': 'Rcedil',
                    '\uD835\uDD64': 'sopf',
                    '\uD835\uDCC8': 'sscr',
                    '\uD835\uDD30': 'sfr',
                    '\uD835\uDD4A': 'Sopf',
                    '\uD835\uDD16': 'Sfr',
                    '\uD835\uDCAE': 'Sscr',
                    '\u24C8': 'oS',
                    '\u015B': 'sacute',
                    '\u015A': 'Sacute',
                    '\u015D': 'scirc',
                    '\u015C': 'Scirc',
                    '\u0161': 'scaron',
                    '\u0160': 'Scaron',
                    '\u015F': 'scedil',
                    '\u015E': 'Scedil',
                    '\xDF': 'szlig',
                    '\uD835\uDD31': 'tfr',
                    '\uD835\uDCC9': 'tscr',
                    '\uD835\uDD65': 'topf',
                    '\uD835\uDCAF': 'Tscr',
                    '\uD835\uDD17': 'Tfr',
                    '\uD835\uDD4B': 'Topf',
                    '\u0165': 'tcaron',
                    '\u0164': 'Tcaron',
                    '\u0163': 'tcedil',
                    '\u0162': 'Tcedil',
                    '\u2122': 'trade',
                    '\u0167': 'tstrok',
                    '\u0166': 'Tstrok',
                    '\uD835\uDCCA': 'uscr',
                    '\uD835\uDD66': 'uopf',
                    '\uD835\uDD32': 'ufr',
                    '\uD835\uDD4C': 'Uopf',
                    '\uD835\uDD18': 'Ufr',
                    '\uD835\uDCB0': 'Uscr',
                    '\xFA': 'uacute',
                    '\xDA': 'Uacute',
                    '\xF9': 'ugrave',
                    '\xD9': 'Ugrave',
                    '\u016D': 'ubreve',
                    '\u016C': 'Ubreve',
                    '\xFB': 'ucirc',
                    '\xDB': 'Ucirc',
                    '\u016F': 'uring',
                    '\u016E': 'Uring',
                    '\xFC': 'uuml',
                    '\xDC': 'Uuml',
                    '\u0171': 'udblac',
                    '\u0170': 'Udblac',
                    '\u0169': 'utilde',
                    '\u0168': 'Utilde',
                    '\u0173': 'uogon',
                    '\u0172': 'Uogon',
                    '\u016B': 'umacr',
                    '\u016A': 'Umacr',
                    '\uD835\uDD33': 'vfr',
                    '\uD835\uDD67': 'vopf',
                    '\uD835\uDCCB': 'vscr',
                    '\uD835\uDD19': 'Vfr',
                    '\uD835\uDD4D': 'Vopf',
                    '\uD835\uDCB1': 'Vscr',
                    '\uD835\uDD68': 'wopf',
                    '\uD835\uDCCC': 'wscr',
                    '\uD835\uDD34': 'wfr',
                    '\uD835\uDCB2': 'Wscr',
                    '\uD835\uDD4E': 'Wopf',
                    '\uD835\uDD1A': 'Wfr',
                    '\u0175': 'wcirc',
                    '\u0174': 'Wcirc',
                    '\uD835\uDD35': 'xfr',
                    '\uD835\uDCCD': 'xscr',
                    '\uD835\uDD69': 'xopf',
                    '\uD835\uDD4F': 'Xopf',
                    '\uD835\uDD1B': 'Xfr',
                    '\uD835\uDCB3': 'Xscr',
                    '\uD835\uDD36': 'yfr',
                    '\uD835\uDCCE': 'yscr',
                    '\uD835\uDD6A': 'yopf',
                    '\uD835\uDCB4': 'Yscr',
                    '\uD835\uDD1C': 'Yfr',
                    '\uD835\uDD50': 'Yopf',
                    '\xFD': 'yacute',
                    '\xDD': 'Yacute',
                    '\u0177': 'ycirc',
                    '\u0176': 'Ycirc',
                    '\xFF': 'yuml',
                    '\u0178': 'Yuml',
                    '\uD835\uDCCF': 'zscr',
                    '\uD835\uDD37': 'zfr',
                    '\uD835\uDD6B': 'zopf',
                    '\u2128': 'Zfr',
                    '\u2124': 'Zopf',
                    '\uD835\uDCB5': 'Zscr',
                    '\u017A': 'zacute',
                    '\u0179': 'Zacute',
                    '\u017E': 'zcaron',
                    '\u017D': 'Zcaron',
                    '\u017C': 'zdot',
                    '\u017B': 'Zdot',
                    '\u01B5': 'imped',
                    '\xFE': 'thorn',
                    '\xDE': 'THORN',
                    '\u0149': 'napos',
                    '\u03B1': 'alpha',
                    '\u0391': 'Alpha',
                    '\u03B2': 'beta',
                    '\u0392': 'Beta',
                    '\u03B3': 'gamma',
                    '\u0393': 'Gamma',
                    '\u03B4': 'delta',
                    '\u0394': 'Delta',
                    '\u03B5': 'epsi',
                    '\u03F5': 'epsiv',
                    '\u0395': 'Epsilon',
                    '\u03DD': 'gammad',
                    '\u03DC': 'Gammad',
                    '\u03B6': 'zeta',
                    '\u0396': 'Zeta',
                    '\u03B7': 'eta',
                    '\u0397': 'Eta',
                    '\u03B8': 'theta',
                    '\u03D1': 'thetav',
                    '\u0398': 'Theta',
                    '\u03B9': 'iota',
                    '\u0399': 'Iota',
                    '\u03BA': 'kappa',
                    '\u03F0': 'kappav',
                    '\u039A': 'Kappa',
                    '\u03BB': 'lambda',
                    '\u039B': 'Lambda',
                    '\u03BC': 'mu',
                    '\xB5': 'micro',
                    '\u039C': 'Mu',
                    '\u03BD': 'nu',
                    '\u039D': 'Nu',
                    '\u03BE': 'xi',
                    '\u039E': 'Xi',
                    '\u03BF': 'omicron',
                    '\u039F': 'Omicron',
                    '\u03C0': 'pi',
                    '\u03D6': 'piv',
                    '\u03A0': 'Pi',
                    '\u03C1': 'rho',
                    '\u03F1': 'rhov',
                    '\u03A1': 'Rho',
                    '\u03C3': 'sigma',
                    '\u03A3': 'Sigma',
                    '\u03C2': 'sigmaf',
                    '\u03C4': 'tau',
                    '\u03A4': 'Tau',
                    '\u03C5': 'upsi',
                    '\u03A5': 'Upsilon',
                    '\u03D2': 'Upsi',
                    '\u03C6': 'phi',
                    '\u03D5': 'phiv',
                    '\u03A6': 'Phi',
                    '\u03C7': 'chi',
                    '\u03A7': 'Chi',
                    '\u03C8': 'psi',
                    '\u03A8': 'Psi',
                    '\u03C9': 'omega',
                    '\u03A9': 'ohm',
                    '\u0430': 'acy',
                    '\u0410': 'Acy',
                    '\u0431': 'bcy',
                    '\u0411': 'Bcy',
                    '\u0432': 'vcy',
                    '\u0412': 'Vcy',
                    '\u0433': 'gcy',
                    '\u0413': 'Gcy',
                    '\u0453': 'gjcy',
                    '\u0403': 'GJcy',
                    '\u0434': 'dcy',
                    '\u0414': 'Dcy',
                    '\u0452': 'djcy',
                    '\u0402': 'DJcy',
                    '\u0435': 'iecy',
                    '\u0415': 'IEcy',
                    '\u0451': 'iocy',
                    '\u0401': 'IOcy',
                    '\u0454': 'jukcy',
                    '\u0404': 'Jukcy',
                    '\u0436': 'zhcy',
                    '\u0416': 'ZHcy',
                    '\u0437': 'zcy',
                    '\u0417': 'Zcy',
                    '\u0455': 'dscy',
                    '\u0405': 'DScy',
                    '\u0438': 'icy',
                    '\u0418': 'Icy',
                    '\u0456': 'iukcy',
                    '\u0406': 'Iukcy',
                    '\u0457': 'yicy',
                    '\u0407': 'YIcy',
                    '\u0439': 'jcy',
                    '\u0419': 'Jcy',
                    '\u0458': 'jsercy',
                    '\u0408': 'Jsercy',
                    '\u043A': 'kcy',
                    '\u041A': 'Kcy',
                    '\u045C': 'kjcy',
                    '\u040C': 'KJcy',
                    '\u043B': 'lcy',
                    '\u041B': 'Lcy',
                    '\u0459': 'ljcy',
                    '\u0409': 'LJcy',
                    '\u043C': 'mcy',
                    '\u041C': 'Mcy',
                    '\u043D': 'ncy',
                    '\u041D': 'Ncy',
                    '\u045A': 'njcy',
                    '\u040A': 'NJcy',
                    '\u043E': 'ocy',
                    '\u041E': 'Ocy',
                    '\u043F': 'pcy',
                    '\u041F': 'Pcy',
                    '\u0440': 'rcy',
                    '\u0420': 'Rcy',
                    '\u0441': 'scy',
                    '\u0421': 'Scy',
                    '\u0442': 'tcy',
                    '\u0422': 'Tcy',
                    '\u045B': 'tshcy',
                    '\u040B': 'TSHcy',
                    '\u0443': 'ucy',
                    '\u0423': 'Ucy',
                    '\u045E': 'ubrcy',
                    '\u040E': 'Ubrcy',
                    '\u0444': 'fcy',
                    '\u0424': 'Fcy',
                    '\u0445': 'khcy',
                    '\u0425': 'KHcy',
                    '\u0446': 'tscy',
                    '\u0426': 'TScy',
                    '\u0447': 'chcy',
                    '\u0427': 'CHcy',
                    '\u045F': 'dzcy',
                    '\u040F': 'DZcy',
                    '\u0448': 'shcy',
                    '\u0428': 'SHcy',
                    '\u0449': 'shchcy',
                    '\u0429': 'SHCHcy',
                    '\u044A': 'hardcy',
                    '\u042A': 'HARDcy',
                    '\u044B': 'ycy',
                    '\u042B': 'Ycy',
                    '\u044C': 'softcy',
                    '\u042C': 'SOFTcy',
                    '\u044D': 'ecy',
                    '\u042D': 'Ecy',
                    '\u044E': 'yucy',
                    '\u042E': 'YUcy',
                    '\u044F': 'yacy',
                    '\u042F': 'YAcy',
                    '\u2135': 'aleph',
                    '\u2136': 'beth',
                    '\u2137': 'gimel',
                    '\u2138': 'daleth'
                };

                var regexEscape = /["&'<>`]/g;
                var escapeMap = {
                    '"': '&quot;',
                    '&': '&amp;',
                    "'": '&#x27;',
                    '<': '&lt;',
                    // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
                    // following is not strictly necessary unless it’s part of a tag or an
                    // unquoted attribute value. We’re only escaping it to support those
                    // situations, and for XML support.
                    '>': '&gt;',
                    // In Internet Explorer ≤ 8, the backtick character can be used
                    // to break out of (un)quoted attribute values or HTML comments.
                    // See http://html5sec.org/#102, http://html5sec.org/#108, and
                    // http://html5sec.org/#133.
                    '`': '&#x60;'
                };

                var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
                var regexInvalidRawCodePoint =
                    /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                var regexDecode =
                    /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
                var decodeMap = {
                    aacute: '\xE1',
                    Aacute: '\xC1',
                    abreve: '\u0103',
                    Abreve: '\u0102',
                    ac: '\u223E',
                    acd: '\u223F',
                    acE: '\u223E\u0333',
                    acirc: '\xE2',
                    Acirc: '\xC2',
                    acute: '\xB4',
                    acy: '\u0430',
                    Acy: '\u0410',
                    aelig: '\xE6',
                    AElig: '\xC6',
                    af: '\u2061',
                    afr: '\uD835\uDD1E',
                    Afr: '\uD835\uDD04',
                    agrave: '\xE0',
                    Agrave: '\xC0',
                    alefsym: '\u2135',
                    aleph: '\u2135',
                    alpha: '\u03B1',
                    Alpha: '\u0391',
                    amacr: '\u0101',
                    Amacr: '\u0100',
                    amalg: '\u2A3F',
                    amp: '&',
                    AMP: '&',
                    and: '\u2227',
                    And: '\u2A53',
                    andand: '\u2A55',
                    andd: '\u2A5C',
                    andslope: '\u2A58',
                    andv: '\u2A5A',
                    ang: '\u2220',
                    ange: '\u29A4',
                    angle: '\u2220',
                    angmsd: '\u2221',
                    angmsdaa: '\u29A8',
                    angmsdab: '\u29A9',
                    angmsdac: '\u29AA',
                    angmsdad: '\u29AB',
                    angmsdae: '\u29AC',
                    angmsdaf: '\u29AD',
                    angmsdag: '\u29AE',
                    angmsdah: '\u29AF',
                    angrt: '\u221F',
                    angrtvb: '\u22BE',
                    angrtvbd: '\u299D',
                    angsph: '\u2222',
                    angst: '\xC5',
                    angzarr: '\u237C',
                    aogon: '\u0105',
                    Aogon: '\u0104',
                    aopf: '\uD835\uDD52',
                    Aopf: '\uD835\uDD38',
                    ap: '\u2248',
                    apacir: '\u2A6F',
                    ape: '\u224A',
                    apE: '\u2A70',
                    apid: '\u224B',
                    apos: "'",
                    ApplyFunction: '\u2061',
                    approx: '\u2248',
                    approxeq: '\u224A',
                    aring: '\xE5',
                    Aring: '\xC5',
                    ascr: '\uD835\uDCB6',
                    Ascr: '\uD835\uDC9C',
                    Assign: '\u2254',
                    ast: '*',
                    asymp: '\u2248',
                    asympeq: '\u224D',
                    atilde: '\xE3',
                    Atilde: '\xC3',
                    auml: '\xE4',
                    Auml: '\xC4',
                    awconint: '\u2233',
                    awint: '\u2A11',
                    backcong: '\u224C',
                    backepsilon: '\u03F6',
                    backprime: '\u2035',
                    backsim: '\u223D',
                    backsimeq: '\u22CD',
                    Backslash: '\u2216',
                    Barv: '\u2AE7',
                    barvee: '\u22BD',
                    barwed: '\u2305',
                    Barwed: '\u2306',
                    barwedge: '\u2305',
                    bbrk: '\u23B5',
                    bbrktbrk: '\u23B6',
                    bcong: '\u224C',
                    bcy: '\u0431',
                    Bcy: '\u0411',
                    bdquo: '\u201E',
                    becaus: '\u2235',
                    because: '\u2235',
                    Because: '\u2235',
                    bemptyv: '\u29B0',
                    bepsi: '\u03F6',
                    bernou: '\u212C',
                    Bernoullis: '\u212C',
                    beta: '\u03B2',
                    Beta: '\u0392',
                    beth: '\u2136',
                    between: '\u226C',
                    bfr: '\uD835\uDD1F',
                    Bfr: '\uD835\uDD05',
                    bigcap: '\u22C2',
                    bigcirc: '\u25EF',
                    bigcup: '\u22C3',
                    bigodot: '\u2A00',
                    bigoplus: '\u2A01',
                    bigotimes: '\u2A02',
                    bigsqcup: '\u2A06',
                    bigstar: '\u2605',
                    bigtriangledown: '\u25BD',
                    bigtriangleup: '\u25B3',
                    biguplus: '\u2A04',
                    bigvee: '\u22C1',
                    bigwedge: '\u22C0',
                    bkarow: '\u290D',
                    blacklozenge: '\u29EB',
                    blacksquare: '\u25AA',
                    blacktriangle: '\u25B4',
                    blacktriangledown: '\u25BE',
                    blacktriangleleft: '\u25C2',
                    blacktriangleright: '\u25B8',
                    blank: '\u2423',
                    blk12: '\u2592',
                    blk14: '\u2591',
                    blk34: '\u2593',
                    block: '\u2588',
                    bne: '=\u20E5',
                    bnequiv: '\u2261\u20E5',
                    bnot: '\u2310',
                    bNot: '\u2AED',
                    bopf: '\uD835\uDD53',
                    Bopf: '\uD835\uDD39',
                    bot: '\u22A5',
                    bottom: '\u22A5',
                    bowtie: '\u22C8',
                    boxbox: '\u29C9',
                    boxdl: '\u2510',
                    boxdL: '\u2555',
                    boxDl: '\u2556',
                    boxDL: '\u2557',
                    boxdr: '\u250C',
                    boxdR: '\u2552',
                    boxDr: '\u2553',
                    boxDR: '\u2554',
                    boxh: '\u2500',
                    boxH: '\u2550',
                    boxhd: '\u252C',
                    boxhD: '\u2565',
                    boxHd: '\u2564',
                    boxHD: '\u2566',
                    boxhu: '\u2534',
                    boxhU: '\u2568',
                    boxHu: '\u2567',
                    boxHU: '\u2569',
                    boxminus: '\u229F',
                    boxplus: '\u229E',
                    boxtimes: '\u22A0',
                    boxul: '\u2518',
                    boxuL: '\u255B',
                    boxUl: '\u255C',
                    boxUL: '\u255D',
                    boxur: '\u2514',
                    boxuR: '\u2558',
                    boxUr: '\u2559',
                    boxUR: '\u255A',
                    boxv: '\u2502',
                    boxV: '\u2551',
                    boxvh: '\u253C',
                    boxvH: '\u256A',
                    boxVh: '\u256B',
                    boxVH: '\u256C',
                    boxvl: '\u2524',
                    boxvL: '\u2561',
                    boxVl: '\u2562',
                    boxVL: '\u2563',
                    boxvr: '\u251C',
                    boxvR: '\u255E',
                    boxVr: '\u255F',
                    boxVR: '\u2560',
                    bprime: '\u2035',
                    breve: '\u02D8',
                    Breve: '\u02D8',
                    brvbar: '\xA6',
                    bscr: '\uD835\uDCB7',
                    Bscr: '\u212C',
                    bsemi: '\u204F',
                    bsim: '\u223D',
                    bsime: '\u22CD',
                    bsol: '\\',
                    bsolb: '\u29C5',
                    bsolhsub: '\u27C8',
                    bull: '\u2022',
                    bullet: '\u2022',
                    bump: '\u224E',
                    bumpe: '\u224F',
                    bumpE: '\u2AAE',
                    bumpeq: '\u224F',
                    Bumpeq: '\u224E',
                    cacute: '\u0107',
                    Cacute: '\u0106',
                    cap: '\u2229',
                    Cap: '\u22D2',
                    capand: '\u2A44',
                    capbrcup: '\u2A49',
                    capcap: '\u2A4B',
                    capcup: '\u2A47',
                    capdot: '\u2A40',
                    CapitalDifferentialD: '\u2145',
                    caps: '\u2229\uFE00',
                    caret: '\u2041',
                    caron: '\u02C7',
                    Cayleys: '\u212D',
                    ccaps: '\u2A4D',
                    ccaron: '\u010D',
                    Ccaron: '\u010C',
                    ccedil: '\xE7',
                    Ccedil: '\xC7',
                    ccirc: '\u0109',
                    Ccirc: '\u0108',
                    Cconint: '\u2230',
                    ccups: '\u2A4C',
                    ccupssm: '\u2A50',
                    cdot: '\u010B',
                    Cdot: '\u010A',
                    cedil: '\xB8',
                    Cedilla: '\xB8',
                    cemptyv: '\u29B2',
                    cent: '\xA2',
                    centerdot: '\xB7',
                    CenterDot: '\xB7',
                    cfr: '\uD835\uDD20',
                    Cfr: '\u212D',
                    chcy: '\u0447',
                    CHcy: '\u0427',
                    check: '\u2713',
                    checkmark: '\u2713',
                    chi: '\u03C7',
                    Chi: '\u03A7',
                    cir: '\u25CB',
                    circ: '\u02C6',
                    circeq: '\u2257',
                    circlearrowleft: '\u21BA',
                    circlearrowright: '\u21BB',
                    circledast: '\u229B',
                    circledcirc: '\u229A',
                    circleddash: '\u229D',
                    CircleDot: '\u2299',
                    circledR: '\xAE',
                    circledS: '\u24C8',
                    CircleMinus: '\u2296',
                    CirclePlus: '\u2295',
                    CircleTimes: '\u2297',
                    cire: '\u2257',
                    cirE: '\u29C3',
                    cirfnint: '\u2A10',
                    cirmid: '\u2AEF',
                    cirscir: '\u29C2',
                    ClockwiseContourIntegral: '\u2232',
                    CloseCurlyDoubleQuote: '\u201D',
                    CloseCurlyQuote: '\u2019',
                    clubs: '\u2663',
                    clubsuit: '\u2663',
                    colon: ':',
                    Colon: '\u2237',
                    colone: '\u2254',
                    Colone: '\u2A74',
                    coloneq: '\u2254',
                    comma: ',',
                    commat: '@',
                    comp: '\u2201',
                    compfn: '\u2218',
                    complement: '\u2201',
                    complexes: '\u2102',
                    cong: '\u2245',
                    congdot: '\u2A6D',
                    Congruent: '\u2261',
                    conint: '\u222E',
                    Conint: '\u222F',
                    ContourIntegral: '\u222E',
                    copf: '\uD835\uDD54',
                    Copf: '\u2102',
                    coprod: '\u2210',
                    Coproduct: '\u2210',
                    copy: '\xA9',
                    COPY: '\xA9',
                    copysr: '\u2117',
                    CounterClockwiseContourIntegral: '\u2233',
                    crarr: '\u21B5',
                    cross: '\u2717',
                    Cross: '\u2A2F',
                    cscr: '\uD835\uDCB8',
                    Cscr: '\uD835\uDC9E',
                    csub: '\u2ACF',
                    csube: '\u2AD1',
                    csup: '\u2AD0',
                    csupe: '\u2AD2',
                    ctdot: '\u22EF',
                    cudarrl: '\u2938',
                    cudarrr: '\u2935',
                    cuepr: '\u22DE',
                    cuesc: '\u22DF',
                    cularr: '\u21B6',
                    cularrp: '\u293D',
                    cup: '\u222A',
                    Cup: '\u22D3',
                    cupbrcap: '\u2A48',
                    cupcap: '\u2A46',
                    CupCap: '\u224D',
                    cupcup: '\u2A4A',
                    cupdot: '\u228D',
                    cupor: '\u2A45',
                    cups: '\u222A\uFE00',
                    curarr: '\u21B7',
                    curarrm: '\u293C',
                    curlyeqprec: '\u22DE',
                    curlyeqsucc: '\u22DF',
                    curlyvee: '\u22CE',
                    curlywedge: '\u22CF',
                    curren: '\xA4',
                    curvearrowleft: '\u21B6',
                    curvearrowright: '\u21B7',
                    cuvee: '\u22CE',
                    cuwed: '\u22CF',
                    cwconint: '\u2232',
                    cwint: '\u2231',
                    cylcty: '\u232D',
                    dagger: '\u2020',
                    Dagger: '\u2021',
                    daleth: '\u2138',
                    darr: '\u2193',
                    dArr: '\u21D3',
                    Darr: '\u21A1',
                    dash: '\u2010',
                    dashv: '\u22A3',
                    Dashv: '\u2AE4',
                    dbkarow: '\u290F',
                    dblac: '\u02DD',
                    dcaron: '\u010F',
                    Dcaron: '\u010E',
                    dcy: '\u0434',
                    Dcy: '\u0414',
                    dd: '\u2146',
                    DD: '\u2145',
                    ddagger: '\u2021',
                    ddarr: '\u21CA',
                    DDotrahd: '\u2911',
                    ddotseq: '\u2A77',
                    deg: '\xB0',
                    Del: '\u2207',
                    delta: '\u03B4',
                    Delta: '\u0394',
                    demptyv: '\u29B1',
                    dfisht: '\u297F',
                    dfr: '\uD835\uDD21',
                    Dfr: '\uD835\uDD07',
                    dHar: '\u2965',
                    dharl: '\u21C3',
                    dharr: '\u21C2',
                    DiacriticalAcute: '\xB4',
                    DiacriticalDot: '\u02D9',
                    DiacriticalDoubleAcute: '\u02DD',
                    DiacriticalGrave: '`',
                    DiacriticalTilde: '\u02DC',
                    diam: '\u22C4',
                    diamond: '\u22C4',
                    Diamond: '\u22C4',
                    diamondsuit: '\u2666',
                    diams: '\u2666',
                    die: '\xA8',
                    DifferentialD: '\u2146',
                    digamma: '\u03DD',
                    disin: '\u22F2',
                    div: '\xF7',
                    divide: '\xF7',
                    divideontimes: '\u22C7',
                    divonx: '\u22C7',
                    djcy: '\u0452',
                    DJcy: '\u0402',
                    dlcorn: '\u231E',
                    dlcrop: '\u230D',
                    dollar: '$',
                    dopf: '\uD835\uDD55',
                    Dopf: '\uD835\uDD3B',
                    dot: '\u02D9',
                    Dot: '\xA8',
                    DotDot: '\u20DC',
                    doteq: '\u2250',
                    doteqdot: '\u2251',
                    DotEqual: '\u2250',
                    dotminus: '\u2238',
                    dotplus: '\u2214',
                    dotsquare: '\u22A1',
                    doublebarwedge: '\u2306',
                    DoubleContourIntegral: '\u222F',
                    DoubleDot: '\xA8',
                    DoubleDownArrow: '\u21D3',
                    DoubleLeftArrow: '\u21D0',
                    DoubleLeftRightArrow: '\u21D4',
                    DoubleLeftTee: '\u2AE4',
                    DoubleLongLeftArrow: '\u27F8',
                    DoubleLongLeftRightArrow: '\u27FA',
                    DoubleLongRightArrow: '\u27F9',
                    DoubleRightArrow: '\u21D2',
                    DoubleRightTee: '\u22A8',
                    DoubleUpArrow: '\u21D1',
                    DoubleUpDownArrow: '\u21D5',
                    DoubleVerticalBar: '\u2225',
                    downarrow: '\u2193',
                    Downarrow: '\u21D3',
                    DownArrow: '\u2193',
                    DownArrowBar: '\u2913',
                    DownArrowUpArrow: '\u21F5',
                    DownBreve: '\u0311',
                    downdownarrows: '\u21CA',
                    downharpoonleft: '\u21C3',
                    downharpoonright: '\u21C2',
                    DownLeftRightVector: '\u2950',
                    DownLeftTeeVector: '\u295E',
                    DownLeftVector: '\u21BD',
                    DownLeftVectorBar: '\u2956',
                    DownRightTeeVector: '\u295F',
                    DownRightVector: '\u21C1',
                    DownRightVectorBar: '\u2957',
                    DownTee: '\u22A4',
                    DownTeeArrow: '\u21A7',
                    drbkarow: '\u2910',
                    drcorn: '\u231F',
                    drcrop: '\u230C',
                    dscr: '\uD835\uDCB9',
                    Dscr: '\uD835\uDC9F',
                    dscy: '\u0455',
                    DScy: '\u0405',
                    dsol: '\u29F6',
                    dstrok: '\u0111',
                    Dstrok: '\u0110',
                    dtdot: '\u22F1',
                    dtri: '\u25BF',
                    dtrif: '\u25BE',
                    duarr: '\u21F5',
                    duhar: '\u296F',
                    dwangle: '\u29A6',
                    dzcy: '\u045F',
                    DZcy: '\u040F',
                    dzigrarr: '\u27FF',
                    eacute: '\xE9',
                    Eacute: '\xC9',
                    easter: '\u2A6E',
                    ecaron: '\u011B',
                    Ecaron: '\u011A',
                    ecir: '\u2256',
                    ecirc: '\xEA',
                    Ecirc: '\xCA',
                    ecolon: '\u2255',
                    ecy: '\u044D',
                    Ecy: '\u042D',
                    eDDot: '\u2A77',
                    edot: '\u0117',
                    eDot: '\u2251',
                    Edot: '\u0116',
                    ee: '\u2147',
                    efDot: '\u2252',
                    efr: '\uD835\uDD22',
                    Efr: '\uD835\uDD08',
                    eg: '\u2A9A',
                    egrave: '\xE8',
                    Egrave: '\xC8',
                    egs: '\u2A96',
                    egsdot: '\u2A98',
                    el: '\u2A99',
                    Element: '\u2208',
                    elinters: '\u23E7',
                    ell: '\u2113',
                    els: '\u2A95',
                    elsdot: '\u2A97',
                    emacr: '\u0113',
                    Emacr: '\u0112',
                    empty: '\u2205',
                    emptyset: '\u2205',
                    EmptySmallSquare: '\u25FB',
                    emptyv: '\u2205',
                    EmptyVerySmallSquare: '\u25AB',
                    emsp: '\u2003',
                    emsp13: '\u2004',
                    emsp14: '\u2005',
                    eng: '\u014B',
                    ENG: '\u014A',
                    ensp: '\u2002',
                    eogon: '\u0119',
                    Eogon: '\u0118',
                    eopf: '\uD835\uDD56',
                    Eopf: '\uD835\uDD3C',
                    epar: '\u22D5',
                    eparsl: '\u29E3',
                    eplus: '\u2A71',
                    epsi: '\u03B5',
                    epsilon: '\u03B5',
                    Epsilon: '\u0395',
                    epsiv: '\u03F5',
                    eqcirc: '\u2256',
                    eqcolon: '\u2255',
                    eqsim: '\u2242',
                    eqslantgtr: '\u2A96',
                    eqslantless: '\u2A95',
                    Equal: '\u2A75',
                    equals: '=',
                    EqualTilde: '\u2242',
                    equest: '\u225F',
                    Equilibrium: '\u21CC',
                    equiv: '\u2261',
                    equivDD: '\u2A78',
                    eqvparsl: '\u29E5',
                    erarr: '\u2971',
                    erDot: '\u2253',
                    escr: '\u212F',
                    Escr: '\u2130',
                    esdot: '\u2250',
                    esim: '\u2242',
                    Esim: '\u2A73',
                    eta: '\u03B7',
                    Eta: '\u0397',
                    eth: '\xF0',
                    ETH: '\xD0',
                    euml: '\xEB',
                    Euml: '\xCB',
                    euro: '\u20AC',
                    excl: '!',
                    exist: '\u2203',
                    Exists: '\u2203',
                    expectation: '\u2130',
                    exponentiale: '\u2147',
                    ExponentialE: '\u2147',
                    fallingdotseq: '\u2252',
                    fcy: '\u0444',
                    Fcy: '\u0424',
                    female: '\u2640',
                    ffilig: '\uFB03',
                    fflig: '\uFB00',
                    ffllig: '\uFB04',
                    ffr: '\uD835\uDD23',
                    Ffr: '\uD835\uDD09',
                    filig: '\uFB01',
                    FilledSmallSquare: '\u25FC',
                    FilledVerySmallSquare: '\u25AA',
                    fjlig: 'fj',
                    flat: '\u266D',
                    fllig: '\uFB02',
                    fltns: '\u25B1',
                    fnof: '\u0192',
                    fopf: '\uD835\uDD57',
                    Fopf: '\uD835\uDD3D',
                    forall: '\u2200',
                    ForAll: '\u2200',
                    fork: '\u22D4',
                    forkv: '\u2AD9',
                    Fouriertrf: '\u2131',
                    fpartint: '\u2A0D',
                    frac12: '\xBD',
                    frac13: '\u2153',
                    frac14: '\xBC',
                    frac15: '\u2155',
                    frac16: '\u2159',
                    frac18: '\u215B',
                    frac23: '\u2154',
                    frac25: '\u2156',
                    frac34: '\xBE',
                    frac35: '\u2157',
                    frac38: '\u215C',
                    frac45: '\u2158',
                    frac56: '\u215A',
                    frac58: '\u215D',
                    frac78: '\u215E',
                    frasl: '\u2044',
                    frown: '\u2322',
                    fscr: '\uD835\uDCBB',
                    Fscr: '\u2131',
                    gacute: '\u01F5',
                    gamma: '\u03B3',
                    Gamma: '\u0393',
                    gammad: '\u03DD',
                    Gammad: '\u03DC',
                    gap: '\u2A86',
                    gbreve: '\u011F',
                    Gbreve: '\u011E',
                    Gcedil: '\u0122',
                    gcirc: '\u011D',
                    Gcirc: '\u011C',
                    gcy: '\u0433',
                    Gcy: '\u0413',
                    gdot: '\u0121',
                    Gdot: '\u0120',
                    ge: '\u2265',
                    gE: '\u2267',
                    gel: '\u22DB',
                    gEl: '\u2A8C',
                    geq: '\u2265',
                    geqq: '\u2267',
                    geqslant: '\u2A7E',
                    ges: '\u2A7E',
                    gescc: '\u2AA9',
                    gesdot: '\u2A80',
                    gesdoto: '\u2A82',
                    gesdotol: '\u2A84',
                    gesl: '\u22DB\uFE00',
                    gesles: '\u2A94',
                    gfr: '\uD835\uDD24',
                    Gfr: '\uD835\uDD0A',
                    gg: '\u226B',
                    Gg: '\u22D9',
                    ggg: '\u22D9',
                    gimel: '\u2137',
                    gjcy: '\u0453',
                    GJcy: '\u0403',
                    gl: '\u2277',
                    gla: '\u2AA5',
                    glE: '\u2A92',
                    glj: '\u2AA4',
                    gnap: '\u2A8A',
                    gnapprox: '\u2A8A',
                    gne: '\u2A88',
                    gnE: '\u2269',
                    gneq: '\u2A88',
                    gneqq: '\u2269',
                    gnsim: '\u22E7',
                    gopf: '\uD835\uDD58',
                    Gopf: '\uD835\uDD3E',
                    grave: '`',
                    GreaterEqual: '\u2265',
                    GreaterEqualLess: '\u22DB',
                    GreaterFullEqual: '\u2267',
                    GreaterGreater: '\u2AA2',
                    GreaterLess: '\u2277',
                    GreaterSlantEqual: '\u2A7E',
                    GreaterTilde: '\u2273',
                    gscr: '\u210A',
                    Gscr: '\uD835\uDCA2',
                    gsim: '\u2273',
                    gsime: '\u2A8E',
                    gsiml: '\u2A90',
                    gt: '>',
                    Gt: '\u226B',
                    GT: '>',
                    gtcc: '\u2AA7',
                    gtcir: '\u2A7A',
                    gtdot: '\u22D7',
                    gtlPar: '\u2995',
                    gtquest: '\u2A7C',
                    gtrapprox: '\u2A86',
                    gtrarr: '\u2978',
                    gtrdot: '\u22D7',
                    gtreqless: '\u22DB',
                    gtreqqless: '\u2A8C',
                    gtrless: '\u2277',
                    gtrsim: '\u2273',
                    gvertneqq: '\u2269\uFE00',
                    gvnE: '\u2269\uFE00',
                    Hacek: '\u02C7',
                    hairsp: '\u200A',
                    half: '\xBD',
                    hamilt: '\u210B',
                    hardcy: '\u044A',
                    HARDcy: '\u042A',
                    harr: '\u2194',
                    hArr: '\u21D4',
                    harrcir: '\u2948',
                    harrw: '\u21AD',
                    Hat: '^',
                    hbar: '\u210F',
                    hcirc: '\u0125',
                    Hcirc: '\u0124',
                    hearts: '\u2665',
                    heartsuit: '\u2665',
                    hellip: '\u2026',
                    hercon: '\u22B9',
                    hfr: '\uD835\uDD25',
                    Hfr: '\u210C',
                    HilbertSpace: '\u210B',
                    hksearow: '\u2925',
                    hkswarow: '\u2926',
                    hoarr: '\u21FF',
                    homtht: '\u223B',
                    hookleftarrow: '\u21A9',
                    hookrightarrow: '\u21AA',
                    hopf: '\uD835\uDD59',
                    Hopf: '\u210D',
                    horbar: '\u2015',
                    HorizontalLine: '\u2500',
                    hscr: '\uD835\uDCBD',
                    Hscr: '\u210B',
                    hslash: '\u210F',
                    hstrok: '\u0127',
                    Hstrok: '\u0126',
                    HumpDownHump: '\u224E',
                    HumpEqual: '\u224F',
                    hybull: '\u2043',
                    hyphen: '\u2010',
                    iacute: '\xED',
                    Iacute: '\xCD',
                    ic: '\u2063',
                    icirc: '\xEE',
                    Icirc: '\xCE',
                    icy: '\u0438',
                    Icy: '\u0418',
                    Idot: '\u0130',
                    iecy: '\u0435',
                    IEcy: '\u0415',
                    iexcl: '\xA1',
                    iff: '\u21D4',
                    ifr: '\uD835\uDD26',
                    Ifr: '\u2111',
                    igrave: '\xEC',
                    Igrave: '\xCC',
                    ii: '\u2148',
                    iiiint: '\u2A0C',
                    iiint: '\u222D',
                    iinfin: '\u29DC',
                    iiota: '\u2129',
                    ijlig: '\u0133',
                    IJlig: '\u0132',
                    Im: '\u2111',
                    imacr: '\u012B',
                    Imacr: '\u012A',
                    image: '\u2111',
                    ImaginaryI: '\u2148',
                    imagline: '\u2110',
                    imagpart: '\u2111',
                    imath: '\u0131',
                    imof: '\u22B7',
                    imped: '\u01B5',
                    Implies: '\u21D2',
                    in: '\u2208',
                    incare: '\u2105',
                    infin: '\u221E',
                    infintie: '\u29DD',
                    inodot: '\u0131',
                    int: '\u222B',
                    Int: '\u222C',
                    intcal: '\u22BA',
                    integers: '\u2124',
                    Integral: '\u222B',
                    intercal: '\u22BA',
                    Intersection: '\u22C2',
                    intlarhk: '\u2A17',
                    intprod: '\u2A3C',
                    InvisibleComma: '\u2063',
                    InvisibleTimes: '\u2062',
                    iocy: '\u0451',
                    IOcy: '\u0401',
                    iogon: '\u012F',
                    Iogon: '\u012E',
                    iopf: '\uD835\uDD5A',
                    Iopf: '\uD835\uDD40',
                    iota: '\u03B9',
                    Iota: '\u0399',
                    iprod: '\u2A3C',
                    iquest: '\xBF',
                    iscr: '\uD835\uDCBE',
                    Iscr: '\u2110',
                    isin: '\u2208',
                    isindot: '\u22F5',
                    isinE: '\u22F9',
                    isins: '\u22F4',
                    isinsv: '\u22F3',
                    isinv: '\u2208',
                    it: '\u2062',
                    itilde: '\u0129',
                    Itilde: '\u0128',
                    iukcy: '\u0456',
                    Iukcy: '\u0406',
                    iuml: '\xEF',
                    Iuml: '\xCF',
                    jcirc: '\u0135',
                    Jcirc: '\u0134',
                    jcy: '\u0439',
                    Jcy: '\u0419',
                    jfr: '\uD835\uDD27',
                    Jfr: '\uD835\uDD0D',
                    jmath: '\u0237',
                    jopf: '\uD835\uDD5B',
                    Jopf: '\uD835\uDD41',
                    jscr: '\uD835\uDCBF',
                    Jscr: '\uD835\uDCA5',
                    jsercy: '\u0458',
                    Jsercy: '\u0408',
                    jukcy: '\u0454',
                    Jukcy: '\u0404',
                    kappa: '\u03BA',
                    Kappa: '\u039A',
                    kappav: '\u03F0',
                    kcedil: '\u0137',
                    Kcedil: '\u0136',
                    kcy: '\u043A',
                    Kcy: '\u041A',
                    kfr: '\uD835\uDD28',
                    Kfr: '\uD835\uDD0E',
                    kgreen: '\u0138',
                    khcy: '\u0445',
                    KHcy: '\u0425',
                    kjcy: '\u045C',
                    KJcy: '\u040C',
                    kopf: '\uD835\uDD5C',
                    Kopf: '\uD835\uDD42',
                    kscr: '\uD835\uDCC0',
                    Kscr: '\uD835\uDCA6',
                    lAarr: '\u21DA',
                    lacute: '\u013A',
                    Lacute: '\u0139',
                    laemptyv: '\u29B4',
                    lagran: '\u2112',
                    lambda: '\u03BB',
                    Lambda: '\u039B',
                    lang: '\u27E8',
                    Lang: '\u27EA',
                    langd: '\u2991',
                    langle: '\u27E8',
                    lap: '\u2A85',
                    Laplacetrf: '\u2112',
                    laquo: '\xAB',
                    larr: '\u2190',
                    lArr: '\u21D0',
                    Larr: '\u219E',
                    larrb: '\u21E4',
                    larrbfs: '\u291F',
                    larrfs: '\u291D',
                    larrhk: '\u21A9',
                    larrlp: '\u21AB',
                    larrpl: '\u2939',
                    larrsim: '\u2973',
                    larrtl: '\u21A2',
                    lat: '\u2AAB',
                    latail: '\u2919',
                    lAtail: '\u291B',
                    late: '\u2AAD',
                    lates: '\u2AAD\uFE00',
                    lbarr: '\u290C',
                    lBarr: '\u290E',
                    lbbrk: '\u2772',
                    lbrace: '{',
                    lbrack: '[',
                    lbrke: '\u298B',
                    lbrksld: '\u298F',
                    lbrkslu: '\u298D',
                    lcaron: '\u013E',
                    Lcaron: '\u013D',
                    lcedil: '\u013C',
                    Lcedil: '\u013B',
                    lceil: '\u2308',
                    lcub: '{',
                    lcy: '\u043B',
                    Lcy: '\u041B',
                    ldca: '\u2936',
                    ldquo: '\u201C',
                    ldquor: '\u201E',
                    ldrdhar: '\u2967',
                    ldrushar: '\u294B',
                    ldsh: '\u21B2',
                    le: '\u2264',
                    lE: '\u2266',
                    LeftAngleBracket: '\u27E8',
                    leftarrow: '\u2190',
                    Leftarrow: '\u21D0',
                    LeftArrow: '\u2190',
                    LeftArrowBar: '\u21E4',
                    LeftArrowRightArrow: '\u21C6',
                    leftarrowtail: '\u21A2',
                    LeftCeiling: '\u2308',
                    LeftDoubleBracket: '\u27E6',
                    LeftDownTeeVector: '\u2961',
                    LeftDownVector: '\u21C3',
                    LeftDownVectorBar: '\u2959',
                    LeftFloor: '\u230A',
                    leftharpoondown: '\u21BD',
                    leftharpoonup: '\u21BC',
                    leftleftarrows: '\u21C7',
                    leftrightarrow: '\u2194',
                    Leftrightarrow: '\u21D4',
                    LeftRightArrow: '\u2194',
                    leftrightarrows: '\u21C6',
                    leftrightharpoons: '\u21CB',
                    leftrightsquigarrow: '\u21AD',
                    LeftRightVector: '\u294E',
                    LeftTee: '\u22A3',
                    LeftTeeArrow: '\u21A4',
                    LeftTeeVector: '\u295A',
                    leftthreetimes: '\u22CB',
                    LeftTriangle: '\u22B2',
                    LeftTriangleBar: '\u29CF',
                    LeftTriangleEqual: '\u22B4',
                    LeftUpDownVector: '\u2951',
                    LeftUpTeeVector: '\u2960',
                    LeftUpVector: '\u21BF',
                    LeftUpVectorBar: '\u2958',
                    LeftVector: '\u21BC',
                    LeftVectorBar: '\u2952',
                    leg: '\u22DA',
                    lEg: '\u2A8B',
                    leq: '\u2264',
                    leqq: '\u2266',
                    leqslant: '\u2A7D',
                    les: '\u2A7D',
                    lescc: '\u2AA8',
                    lesdot: '\u2A7F',
                    lesdoto: '\u2A81',
                    lesdotor: '\u2A83',
                    lesg: '\u22DA\uFE00',
                    lesges: '\u2A93',
                    lessapprox: '\u2A85',
                    lessdot: '\u22D6',
                    lesseqgtr: '\u22DA',
                    lesseqqgtr: '\u2A8B',
                    LessEqualGreater: '\u22DA',
                    LessFullEqual: '\u2266',
                    LessGreater: '\u2276',
                    lessgtr: '\u2276',
                    LessLess: '\u2AA1',
                    lesssim: '\u2272',
                    LessSlantEqual: '\u2A7D',
                    LessTilde: '\u2272',
                    lfisht: '\u297C',
                    lfloor: '\u230A',
                    lfr: '\uD835\uDD29',
                    Lfr: '\uD835\uDD0F',
                    lg: '\u2276',
                    lgE: '\u2A91',
                    lHar: '\u2962',
                    lhard: '\u21BD',
                    lharu: '\u21BC',
                    lharul: '\u296A',
                    lhblk: '\u2584',
                    ljcy: '\u0459',
                    LJcy: '\u0409',
                    ll: '\u226A',
                    Ll: '\u22D8',
                    llarr: '\u21C7',
                    llcorner: '\u231E',
                    Lleftarrow: '\u21DA',
                    llhard: '\u296B',
                    lltri: '\u25FA',
                    lmidot: '\u0140',
                    Lmidot: '\u013F',
                    lmoust: '\u23B0',
                    lmoustache: '\u23B0',
                    lnap: '\u2A89',
                    lnapprox: '\u2A89',
                    lne: '\u2A87',
                    lnE: '\u2268',
                    lneq: '\u2A87',
                    lneqq: '\u2268',
                    lnsim: '\u22E6',
                    loang: '\u27EC',
                    loarr: '\u21FD',
                    lobrk: '\u27E6',
                    longleftarrow: '\u27F5',
                    Longleftarrow: '\u27F8',
                    LongLeftArrow: '\u27F5',
                    longleftrightarrow: '\u27F7',
                    Longleftrightarrow: '\u27FA',
                    LongLeftRightArrow: '\u27F7',
                    longmapsto: '\u27FC',
                    longrightarrow: '\u27F6',
                    Longrightarrow: '\u27F9',
                    LongRightArrow: '\u27F6',
                    looparrowleft: '\u21AB',
                    looparrowright: '\u21AC',
                    lopar: '\u2985',
                    lopf: '\uD835\uDD5D',
                    Lopf: '\uD835\uDD43',
                    loplus: '\u2A2D',
                    lotimes: '\u2A34',
                    lowast: '\u2217',
                    lowbar: '_',
                    LowerLeftArrow: '\u2199',
                    LowerRightArrow: '\u2198',
                    loz: '\u25CA',
                    lozenge: '\u25CA',
                    lozf: '\u29EB',
                    lpar: '(',
                    lparlt: '\u2993',
                    lrarr: '\u21C6',
                    lrcorner: '\u231F',
                    lrhar: '\u21CB',
                    lrhard: '\u296D',
                    lrm: '\u200E',
                    lrtri: '\u22BF',
                    lsaquo: '\u2039',
                    lscr: '\uD835\uDCC1',
                    Lscr: '\u2112',
                    lsh: '\u21B0',
                    Lsh: '\u21B0',
                    lsim: '\u2272',
                    lsime: '\u2A8D',
                    lsimg: '\u2A8F',
                    lsqb: '[',
                    lsquo: '\u2018',
                    lsquor: '\u201A',
                    lstrok: '\u0142',
                    Lstrok: '\u0141',
                    lt: '<',
                    Lt: '\u226A',
                    LT: '<',
                    ltcc: '\u2AA6',
                    ltcir: '\u2A79',
                    ltdot: '\u22D6',
                    lthree: '\u22CB',
                    ltimes: '\u22C9',
                    ltlarr: '\u2976',
                    ltquest: '\u2A7B',
                    ltri: '\u25C3',
                    ltrie: '\u22B4',
                    ltrif: '\u25C2',
                    ltrPar: '\u2996',
                    lurdshar: '\u294A',
                    luruhar: '\u2966',
                    lvertneqq: '\u2268\uFE00',
                    lvnE: '\u2268\uFE00',
                    macr: '\xAF',
                    male: '\u2642',
                    malt: '\u2720',
                    maltese: '\u2720',
                    map: '\u21A6',
                    Map: '\u2905',
                    mapsto: '\u21A6',
                    mapstodown: '\u21A7',
                    mapstoleft: '\u21A4',
                    mapstoup: '\u21A5',
                    marker: '\u25AE',
                    mcomma: '\u2A29',
                    mcy: '\u043C',
                    Mcy: '\u041C',
                    mdash: '\u2014',
                    mDDot: '\u223A',
                    measuredangle: '\u2221',
                    MediumSpace: '\u205F',
                    Mellintrf: '\u2133',
                    mfr: '\uD835\uDD2A',
                    Mfr: '\uD835\uDD10',
                    mho: '\u2127',
                    micro: '\xB5',
                    mid: '\u2223',
                    midast: '*',
                    midcir: '\u2AF0',
                    middot: '\xB7',
                    minus: '\u2212',
                    minusb: '\u229F',
                    minusd: '\u2238',
                    minusdu: '\u2A2A',
                    MinusPlus: '\u2213',
                    mlcp: '\u2ADB',
                    mldr: '\u2026',
                    mnplus: '\u2213',
                    models: '\u22A7',
                    mopf: '\uD835\uDD5E',
                    Mopf: '\uD835\uDD44',
                    mp: '\u2213',
                    mscr: '\uD835\uDCC2',
                    Mscr: '\u2133',
                    mstpos: '\u223E',
                    mu: '\u03BC',
                    Mu: '\u039C',
                    multimap: '\u22B8',
                    mumap: '\u22B8',
                    nabla: '\u2207',
                    nacute: '\u0144',
                    Nacute: '\u0143',
                    nang: '\u2220\u20D2',
                    nap: '\u2249',
                    napE: '\u2A70\u0338',
                    napid: '\u224B\u0338',
                    napos: '\u0149',
                    napprox: '\u2249',
                    natur: '\u266E',
                    natural: '\u266E',
                    naturals: '\u2115',
                    nbsp: '\xA0',
                    nbump: '\u224E\u0338',
                    nbumpe: '\u224F\u0338',
                    ncap: '\u2A43',
                    ncaron: '\u0148',
                    Ncaron: '\u0147',
                    ncedil: '\u0146',
                    Ncedil: '\u0145',
                    ncong: '\u2247',
                    ncongdot: '\u2A6D\u0338',
                    ncup: '\u2A42',
                    ncy: '\u043D',
                    Ncy: '\u041D',
                    ndash: '\u2013',
                    ne: '\u2260',
                    nearhk: '\u2924',
                    nearr: '\u2197',
                    neArr: '\u21D7',
                    nearrow: '\u2197',
                    nedot: '\u2250\u0338',
                    NegativeMediumSpace: '\u200B',
                    NegativeThickSpace: '\u200B',
                    NegativeThinSpace: '\u200B',
                    NegativeVeryThinSpace: '\u200B',
                    nequiv: '\u2262',
                    nesear: '\u2928',
                    nesim: '\u2242\u0338',
                    NestedGreaterGreater: '\u226B',
                    NestedLessLess: '\u226A',
                    NewLine: '\n',
                    nexist: '\u2204',
                    nexists: '\u2204',
                    nfr: '\uD835\uDD2B',
                    Nfr: '\uD835\uDD11',
                    nge: '\u2271',
                    ngE: '\u2267\u0338',
                    ngeq: '\u2271',
                    ngeqq: '\u2267\u0338',
                    ngeqslant: '\u2A7E\u0338',
                    nges: '\u2A7E\u0338',
                    nGg: '\u22D9\u0338',
                    ngsim: '\u2275',
                    ngt: '\u226F',
                    nGt: '\u226B\u20D2',
                    ngtr: '\u226F',
                    nGtv: '\u226B\u0338',
                    nharr: '\u21AE',
                    nhArr: '\u21CE',
                    nhpar: '\u2AF2',
                    ni: '\u220B',
                    nis: '\u22FC',
                    nisd: '\u22FA',
                    niv: '\u220B',
                    njcy: '\u045A',
                    NJcy: '\u040A',
                    nlarr: '\u219A',
                    nlArr: '\u21CD',
                    nldr: '\u2025',
                    nle: '\u2270',
                    nlE: '\u2266\u0338',
                    nleftarrow: '\u219A',
                    nLeftarrow: '\u21CD',
                    nleftrightarrow: '\u21AE',
                    nLeftrightarrow: '\u21CE',
                    nleq: '\u2270',
                    nleqq: '\u2266\u0338',
                    nleqslant: '\u2A7D\u0338',
                    nles: '\u2A7D\u0338',
                    nless: '\u226E',
                    nLl: '\u22D8\u0338',
                    nlsim: '\u2274',
                    nlt: '\u226E',
                    nLt: '\u226A\u20D2',
                    nltri: '\u22EA',
                    nltrie: '\u22EC',
                    nLtv: '\u226A\u0338',
                    nmid: '\u2224',
                    NoBreak: '\u2060',
                    NonBreakingSpace: '\xA0',
                    nopf: '\uD835\uDD5F',
                    Nopf: '\u2115',
                    not: '\xAC',
                    Not: '\u2AEC',
                    NotCongruent: '\u2262',
                    NotCupCap: '\u226D',
                    NotDoubleVerticalBar: '\u2226',
                    NotElement: '\u2209',
                    NotEqual: '\u2260',
                    NotEqualTilde: '\u2242\u0338',
                    NotExists: '\u2204',
                    NotGreater: '\u226F',
                    NotGreaterEqual: '\u2271',
                    NotGreaterFullEqual: '\u2267\u0338',
                    NotGreaterGreater: '\u226B\u0338',
                    NotGreaterLess: '\u2279',
                    NotGreaterSlantEqual: '\u2A7E\u0338',
                    NotGreaterTilde: '\u2275',
                    NotHumpDownHump: '\u224E\u0338',
                    NotHumpEqual: '\u224F\u0338',
                    notin: '\u2209',
                    notindot: '\u22F5\u0338',
                    notinE: '\u22F9\u0338',
                    notinva: '\u2209',
                    notinvb: '\u22F7',
                    notinvc: '\u22F6',
                    NotLeftTriangle: '\u22EA',
                    NotLeftTriangleBar: '\u29CF\u0338',
                    NotLeftTriangleEqual: '\u22EC',
                    NotLess: '\u226E',
                    NotLessEqual: '\u2270',
                    NotLessGreater: '\u2278',
                    NotLessLess: '\u226A\u0338',
                    NotLessSlantEqual: '\u2A7D\u0338',
                    NotLessTilde: '\u2274',
                    NotNestedGreaterGreater: '\u2AA2\u0338',
                    NotNestedLessLess: '\u2AA1\u0338',
                    notni: '\u220C',
                    notniva: '\u220C',
                    notnivb: '\u22FE',
                    notnivc: '\u22FD',
                    NotPrecedes: '\u2280',
                    NotPrecedesEqual: '\u2AAF\u0338',
                    NotPrecedesSlantEqual: '\u22E0',
                    NotReverseElement: '\u220C',
                    NotRightTriangle: '\u22EB',
                    NotRightTriangleBar: '\u29D0\u0338',
                    NotRightTriangleEqual: '\u22ED',
                    NotSquareSubset: '\u228F\u0338',
                    NotSquareSubsetEqual: '\u22E2',
                    NotSquareSuperset: '\u2290\u0338',
                    NotSquareSupersetEqual: '\u22E3',
                    NotSubset: '\u2282\u20D2',
                    NotSubsetEqual: '\u2288',
                    NotSucceeds: '\u2281',
                    NotSucceedsEqual: '\u2AB0\u0338',
                    NotSucceedsSlantEqual: '\u22E1',
                    NotSucceedsTilde: '\u227F\u0338',
                    NotSuperset: '\u2283\u20D2',
                    NotSupersetEqual: '\u2289',
                    NotTilde: '\u2241',
                    NotTildeEqual: '\u2244',
                    NotTildeFullEqual: '\u2247',
                    NotTildeTilde: '\u2249',
                    NotVerticalBar: '\u2224',
                    npar: '\u2226',
                    nparallel: '\u2226',
                    nparsl: '\u2AFD\u20E5',
                    npart: '\u2202\u0338',
                    npolint: '\u2A14',
                    npr: '\u2280',
                    nprcue: '\u22E0',
                    npre: '\u2AAF\u0338',
                    nprec: '\u2280',
                    npreceq: '\u2AAF\u0338',
                    nrarr: '\u219B',
                    nrArr: '\u21CF',
                    nrarrc: '\u2933\u0338',
                    nrarrw: '\u219D\u0338',
                    nrightarrow: '\u219B',
                    nRightarrow: '\u21CF',
                    nrtri: '\u22EB',
                    nrtrie: '\u22ED',
                    nsc: '\u2281',
                    nsccue: '\u22E1',
                    nsce: '\u2AB0\u0338',
                    nscr: '\uD835\uDCC3',
                    Nscr: '\uD835\uDCA9',
                    nshortmid: '\u2224',
                    nshortparallel: '\u2226',
                    nsim: '\u2241',
                    nsime: '\u2244',
                    nsimeq: '\u2244',
                    nsmid: '\u2224',
                    nspar: '\u2226',
                    nsqsube: '\u22E2',
                    nsqsupe: '\u22E3',
                    nsub: '\u2284',
                    nsube: '\u2288',
                    nsubE: '\u2AC5\u0338',
                    nsubset: '\u2282\u20D2',
                    nsubseteq: '\u2288',
                    nsubseteqq: '\u2AC5\u0338',
                    nsucc: '\u2281',
                    nsucceq: '\u2AB0\u0338',
                    nsup: '\u2285',
                    nsupe: '\u2289',
                    nsupE: '\u2AC6\u0338',
                    nsupset: '\u2283\u20D2',
                    nsupseteq: '\u2289',
                    nsupseteqq: '\u2AC6\u0338',
                    ntgl: '\u2279',
                    ntilde: '\xF1',
                    Ntilde: '\xD1',
                    ntlg: '\u2278',
                    ntriangleleft: '\u22EA',
                    ntrianglelefteq: '\u22EC',
                    ntriangleright: '\u22EB',
                    ntrianglerighteq: '\u22ED',
                    nu: '\u03BD',
                    Nu: '\u039D',
                    num: '#',
                    numero: '\u2116',
                    numsp: '\u2007',
                    nvap: '\u224D\u20D2',
                    nvdash: '\u22AC',
                    nvDash: '\u22AD',
                    nVdash: '\u22AE',
                    nVDash: '\u22AF',
                    nvge: '\u2265\u20D2',
                    nvgt: '>\u20D2',
                    nvHarr: '\u2904',
                    nvinfin: '\u29DE',
                    nvlArr: '\u2902',
                    nvle: '\u2264\u20D2',
                    nvlt: '<\u20D2',
                    nvltrie: '\u22B4\u20D2',
                    nvrArr: '\u2903',
                    nvrtrie: '\u22B5\u20D2',
                    nvsim: '\u223C\u20D2',
                    nwarhk: '\u2923',
                    nwarr: '\u2196',
                    nwArr: '\u21D6',
                    nwarrow: '\u2196',
                    nwnear: '\u2927',
                    oacute: '\xF3',
                    Oacute: '\xD3',
                    oast: '\u229B',
                    ocir: '\u229A',
                    ocirc: '\xF4',
                    Ocirc: '\xD4',
                    ocy: '\u043E',
                    Ocy: '\u041E',
                    odash: '\u229D',
                    odblac: '\u0151',
                    Odblac: '\u0150',
                    odiv: '\u2A38',
                    odot: '\u2299',
                    odsold: '\u29BC',
                    oelig: '\u0153',
                    OElig: '\u0152',
                    ofcir: '\u29BF',
                    ofr: '\uD835\uDD2C',
                    Ofr: '\uD835\uDD12',
                    ogon: '\u02DB',
                    ograve: '\xF2',
                    Ograve: '\xD2',
                    ogt: '\u29C1',
                    ohbar: '\u29B5',
                    ohm: '\u03A9',
                    oint: '\u222E',
                    olarr: '\u21BA',
                    olcir: '\u29BE',
                    olcross: '\u29BB',
                    oline: '\u203E',
                    olt: '\u29C0',
                    omacr: '\u014D',
                    Omacr: '\u014C',
                    omega: '\u03C9',
                    Omega: '\u03A9',
                    omicron: '\u03BF',
                    Omicron: '\u039F',
                    omid: '\u29B6',
                    ominus: '\u2296',
                    oopf: '\uD835\uDD60',
                    Oopf: '\uD835\uDD46',
                    opar: '\u29B7',
                    OpenCurlyDoubleQuote: '\u201C',
                    OpenCurlyQuote: '\u2018',
                    operp: '\u29B9',
                    oplus: '\u2295',
                    or: '\u2228',
                    Or: '\u2A54',
                    orarr: '\u21BB',
                    ord: '\u2A5D',
                    order: '\u2134',
                    orderof: '\u2134',
                    ordf: '\xAA',
                    ordm: '\xBA',
                    origof: '\u22B6',
                    oror: '\u2A56',
                    orslope: '\u2A57',
                    orv: '\u2A5B',
                    oS: '\u24C8',
                    oscr: '\u2134',
                    Oscr: '\uD835\uDCAA',
                    oslash: '\xF8',
                    Oslash: '\xD8',
                    osol: '\u2298',
                    otilde: '\xF5',
                    Otilde: '\xD5',
                    otimes: '\u2297',
                    Otimes: '\u2A37',
                    otimesas: '\u2A36',
                    ouml: '\xF6',
                    Ouml: '\xD6',
                    ovbar: '\u233D',
                    OverBar: '\u203E',
                    OverBrace: '\u23DE',
                    OverBracket: '\u23B4',
                    OverParenthesis: '\u23DC',
                    par: '\u2225',
                    para: '\xB6',
                    parallel: '\u2225',
                    parsim: '\u2AF3',
                    parsl: '\u2AFD',
                    part: '\u2202',
                    PartialD: '\u2202',
                    pcy: '\u043F',
                    Pcy: '\u041F',
                    percnt: '%',
                    period: '.',
                    permil: '\u2030',
                    perp: '\u22A5',
                    pertenk: '\u2031',
                    pfr: '\uD835\uDD2D',
                    Pfr: '\uD835\uDD13',
                    phi: '\u03C6',
                    Phi: '\u03A6',
                    phiv: '\u03D5',
                    phmmat: '\u2133',
                    phone: '\u260E',
                    pi: '\u03C0',
                    Pi: '\u03A0',
                    pitchfork: '\u22D4',
                    piv: '\u03D6',
                    planck: '\u210F',
                    planckh: '\u210E',
                    plankv: '\u210F',
                    plus: '+',
                    plusacir: '\u2A23',
                    plusb: '\u229E',
                    pluscir: '\u2A22',
                    plusdo: '\u2214',
                    plusdu: '\u2A25',
                    pluse: '\u2A72',
                    PlusMinus: '\xB1',
                    plusmn: '\xB1',
                    plussim: '\u2A26',
                    plustwo: '\u2A27',
                    pm: '\xB1',
                    Poincareplane: '\u210C',
                    pointint: '\u2A15',
                    popf: '\uD835\uDD61',
                    Popf: '\u2119',
                    pound: '\xA3',
                    pr: '\u227A',
                    Pr: '\u2ABB',
                    prap: '\u2AB7',
                    prcue: '\u227C',
                    pre: '\u2AAF',
                    prE: '\u2AB3',
                    prec: '\u227A',
                    precapprox: '\u2AB7',
                    preccurlyeq: '\u227C',
                    Precedes: '\u227A',
                    PrecedesEqual: '\u2AAF',
                    PrecedesSlantEqual: '\u227C',
                    PrecedesTilde: '\u227E',
                    preceq: '\u2AAF',
                    precnapprox: '\u2AB9',
                    precneqq: '\u2AB5',
                    precnsim: '\u22E8',
                    precsim: '\u227E',
                    prime: '\u2032',
                    Prime: '\u2033',
                    primes: '\u2119',
                    prnap: '\u2AB9',
                    prnE: '\u2AB5',
                    prnsim: '\u22E8',
                    prod: '\u220F',
                    Product: '\u220F',
                    profalar: '\u232E',
                    profline: '\u2312',
                    profsurf: '\u2313',
                    prop: '\u221D',
                    Proportion: '\u2237',
                    Proportional: '\u221D',
                    propto: '\u221D',
                    prsim: '\u227E',
                    prurel: '\u22B0',
                    pscr: '\uD835\uDCC5',
                    Pscr: '\uD835\uDCAB',
                    psi: '\u03C8',
                    Psi: '\u03A8',
                    puncsp: '\u2008',
                    qfr: '\uD835\uDD2E',
                    Qfr: '\uD835\uDD14',
                    qint: '\u2A0C',
                    qopf: '\uD835\uDD62',
                    Qopf: '\u211A',
                    qprime: '\u2057',
                    qscr: '\uD835\uDCC6',
                    Qscr: '\uD835\uDCAC',
                    quaternions: '\u210D',
                    quatint: '\u2A16',
                    quest: '?',
                    questeq: '\u225F',
                    quot: '"',
                    QUOT: '"',
                    rAarr: '\u21DB',
                    race: '\u223D\u0331',
                    racute: '\u0155',
                    Racute: '\u0154',
                    radic: '\u221A',
                    raemptyv: '\u29B3',
                    rang: '\u27E9',
                    Rang: '\u27EB',
                    rangd: '\u2992',
                    range: '\u29A5',
                    rangle: '\u27E9',
                    raquo: '\xBB',
                    rarr: '\u2192',
                    rArr: '\u21D2',
                    Rarr: '\u21A0',
                    rarrap: '\u2975',
                    rarrb: '\u21E5',
                    rarrbfs: '\u2920',
                    rarrc: '\u2933',
                    rarrfs: '\u291E',
                    rarrhk: '\u21AA',
                    rarrlp: '\u21AC',
                    rarrpl: '\u2945',
                    rarrsim: '\u2974',
                    rarrtl: '\u21A3',
                    Rarrtl: '\u2916',
                    rarrw: '\u219D',
                    ratail: '\u291A',
                    rAtail: '\u291C',
                    ratio: '\u2236',
                    rationals: '\u211A',
                    rbarr: '\u290D',
                    rBarr: '\u290F',
                    RBarr: '\u2910',
                    rbbrk: '\u2773',
                    rbrace: '}',
                    rbrack: ']',
                    rbrke: '\u298C',
                    rbrksld: '\u298E',
                    rbrkslu: '\u2990',
                    rcaron: '\u0159',
                    Rcaron: '\u0158',
                    rcedil: '\u0157',
                    Rcedil: '\u0156',
                    rceil: '\u2309',
                    rcub: '}',
                    rcy: '\u0440',
                    Rcy: '\u0420',
                    rdca: '\u2937',
                    rdldhar: '\u2969',
                    rdquo: '\u201D',
                    rdquor: '\u201D',
                    rdsh: '\u21B3',
                    Re: '\u211C',
                    real: '\u211C',
                    realine: '\u211B',
                    realpart: '\u211C',
                    reals: '\u211D',
                    rect: '\u25AD',
                    reg: '\xAE',
                    REG: '\xAE',
                    ReverseElement: '\u220B',
                    ReverseEquilibrium: '\u21CB',
                    ReverseUpEquilibrium: '\u296F',
                    rfisht: '\u297D',
                    rfloor: '\u230B',
                    rfr: '\uD835\uDD2F',
                    Rfr: '\u211C',
                    rHar: '\u2964',
                    rhard: '\u21C1',
                    rharu: '\u21C0',
                    rharul: '\u296C',
                    rho: '\u03C1',
                    Rho: '\u03A1',
                    rhov: '\u03F1',
                    RightAngleBracket: '\u27E9',
                    rightarrow: '\u2192',
                    Rightarrow: '\u21D2',
                    RightArrow: '\u2192',
                    RightArrowBar: '\u21E5',
                    RightArrowLeftArrow: '\u21C4',
                    rightarrowtail: '\u21A3',
                    RightCeiling: '\u2309',
                    RightDoubleBracket: '\u27E7',
                    RightDownTeeVector: '\u295D',
                    RightDownVector: '\u21C2',
                    RightDownVectorBar: '\u2955',
                    RightFloor: '\u230B',
                    rightharpoondown: '\u21C1',
                    rightharpoonup: '\u21C0',
                    rightleftarrows: '\u21C4',
                    rightleftharpoons: '\u21CC',
                    rightrightarrows: '\u21C9',
                    rightsquigarrow: '\u219D',
                    RightTee: '\u22A2',
                    RightTeeArrow: '\u21A6',
                    RightTeeVector: '\u295B',
                    rightthreetimes: '\u22CC',
                    RightTriangle: '\u22B3',
                    RightTriangleBar: '\u29D0',
                    RightTriangleEqual: '\u22B5',
                    RightUpDownVector: '\u294F',
                    RightUpTeeVector: '\u295C',
                    RightUpVector: '\u21BE',
                    RightUpVectorBar: '\u2954',
                    RightVector: '\u21C0',
                    RightVectorBar: '\u2953',
                    ring: '\u02DA',
                    risingdotseq: '\u2253',
                    rlarr: '\u21C4',
                    rlhar: '\u21CC',
                    rlm: '\u200F',
                    rmoust: '\u23B1',
                    rmoustache: '\u23B1',
                    rnmid: '\u2AEE',
                    roang: '\u27ED',
                    roarr: '\u21FE',
                    robrk: '\u27E7',
                    ropar: '\u2986',
                    ropf: '\uD835\uDD63',
                    Ropf: '\u211D',
                    roplus: '\u2A2E',
                    rotimes: '\u2A35',
                    RoundImplies: '\u2970',
                    rpar: ')',
                    rpargt: '\u2994',
                    rppolint: '\u2A12',
                    rrarr: '\u21C9',
                    Rrightarrow: '\u21DB',
                    rsaquo: '\u203A',
                    rscr: '\uD835\uDCC7',
                    Rscr: '\u211B',
                    rsh: '\u21B1',
                    Rsh: '\u21B1',
                    rsqb: ']',
                    rsquo: '\u2019',
                    rsquor: '\u2019',
                    rthree: '\u22CC',
                    rtimes: '\u22CA',
                    rtri: '\u25B9',
                    rtrie: '\u22B5',
                    rtrif: '\u25B8',
                    rtriltri: '\u29CE',
                    RuleDelayed: '\u29F4',
                    ruluhar: '\u2968',
                    rx: '\u211E',
                    sacute: '\u015B',
                    Sacute: '\u015A',
                    sbquo: '\u201A',
                    sc: '\u227B',
                    Sc: '\u2ABC',
                    scap: '\u2AB8',
                    scaron: '\u0161',
                    Scaron: '\u0160',
                    sccue: '\u227D',
                    sce: '\u2AB0',
                    scE: '\u2AB4',
                    scedil: '\u015F',
                    Scedil: '\u015E',
                    scirc: '\u015D',
                    Scirc: '\u015C',
                    scnap: '\u2ABA',
                    scnE: '\u2AB6',
                    scnsim: '\u22E9',
                    scpolint: '\u2A13',
                    scsim: '\u227F',
                    scy: '\u0441',
                    Scy: '\u0421',
                    sdot: '\u22C5',
                    sdotb: '\u22A1',
                    sdote: '\u2A66',
                    searhk: '\u2925',
                    searr: '\u2198',
                    seArr: '\u21D8',
                    searrow: '\u2198',
                    sect: '\xA7',
                    semi: ';',
                    seswar: '\u2929',
                    setminus: '\u2216',
                    setmn: '\u2216',
                    sext: '\u2736',
                    sfr: '\uD835\uDD30',
                    Sfr: '\uD835\uDD16',
                    sfrown: '\u2322',
                    sharp: '\u266F',
                    shchcy: '\u0449',
                    SHCHcy: '\u0429',
                    shcy: '\u0448',
                    SHcy: '\u0428',
                    ShortDownArrow: '\u2193',
                    ShortLeftArrow: '\u2190',
                    shortmid: '\u2223',
                    shortparallel: '\u2225',
                    ShortRightArrow: '\u2192',
                    ShortUpArrow: '\u2191',
                    shy: '\xAD',
                    sigma: '\u03C3',
                    Sigma: '\u03A3',
                    sigmaf: '\u03C2',
                    sigmav: '\u03C2',
                    sim: '\u223C',
                    simdot: '\u2A6A',
                    sime: '\u2243',
                    simeq: '\u2243',
                    simg: '\u2A9E',
                    simgE: '\u2AA0',
                    siml: '\u2A9D',
                    simlE: '\u2A9F',
                    simne: '\u2246',
                    simplus: '\u2A24',
                    simrarr: '\u2972',
                    slarr: '\u2190',
                    SmallCircle: '\u2218',
                    smallsetminus: '\u2216',
                    smashp: '\u2A33',
                    smeparsl: '\u29E4',
                    smid: '\u2223',
                    smile: '\u2323',
                    smt: '\u2AAA',
                    smte: '\u2AAC',
                    smtes: '\u2AAC\uFE00',
                    softcy: '\u044C',
                    SOFTcy: '\u042C',
                    sol: '/',
                    solb: '\u29C4',
                    solbar: '\u233F',
                    sopf: '\uD835\uDD64',
                    Sopf: '\uD835\uDD4A',
                    spades: '\u2660',
                    spadesuit: '\u2660',
                    spar: '\u2225',
                    sqcap: '\u2293',
                    sqcaps: '\u2293\uFE00',
                    sqcup: '\u2294',
                    sqcups: '\u2294\uFE00',
                    Sqrt: '\u221A',
                    sqsub: '\u228F',
                    sqsube: '\u2291',
                    sqsubset: '\u228F',
                    sqsubseteq: '\u2291',
                    sqsup: '\u2290',
                    sqsupe: '\u2292',
                    sqsupset: '\u2290',
                    sqsupseteq: '\u2292',
                    squ: '\u25A1',
                    square: '\u25A1',
                    Square: '\u25A1',
                    SquareIntersection: '\u2293',
                    SquareSubset: '\u228F',
                    SquareSubsetEqual: '\u2291',
                    SquareSuperset: '\u2290',
                    SquareSupersetEqual: '\u2292',
                    SquareUnion: '\u2294',
                    squarf: '\u25AA',
                    squf: '\u25AA',
                    srarr: '\u2192',
                    sscr: '\uD835\uDCC8',
                    Sscr: '\uD835\uDCAE',
                    ssetmn: '\u2216',
                    ssmile: '\u2323',
                    sstarf: '\u22C6',
                    star: '\u2606',
                    Star: '\u22C6',
                    starf: '\u2605',
                    straightepsilon: '\u03F5',
                    straightphi: '\u03D5',
                    strns: '\xAF',
                    sub: '\u2282',
                    Sub: '\u22D0',
                    subdot: '\u2ABD',
                    sube: '\u2286',
                    subE: '\u2AC5',
                    subedot: '\u2AC3',
                    submult: '\u2AC1',
                    subne: '\u228A',
                    subnE: '\u2ACB',
                    subplus: '\u2ABF',
                    subrarr: '\u2979',
                    subset: '\u2282',
                    Subset: '\u22D0',
                    subseteq: '\u2286',
                    subseteqq: '\u2AC5',
                    SubsetEqual: '\u2286',
                    subsetneq: '\u228A',
                    subsetneqq: '\u2ACB',
                    subsim: '\u2AC7',
                    subsub: '\u2AD5',
                    subsup: '\u2AD3',
                    succ: '\u227B',
                    succapprox: '\u2AB8',
                    succcurlyeq: '\u227D',
                    Succeeds: '\u227B',
                    SucceedsEqual: '\u2AB0',
                    SucceedsSlantEqual: '\u227D',
                    SucceedsTilde: '\u227F',
                    succeq: '\u2AB0',
                    succnapprox: '\u2ABA',
                    succneqq: '\u2AB6',
                    succnsim: '\u22E9',
                    succsim: '\u227F',
                    SuchThat: '\u220B',
                    sum: '\u2211',
                    Sum: '\u2211',
                    sung: '\u266A',
                    sup: '\u2283',
                    Sup: '\u22D1',
                    sup1: '\xB9',
                    sup2: '\xB2',
                    sup3: '\xB3',
                    supdot: '\u2ABE',
                    supdsub: '\u2AD8',
                    supe: '\u2287',
                    supE: '\u2AC6',
                    supedot: '\u2AC4',
                    Superset: '\u2283',
                    SupersetEqual: '\u2287',
                    suphsol: '\u27C9',
                    suphsub: '\u2AD7',
                    suplarr: '\u297B',
                    supmult: '\u2AC2',
                    supne: '\u228B',
                    supnE: '\u2ACC',
                    supplus: '\u2AC0',
                    supset: '\u2283',
                    Supset: '\u22D1',
                    supseteq: '\u2287',
                    supseteqq: '\u2AC6',
                    supsetneq: '\u228B',
                    supsetneqq: '\u2ACC',
                    supsim: '\u2AC8',
                    supsub: '\u2AD4',
                    supsup: '\u2AD6',
                    swarhk: '\u2926',
                    swarr: '\u2199',
                    swArr: '\u21D9',
                    swarrow: '\u2199',
                    swnwar: '\u292A',
                    szlig: '\xDF',
                    Tab: '\t',
                    target: '\u2316',
                    tau: '\u03C4',
                    Tau: '\u03A4',
                    tbrk: '\u23B4',
                    tcaron: '\u0165',
                    Tcaron: '\u0164',
                    tcedil: '\u0163',
                    Tcedil: '\u0162',
                    tcy: '\u0442',
                    Tcy: '\u0422',
                    tdot: '\u20DB',
                    telrec: '\u2315',
                    tfr: '\uD835\uDD31',
                    Tfr: '\uD835\uDD17',
                    there4: '\u2234',
                    therefore: '\u2234',
                    Therefore: '\u2234',
                    theta: '\u03B8',
                    Theta: '\u0398',
                    thetasym: '\u03D1',
                    thetav: '\u03D1',
                    thickapprox: '\u2248',
                    thicksim: '\u223C',
                    ThickSpace: '\u205F\u200A',
                    thinsp: '\u2009',
                    ThinSpace: '\u2009',
                    thkap: '\u2248',
                    thksim: '\u223C',
                    thorn: '\xFE',
                    THORN: '\xDE',
                    tilde: '\u02DC',
                    Tilde: '\u223C',
                    TildeEqual: '\u2243',
                    TildeFullEqual: '\u2245',
                    TildeTilde: '\u2248',
                    times: '\xD7',
                    timesb: '\u22A0',
                    timesbar: '\u2A31',
                    timesd: '\u2A30',
                    tint: '\u222D',
                    toea: '\u2928',
                    top: '\u22A4',
                    topbot: '\u2336',
                    topcir: '\u2AF1',
                    topf: '\uD835\uDD65',
                    Topf: '\uD835\uDD4B',
                    topfork: '\u2ADA',
                    tosa: '\u2929',
                    tprime: '\u2034',
                    trade: '\u2122',
                    TRADE: '\u2122',
                    triangle: '\u25B5',
                    triangledown: '\u25BF',
                    triangleleft: '\u25C3',
                    trianglelefteq: '\u22B4',
                    triangleq: '\u225C',
                    triangleright: '\u25B9',
                    trianglerighteq: '\u22B5',
                    tridot: '\u25EC',
                    trie: '\u225C',
                    triminus: '\u2A3A',
                    TripleDot: '\u20DB',
                    triplus: '\u2A39',
                    trisb: '\u29CD',
                    tritime: '\u2A3B',
                    trpezium: '\u23E2',
                    tscr: '\uD835\uDCC9',
                    Tscr: '\uD835\uDCAF',
                    tscy: '\u0446',
                    TScy: '\u0426',
                    tshcy: '\u045B',
                    TSHcy: '\u040B',
                    tstrok: '\u0167',
                    Tstrok: '\u0166',
                    twixt: '\u226C',
                    twoheadleftarrow: '\u219E',
                    twoheadrightarrow: '\u21A0',
                    uacute: '\xFA',
                    Uacute: '\xDA',
                    uarr: '\u2191',
                    uArr: '\u21D1',
                    Uarr: '\u219F',
                    Uarrocir: '\u2949',
                    ubrcy: '\u045E',
                    Ubrcy: '\u040E',
                    ubreve: '\u016D',
                    Ubreve: '\u016C',
                    ucirc: '\xFB',
                    Ucirc: '\xDB',
                    ucy: '\u0443',
                    Ucy: '\u0423',
                    udarr: '\u21C5',
                    udblac: '\u0171',
                    Udblac: '\u0170',
                    udhar: '\u296E',
                    ufisht: '\u297E',
                    ufr: '\uD835\uDD32',
                    Ufr: '\uD835\uDD18',
                    ugrave: '\xF9',
                    Ugrave: '\xD9',
                    uHar: '\u2963',
                    uharl: '\u21BF',
                    uharr: '\u21BE',
                    uhblk: '\u2580',
                    ulcorn: '\u231C',
                    ulcorner: '\u231C',
                    ulcrop: '\u230F',
                    ultri: '\u25F8',
                    umacr: '\u016B',
                    Umacr: '\u016A',
                    uml: '\xA8',
                    UnderBar: '_',
                    UnderBrace: '\u23DF',
                    UnderBracket: '\u23B5',
                    UnderParenthesis: '\u23DD',
                    Union: '\u22C3',
                    UnionPlus: '\u228E',
                    uogon: '\u0173',
                    Uogon: '\u0172',
                    uopf: '\uD835\uDD66',
                    Uopf: '\uD835\uDD4C',
                    uparrow: '\u2191',
                    Uparrow: '\u21D1',
                    UpArrow: '\u2191',
                    UpArrowBar: '\u2912',
                    UpArrowDownArrow: '\u21C5',
                    updownarrow: '\u2195',
                    Updownarrow: '\u21D5',
                    UpDownArrow: '\u2195',
                    UpEquilibrium: '\u296E',
                    upharpoonleft: '\u21BF',
                    upharpoonright: '\u21BE',
                    uplus: '\u228E',
                    UpperLeftArrow: '\u2196',
                    UpperRightArrow: '\u2197',
                    upsi: '\u03C5',
                    Upsi: '\u03D2',
                    upsih: '\u03D2',
                    upsilon: '\u03C5',
                    Upsilon: '\u03A5',
                    UpTee: '\u22A5',
                    UpTeeArrow: '\u21A5',
                    upuparrows: '\u21C8',
                    urcorn: '\u231D',
                    urcorner: '\u231D',
                    urcrop: '\u230E',
                    uring: '\u016F',
                    Uring: '\u016E',
                    urtri: '\u25F9',
                    uscr: '\uD835\uDCCA',
                    Uscr: '\uD835\uDCB0',
                    utdot: '\u22F0',
                    utilde: '\u0169',
                    Utilde: '\u0168',
                    utri: '\u25B5',
                    utrif: '\u25B4',
                    uuarr: '\u21C8',
                    uuml: '\xFC',
                    Uuml: '\xDC',
                    uwangle: '\u29A7',
                    vangrt: '\u299C',
                    varepsilon: '\u03F5',
                    varkappa: '\u03F0',
                    varnothing: '\u2205',
                    varphi: '\u03D5',
                    varpi: '\u03D6',
                    varpropto: '\u221D',
                    varr: '\u2195',
                    vArr: '\u21D5',
                    varrho: '\u03F1',
                    varsigma: '\u03C2',
                    varsubsetneq: '\u228A\uFE00',
                    varsubsetneqq: '\u2ACB\uFE00',
                    varsupsetneq: '\u228B\uFE00',
                    varsupsetneqq: '\u2ACC\uFE00',
                    vartheta: '\u03D1',
                    vartriangleleft: '\u22B2',
                    vartriangleright: '\u22B3',
                    vBar: '\u2AE8',
                    Vbar: '\u2AEB',
                    vBarv: '\u2AE9',
                    vcy: '\u0432',
                    Vcy: '\u0412',
                    vdash: '\u22A2',
                    vDash: '\u22A8',
                    Vdash: '\u22A9',
                    VDash: '\u22AB',
                    Vdashl: '\u2AE6',
                    vee: '\u2228',
                    Vee: '\u22C1',
                    veebar: '\u22BB',
                    veeeq: '\u225A',
                    vellip: '\u22EE',
                    verbar: '|',
                    Verbar: '\u2016',
                    vert: '|',
                    Vert: '\u2016',
                    VerticalBar: '\u2223',
                    VerticalLine: '|',
                    VerticalSeparator: '\u2758',
                    VerticalTilde: '\u2240',
                    VeryThinSpace: '\u200A',
                    vfr: '\uD835\uDD33',
                    Vfr: '\uD835\uDD19',
                    vltri: '\u22B2',
                    vnsub: '\u2282\u20D2',
                    vnsup: '\u2283\u20D2',
                    vopf: '\uD835\uDD67',
                    Vopf: '\uD835\uDD4D',
                    vprop: '\u221D',
                    vrtri: '\u22B3',
                    vscr: '\uD835\uDCCB',
                    Vscr: '\uD835\uDCB1',
                    vsubne: '\u228A\uFE00',
                    vsubnE: '\u2ACB\uFE00',
                    vsupne: '\u228B\uFE00',
                    vsupnE: '\u2ACC\uFE00',
                    Vvdash: '\u22AA',
                    vzigzag: '\u299A',
                    wcirc: '\u0175',
                    Wcirc: '\u0174',
                    wedbar: '\u2A5F',
                    wedge: '\u2227',
                    Wedge: '\u22C0',
                    wedgeq: '\u2259',
                    weierp: '\u2118',
                    wfr: '\uD835\uDD34',
                    Wfr: '\uD835\uDD1A',
                    wopf: '\uD835\uDD68',
                    Wopf: '\uD835\uDD4E',
                    wp: '\u2118',
                    wr: '\u2240',
                    wreath: '\u2240',
                    wscr: '\uD835\uDCCC',
                    Wscr: '\uD835\uDCB2',
                    xcap: '\u22C2',
                    xcirc: '\u25EF',
                    xcup: '\u22C3',
                    xdtri: '\u25BD',
                    xfr: '\uD835\uDD35',
                    Xfr: '\uD835\uDD1B',
                    xharr: '\u27F7',
                    xhArr: '\u27FA',
                    xi: '\u03BE',
                    Xi: '\u039E',
                    xlarr: '\u27F5',
                    xlArr: '\u27F8',
                    xmap: '\u27FC',
                    xnis: '\u22FB',
                    xodot: '\u2A00',
                    xopf: '\uD835\uDD69',
                    Xopf: '\uD835\uDD4F',
                    xoplus: '\u2A01',
                    xotime: '\u2A02',
                    xrarr: '\u27F6',
                    xrArr: '\u27F9',
                    xscr: '\uD835\uDCCD',
                    Xscr: '\uD835\uDCB3',
                    xsqcup: '\u2A06',
                    xuplus: '\u2A04',
                    xutri: '\u25B3',
                    xvee: '\u22C1',
                    xwedge: '\u22C0',
                    yacute: '\xFD',
                    Yacute: '\xDD',
                    yacy: '\u044F',
                    YAcy: '\u042F',
                    ycirc: '\u0177',
                    Ycirc: '\u0176',
                    ycy: '\u044B',
                    Ycy: '\u042B',
                    yen: '\xA5',
                    yfr: '\uD835\uDD36',
                    Yfr: '\uD835\uDD1C',
                    yicy: '\u0457',
                    YIcy: '\u0407',
                    yopf: '\uD835\uDD6A',
                    Yopf: '\uD835\uDD50',
                    yscr: '\uD835\uDCCE',
                    Yscr: '\uD835\uDCB4',
                    yucy: '\u044E',
                    YUcy: '\u042E',
                    yuml: '\xFF',
                    Yuml: '\u0178',
                    zacute: '\u017A',
                    Zacute: '\u0179',
                    zcaron: '\u017E',
                    Zcaron: '\u017D',
                    zcy: '\u0437',
                    Zcy: '\u0417',
                    zdot: '\u017C',
                    Zdot: '\u017B',
                    zeetrf: '\u2128',
                    ZeroWidthSpace: '\u200B',
                    zeta: '\u03B6',
                    Zeta: '\u0396',
                    zfr: '\uD835\uDD37',
                    Zfr: '\u2128',
                    zhcy: '\u0436',
                    ZHcy: '\u0416',
                    zigrarr: '\u21DD',
                    zopf: '\uD835\uDD6B',
                    Zopf: '\u2124',
                    zscr: '\uD835\uDCCF',
                    Zscr: '\uD835\uDCB5',
                    zwj: '\u200D',
                    zwnj: '\u200C'
                };
                var decodeMapLegacy = {
                    aacute: '\xE1',
                    Aacute: '\xC1',
                    acirc: '\xE2',
                    Acirc: '\xC2',
                    acute: '\xB4',
                    aelig: '\xE6',
                    AElig: '\xC6',
                    agrave: '\xE0',
                    Agrave: '\xC0',
                    amp: '&',
                    AMP: '&',
                    aring: '\xE5',
                    Aring: '\xC5',
                    atilde: '\xE3',
                    Atilde: '\xC3',
                    auml: '\xE4',
                    Auml: '\xC4',
                    brvbar: '\xA6',
                    ccedil: '\xE7',
                    Ccedil: '\xC7',
                    cedil: '\xB8',
                    cent: '\xA2',
                    copy: '\xA9',
                    COPY: '\xA9',
                    curren: '\xA4',
                    deg: '\xB0',
                    divide: '\xF7',
                    eacute: '\xE9',
                    Eacute: '\xC9',
                    ecirc: '\xEA',
                    Ecirc: '\xCA',
                    egrave: '\xE8',
                    Egrave: '\xC8',
                    eth: '\xF0',
                    ETH: '\xD0',
                    euml: '\xEB',
                    Euml: '\xCB',
                    frac12: '\xBD',
                    frac14: '\xBC',
                    frac34: '\xBE',
                    gt: '>',
                    GT: '>',
                    iacute: '\xED',
                    Iacute: '\xCD',
                    icirc: '\xEE',
                    Icirc: '\xCE',
                    iexcl: '\xA1',
                    igrave: '\xEC',
                    Igrave: '\xCC',
                    iquest: '\xBF',
                    iuml: '\xEF',
                    Iuml: '\xCF',
                    laquo: '\xAB',
                    lt: '<',
                    LT: '<',
                    macr: '\xAF',
                    micro: '\xB5',
                    middot: '\xB7',
                    nbsp: '\xA0',
                    not: '\xAC',
                    ntilde: '\xF1',
                    Ntilde: '\xD1',
                    oacute: '\xF3',
                    Oacute: '\xD3',
                    ocirc: '\xF4',
                    Ocirc: '\xD4',
                    ograve: '\xF2',
                    Ograve: '\xD2',
                    ordf: '\xAA',
                    ordm: '\xBA',
                    oslash: '\xF8',
                    Oslash: '\xD8',
                    otilde: '\xF5',
                    Otilde: '\xD5',
                    ouml: '\xF6',
                    Ouml: '\xD6',
                    para: '\xB6',
                    plusmn: '\xB1',
                    pound: '\xA3',
                    quot: '"',
                    QUOT: '"',
                    raquo: '\xBB',
                    reg: '\xAE',
                    REG: '\xAE',
                    sect: '\xA7',
                    shy: '\xAD',
                    sup1: '\xB9',
                    sup2: '\xB2',
                    sup3: '\xB3',
                    szlig: '\xDF',
                    thorn: '\xFE',
                    THORN: '\xDE',
                    times: '\xD7',
                    uacute: '\xFA',
                    Uacute: '\xDA',
                    ucirc: '\xFB',
                    Ucirc: '\xDB',
                    ugrave: '\xF9',
                    Ugrave: '\xD9',
                    uml: '\xA8',
                    uuml: '\xFC',
                    Uuml: '\xDC',
                    yacute: '\xFD',
                    Yacute: '\xDD',
                    yen: '\xA5',
                    yuml: '\xFF'
                };
                var decodeMapNumeric = {
                    0: '\uFFFD',
                    128: '\u20AC',
                    130: '\u201A',
                    131: '\u0192',
                    132: '\u201E',
                    133: '\u2026',
                    134: '\u2020',
                    135: '\u2021',
                    136: '\u02C6',
                    137: '\u2030',
                    138: '\u0160',
                    139: '\u2039',
                    140: '\u0152',
                    142: '\u017D',
                    145: '\u2018',
                    146: '\u2019',
                    147: '\u201C',
                    148: '\u201D',
                    149: '\u2022',
                    150: '\u2013',
                    151: '\u2014',
                    152: '\u02DC',
                    153: '\u2122',
                    154: '\u0161',
                    155: '\u203A',
                    156: '\u0153',
                    158: '\u017E',
                    159: '\u0178'
                };
                var invalidReferenceCodePoints = [
                    1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
                    26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
                    138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,
                    154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982,
                    64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993,
                    64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004,
                    65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142,
                    262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822,
                    589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502,
                    917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111
                ];

                /*--------------------------------------------------------------------------*/

                var stringFromCharCode = String.fromCharCode;

                var object = {};
                var hasOwnProperty = object.hasOwnProperty;
                var has = function (object, propertyName) {
                    return hasOwnProperty.call(object, propertyName);
                };

                var contains = function (array, value) {
                    var index = -1;
                    var length = array.length;
                    while (++index < length) {
                        if (array[index] == value) {
                            return true;
                        }
                    }
                    return false;
                };

                var merge = function (options, defaults) {
                    if (!options) {
                        return defaults;
                    }
                    var result = {};
                    var key;
                    for (key in defaults) {
                        // A `hasOwnProperty` check is not needed here, since only recognized
                        // option names are used anyway. Any others are ignored.
                        result[key] = has(options, key) ? options[key] : defaults[key];
                    }
                    return result;
                };

                // Modified version of `ucs2encode`; see https://mths.be/punycode.
                var codePointToSymbol = function (codePoint, strict) {
                    var output = '';
                    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
                        // See issue #4:
                        // “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
                        // greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
                        // REPLACEMENT CHARACTER.”
                        if (strict) {
                            parseError('character reference outside the permissible Unicode range');
                        }
                        return '\uFFFD';
                    }
                    if (has(decodeMapNumeric, codePoint)) {
                        if (strict) {
                            parseError('disallowed character reference');
                        }
                        return decodeMapNumeric[codePoint];
                    }
                    if (strict && contains(invalidReferenceCodePoints, codePoint)) {
                        parseError('disallowed character reference');
                    }
                    if (codePoint > 0xffff) {
                        codePoint -= 0x10000;
                        output += stringFromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
                        codePoint = 0xdc00 | (codePoint & 0x3ff);
                    }
                    output += stringFromCharCode(codePoint);
                    return output;
                };

                var hexEscape = function (codePoint) {
                    return '&#x' + codePoint.toString(16).toUpperCase() + ';';
                };

                var decEscape = function (codePoint) {
                    return '&#' + codePoint + ';';
                };

                var parseError = function (message) {
                    throw Error('Parse error: ' + message);
                };

                /*--------------------------------------------------------------------------*/

                var encode = function (string, options) {
                    options = merge(options, encode.options);
                    var strict = options.strict;
                    if (strict && regexInvalidRawCodePoint.test(string)) {
                        parseError('forbidden code point');
                    }
                    var encodeEverything = options.encodeEverything;
                    var useNamedReferences = options.useNamedReferences;
                    var allowUnsafeSymbols = options.allowUnsafeSymbols;
                    var escapeCodePoint = options.decimal ? decEscape : hexEscape;

                    var escapeBmpSymbol = function (symbol) {
                        return escapeCodePoint(symbol.charCodeAt(0));
                    };

                    if (encodeEverything) {
                        // Encode ASCII symbols.
                        string = string.replace(regexAsciiWhitelist, function (symbol) {
                            // Use named references if requested & possible.
                            if (useNamedReferences && has(encodeMap, symbol)) {
                                return '&' + encodeMap[symbol] + ';';
                            }
                            return escapeBmpSymbol(symbol);
                        });
                        // Shorten a few escapes that represent two symbols, of which at least one
                        // is within the ASCII range.
                        if (useNamedReferences) {
                            string = string
                                .replace(/&gt;\u20D2/g, '&nvgt;')
                                .replace(/&lt;\u20D2/g, '&nvlt;')
                                .replace(/&#x66;&#x6A;/g, '&fjlig;');
                        }
                        // Encode non-ASCII symbols.
                        if (useNamedReferences) {
                            // Encode non-ASCII symbols that can be replaced with a named reference.
                            string = string.replace(regexEncodeNonAscii, function (string) {
                                // Note: there is no need to check `has(encodeMap, string)` here.
                                return '&' + encodeMap[string] + ';';
                            });
                        }
                        // Note: any remaining non-ASCII symbols are handled outside of the `if`.
                    } else if (useNamedReferences) {
                        // Apply named character references.
                        // Encode `<>"'&` using named character references.
                        if (!allowUnsafeSymbols) {
                            string = string.replace(regexEscape, function (string) {
                                return '&' + encodeMap[string] + ';'; // no need to check `has()` here
                            });
                        }
                        // Shorten escapes that represent two symbols, of which at least one is
                        // `<>"'&`.
                        string = string
                            .replace(/&gt;\u20D2/g, '&nvgt;')
                            .replace(/&lt;\u20D2/g, '&nvlt;');
                        // Encode non-ASCII symbols that can be replaced with a named reference.
                        string = string.replace(regexEncodeNonAscii, function (string) {
                            // Note: there is no need to check `has(encodeMap, string)` here.
                            return '&' + encodeMap[string] + ';';
                        });
                    } else if (!allowUnsafeSymbols) {
                        // Encode `<>"'&` using hexadecimal escapes, now that they’re not handled
                        // using named character references.
                        string = string.replace(regexEscape, escapeBmpSymbol);
                    }
                    return (
                        string
                            // Encode astral symbols.
                            .replace(regexAstralSymbols, function ($0) {
                                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                                var high = $0.charCodeAt(0);
                                var low = $0.charCodeAt(1);
                                var codePoint = (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;
                                return escapeCodePoint(codePoint);
                            })
                            // Encode any remaining BMP symbols that are not printable ASCII symbols
                            // using a hexadecimal escape.
                            .replace(regexBmpWhitelist, escapeBmpSymbol)
                    );
                };
                // Expose default options (so they can be overridden globally).
                encode.options = {
                    allowUnsafeSymbols: false,
                    encodeEverything: false,
                    strict: false,
                    useNamedReferences: false,
                    decimal: false
                };

                var decode = function (html, options) {
                    options = merge(options, decode.options);
                    var strict = options.strict;
                    if (strict && regexInvalidEntity.test(html)) {
                        parseError('malformed character reference');
                    }
                    return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7, $8) {
                        var codePoint;
                        var semicolon;
                        var decDigits;
                        var hexDigits;
                        var reference;
                        var next;

                        if ($1) {
                            reference = $1;
                            // Note: there is no need to check `has(decodeMap, reference)`.
                            return decodeMap[reference];
                        }

                        if ($2) {
                            // Decode named character references without trailing `;`, e.g. `&amp`.
                            // This is only a parse error if it gets converted to `&`, or if it is
                            // followed by `=` in an attribute context.
                            reference = $2;
                            next = $3;
                            if (next && options.isAttributeValue) {
                                if (strict && next == '=') {
                                    parseError('`&` did not start a character reference');
                                }
                                return $0;
                            } else {
                                if (strict) {
                                    parseError(
                                        'named character reference was not terminated by a semicolon'
                                    );
                                }
                                // Note: there is no need to check `has(decodeMapLegacy, reference)`.
                                return decodeMapLegacy[reference] + (next || '');
                            }
                        }

                        if ($4) {
                            // Decode decimal escapes, e.g. `&#119558;`.
                            decDigits = $4;
                            semicolon = $5;
                            if (strict && !semicolon) {
                                parseError('character reference was not terminated by a semicolon');
                            }
                            codePoint = parseInt(decDigits, 10);
                            return codePointToSymbol(codePoint, strict);
                        }

                        if ($6) {
                            // Decode hexadecimal escapes, e.g. `&#x1D306;`.
                            hexDigits = $6;
                            semicolon = $7;
                            if (strict && !semicolon) {
                                parseError('character reference was not terminated by a semicolon');
                            }
                            codePoint = parseInt(hexDigits, 16);
                            return codePointToSymbol(codePoint, strict);
                        }

                        // If we’re still here, `if ($7)` is implied; it’s an ambiguous
                        // ampersand for sure. https://mths.be/notes/ambiguous-ampersands
                        if (strict) {
                            parseError(
                                'named character reference was not terminated by a semicolon'
                            );
                        }
                        return $0;
                    });
                };
                // Expose default options (so they can be overridden globally).
                decode.options = {
                    isAttributeValue: false,
                    strict: false
                };

                var escape = function (string) {
                    return string.replace(regexEscape, function ($0) {
                        // Note: there is no need to check `has(escapeMap, $0)` here.
                        return escapeMap[$0];
                    });
                };

                /*--------------------------------------------------------------------------*/

                var he = {
                    version: '1.2.0',
                    encode: encode,
                    decode: decode,
                    escape: escape,
                    unescape: decode
                };

                // Some AMD build optimizers, like r.js, check for specific condition patterns
                // like the following:
                if (true) {
                    !((__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                        return he;
                    }.call(exports, __webpack_require__, exports, module)),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                        (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {
                    var key;
                }
            })(this);

            /***/
        },
        /* 73 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.generateTokenAuthHeader = void 0;
            function generateTokenAuthHeader(token) {
                return ''.concat(token.token_type, ' ').concat(token.access_token);
            }
            exports.generateTokenAuthHeader = generateTokenAuthHeader;

            /***/
        },
        /* 74 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.ErrorCode = exports.AuthType = void 0;
            var AuthType;
            (function (AuthType) {
                AuthType['Digest'] = 'digest';
                AuthType['None'] = 'none';
                AuthType['Password'] = 'password';
                AuthType['Token'] = 'token';
            })((AuthType = exports.AuthType || (exports.AuthType = {})));
            var ErrorCode;
            (function (ErrorCode) {
                ErrorCode['DataTypeNoLength'] = 'data-type-no-length';
                ErrorCode['InvalidAuthType'] = 'invalid-auth-type';
                ErrorCode['InvalidOutputFormat'] = 'invalid-output-format';
                ErrorCode['LinkUnsupportedAuthType'] = 'link-unsupported-auth';
            })((ErrorCode = exports.ErrorCode || (exports.ErrorCode = {})));

            /***/
        },
        /* 75 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.copyFile = void 0;
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            function copyFile(context, filename, destination, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var requestOptions, response;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(filename)
                                        ),
                                        method: 'COPY',
                                        headers: {
                                            Destination: (0, url_1.joinURL)(
                                                context.remoteURL,
                                                (0, path_1.encodePath)(destination)
                                            )
                                        }
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [2 /*return*/];
                        }
                    });
                });
            }
            exports.copyFile = copyFile;

            /***/
        },
        /* 76 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.request = exports.prepareRequestOptions = void 0;
            var axios_1 = __importDefault(__webpack_require__(77));
            var patcher_1 = __webpack_require__(142);
            var digest_1 = __webpack_require__(63);
            var merge_1 = __webpack_require__(145);
            var headers_1 = __webpack_require__(146);
            function _request(requestOptions) {
                return (0, patcher_1.getPatcher)().patchInline(
                    'request',
                    function (options) {
                        return (0, axios_1.default)(options);
                    },
                    requestOptions
                );
            }
            function prepareRequestOptions(requestOptions, context, userOptions) {
                var finalOptions = (0, merge_1.cloneShallow)(requestOptions);
                finalOptions.headers = (0, headers_1.mergeHeaders)(
                    context.headers,
                    finalOptions.headers || {},
                    userOptions.headers || {}
                );
                if (typeof userOptions.data !== 'undefined') {
                    finalOptions.data = userOptions.data;
                }
                if (userOptions.signal) {
                    finalOptions.signal = userOptions.signal;
                }
                if (context.httpAgent) {
                    finalOptions.httpAgent = context.httpAgent;
                }
                if (context.httpsAgent) {
                    finalOptions.httpsAgent = context.httpsAgent;
                }
                if (context.digest) {
                    finalOptions._digest = context.digest;
                }
                if (typeof context.withCredentials === 'boolean') {
                    finalOptions.withCredentials = context.withCredentials;
                }
                if (context.maxContentLength) {
                    finalOptions.maxContentLength = context.maxContentLength;
                }
                if (context.maxBodyLength) {
                    finalOptions.maxBodyLength = context.maxBodyLength;
                }
                if (userOptions.hasOwnProperty('onUploadProgress')) {
                    finalOptions.onUploadProgress = userOptions['onUploadProgress'];
                }
                if (userOptions.hasOwnProperty('onDownloadProgress')) {
                    finalOptions.onDownloadProgress = userOptions['onDownloadProgress'];
                }
                // Take full control of all response status codes
                finalOptions.validateStatus = function () {
                    return true;
                };
                return finalOptions;
            }
            exports.prepareRequestOptions = prepareRequestOptions;
            function request(requestOptions) {
                // Client not configured for digest authentication
                if (!requestOptions._digest) {
                    return _request(requestOptions);
                }
                // Remove client's digest authentication object from request options
                var _digest = requestOptions._digest;
                delete requestOptions._digest;
                // If client is already using digest authentication, include the digest authorization header
                if (_digest.hasDigestAuth) {
                    requestOptions = (0, merge_1.merge)(requestOptions, {
                        headers: {
                            Authorization: (0, digest_1.generateDigestAuthHeader)(
                                requestOptions,
                                _digest
                            )
                        }
                    });
                }
                // Perform the request and handle digest authentication
                return _request(requestOptions).then(function (response) {
                    if (response.status == 401) {
                        _digest.hasDigestAuth = (0, digest_1.parseDigestAuth)(response, _digest);
                        if (_digest.hasDigestAuth) {
                            requestOptions = (0, merge_1.merge)(requestOptions, {
                                headers: {
                                    Authorization: (0, digest_1.generateDigestAuthHeader)(
                                        requestOptions,
                                        _digest
                                    )
                                }
                            });
                            return _request(requestOptions).then(function (response2) {
                                if (response2.status == 401) {
                                    _digest.hasDigestAuth = false;
                                } else {
                                    _digest.nc++;
                                }
                                return response2;
                            });
                        }
                    } else {
                        _digest.nc++;
                    }
                    return response;
                });
            }
            exports.request = request;

            /***/
        },
        /* 77 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            module.exports = __webpack_require__(78);

            /***/
        },
        /* 78 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);
            var bind = __webpack_require__(80);
            var Axios = __webpack_require__(81);
            var mergeConfig = __webpack_require__(137);
            var defaults = __webpack_require__(86);

            /**
             * Create an instance of Axios
             *
             * @param {Object} defaultConfig The default config for the instance
             * @return {Axios} A new instance of Axios
             */
            function createInstance(defaultConfig) {
                var context = new Axios(defaultConfig);
                var instance = bind(Axios.prototype.request, context);

                // Copy axios.prototype to instance
                utils.extend(instance, Axios.prototype, context);

                // Copy context to instance
                utils.extend(instance, context);

                // Factory for creating new instances
                instance.create = function create(instanceConfig) {
                    return createInstance(mergeConfig(defaultConfig, instanceConfig));
                };

                return instance;
            }

            // Create the default instance to be exported
            var axios = createInstance(defaults);

            // Expose Axios class to allow class inheritance
            axios.Axios = Axios;

            // Expose Cancel & CancelToken
            axios.CanceledError = __webpack_require__(99);
            axios.CancelToken = __webpack_require__(139);
            axios.isCancel = __webpack_require__(136);
            axios.VERSION = __webpack_require__(117).version;
            axios.toFormData = __webpack_require__(90);

            // Expose AxiosError class
            axios.AxiosError = __webpack_require__(88);

            // alias for CanceledError for backward compatibility
            axios.Cancel = axios.CanceledError;

            // Expose all/spread
            axios.all = function all(promises) {
                return Promise.all(promises);
            };
            axios.spread = __webpack_require__(140);

            // Expose isAxiosError
            axios.isAxiosError = __webpack_require__(141);

            module.exports = axios;

            // Allow use of default import syntax in TypeScript
            module.exports['default'] = axios;

            /***/
        },
        /* 79 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var bind = __webpack_require__(80);

            // utils is a library of generic helper functions non-specific to axios

            var toString = Object.prototype.toString;

            // eslint-disable-next-line func-names
            var kindOf = (function (cache) {
                // eslint-disable-next-line func-names
                return function (thing) {
                    var str = toString.call(thing);
                    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
                };
            })(Object.create(null));

            function kindOfTest(type) {
                type = type.toLowerCase();
                return function isKindOf(thing) {
                    return kindOf(thing) === type;
                };
            }

            /**
             * Determine if a value is an Array
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is an Array, otherwise false
             */
            function isArray(val) {
                return Array.isArray(val);
            }

            /**
             * Determine if a value is undefined
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if the value is undefined, otherwise false
             */
            function isUndefined(val) {
                return typeof val === 'undefined';
            }

            /**
             * Determine if a value is a Buffer
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Buffer, otherwise false
             */
            function isBuffer(val) {
                return (
                    val !== null &&
                    !isUndefined(val) &&
                    val.constructor !== null &&
                    !isUndefined(val.constructor) &&
                    typeof val.constructor.isBuffer === 'function' &&
                    val.constructor.isBuffer(val)
                );
            }

            /**
             * Determine if a value is an ArrayBuffer
             *
             * @function
             * @param {Object} val The value to test
             * @returns {boolean} True if value is an ArrayBuffer, otherwise false
             */
            var isArrayBuffer = kindOfTest('ArrayBuffer');

            /**
             * Determine if a value is a view on an ArrayBuffer
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
             */
            function isArrayBufferView(val) {
                var result;
                if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                    result = ArrayBuffer.isView(val);
                } else {
                    result = val && val.buffer && isArrayBuffer(val.buffer);
                }
                return result;
            }

            /**
             * Determine if a value is a String
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a String, otherwise false
             */
            function isString(val) {
                return typeof val === 'string';
            }

            /**
             * Determine if a value is a Number
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Number, otherwise false
             */
            function isNumber(val) {
                return typeof val === 'number';
            }

            /**
             * Determine if a value is an Object
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is an Object, otherwise false
             */
            function isObject(val) {
                return val !== null && typeof val === 'object';
            }

            /**
             * Determine if a value is a plain Object
             *
             * @param {Object} val The value to test
             * @return {boolean} True if value is a plain Object, otherwise false
             */
            function isPlainObject(val) {
                if (kindOf(val) !== 'object') {
                    return false;
                }

                var prototype = Object.getPrototypeOf(val);
                return prototype === null || prototype === Object.prototype;
            }

            /**
             * Determine if a value is a Date
             *
             * @function
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Date, otherwise false
             */
            var isDate = kindOfTest('Date');

            /**
             * Determine if a value is a File
             *
             * @function
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a File, otherwise false
             */
            var isFile = kindOfTest('File');

            /**
             * Determine if a value is a Blob
             *
             * @function
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Blob, otherwise false
             */
            var isBlob = kindOfTest('Blob');

            /**
             * Determine if a value is a FileList
             *
             * @function
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a File, otherwise false
             */
            var isFileList = kindOfTest('FileList');

            /**
             * Determine if a value is a Function
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Function, otherwise false
             */
            function isFunction(val) {
                return toString.call(val) === '[object Function]';
            }

            /**
             * Determine if a value is a Stream
             *
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a Stream, otherwise false
             */
            function isStream(val) {
                return isObject(val) && isFunction(val.pipe);
            }

            /**
             * Determine if a value is a FormData
             *
             * @param {Object} thing The value to test
             * @returns {boolean} True if value is an FormData, otherwise false
             */
            function isFormData(thing) {
                var pattern = '[object FormData]';
                return (
                    thing &&
                    ((typeof FormData === 'function' && thing instanceof FormData) ||
                        toString.call(thing) === pattern ||
                        (isFunction(thing.toString) && thing.toString() === pattern))
                );
            }

            /**
             * Determine if a value is a URLSearchParams object
             * @function
             * @param {Object} val The value to test
             * @returns {boolean} True if value is a URLSearchParams object, otherwise false
             */
            var isURLSearchParams = kindOfTest('URLSearchParams');

            /**
             * Trim excess whitespace off the beginning and end of a string
             *
             * @param {String} str The String to trim
             * @returns {String} The String freed of excess whitespace
             */
            function trim(str) {
                return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
            }

            /**
             * Determine if we're running in a standard browser environment
             *
             * This allows axios to run in a web worker, and react-native.
             * Both environments support XMLHttpRequest, but not fully standard globals.
             *
             * web workers:
             *  typeof window -> undefined
             *  typeof document -> undefined
             *
             * react-native:
             *  navigator.product -> 'ReactNative'
             * nativescript
             *  navigator.product -> 'NativeScript' or 'NS'
             */
            function isStandardBrowserEnv() {
                if (
                    typeof navigator !== 'undefined' &&
                    (navigator.product === 'ReactNative' ||
                        navigator.product === 'NativeScript' ||
                        navigator.product === 'NS')
                ) {
                    return false;
                }
                return typeof window !== 'undefined' && typeof document !== 'undefined';
            }

            /**
             * Iterate over an Array or an Object invoking a function for each item.
             *
             * If `obj` is an Array callback will be called passing
             * the value, index, and complete array for each item.
             *
             * If 'obj' is an Object callback will be called passing
             * the value, key, and complete object for each property.
             *
             * @param {Object|Array} obj The object to iterate
             * @param {Function} fn The callback to invoke for each item
             */
            function forEach(obj, fn) {
                // Don't bother if no value provided
                if (obj === null || typeof obj === 'undefined') {
                    return;
                }

                // Force an array if not already something iterable
                if (typeof obj !== 'object') {
                    /*eslint no-param-reassign:0*/
                    obj = [obj];
                }

                if (isArray(obj)) {
                    // Iterate over array values
                    for (var i = 0, l = obj.length; i < l; i++) {
                        fn.call(null, obj[i], i, obj);
                    }
                } else {
                    // Iterate over object keys
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            fn.call(null, obj[key], key, obj);
                        }
                    }
                }
            }

            /**
             * Accepts varargs expecting each argument to be an object, then
             * immutably merges the properties of each object and returns result.
             *
             * When multiple objects contain the same key the later object in
             * the arguments list will take precedence.
             *
             * Example:
             *
             * ```js
             * var result = merge({foo: 123}, {foo: 456});
             * console.log(result.foo); // outputs 456
             * ```
             *
             * @param {Object} obj1 Object to merge
             * @returns {Object} Result of all merge properties
             */
            function merge(/* obj1, obj2, obj3, ... */) {
                var result = {};
                function assignValue(val, key) {
                    if (isPlainObject(result[key]) && isPlainObject(val)) {
                        result[key] = merge(result[key], val);
                    } else if (isPlainObject(val)) {
                        result[key] = merge({}, val);
                    } else if (isArray(val)) {
                        result[key] = val.slice();
                    } else {
                        result[key] = val;
                    }
                }

                for (var i = 0, l = arguments.length; i < l; i++) {
                    forEach(arguments[i], assignValue);
                }
                return result;
            }

            /**
             * Extends object a by mutably adding to it the properties of object b.
             *
             * @param {Object} a The object to be extended
             * @param {Object} b The object to copy properties from
             * @param {Object} thisArg The object to bind function to
             * @return {Object} The resulting value of object a
             */
            function extend(a, b, thisArg) {
                forEach(b, function assignValue(val, key) {
                    if (thisArg && typeof val === 'function') {
                        a[key] = bind(val, thisArg);
                    } else {
                        a[key] = val;
                    }
                });
                return a;
            }

            /**
             * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
             *
             * @param {string} content with BOM
             * @return {string} content value without BOM
             */
            function stripBOM(content) {
                if (content.charCodeAt(0) === 0xfeff) {
                    content = content.slice(1);
                }
                return content;
            }

            /**
             * Inherit the prototype methods from one constructor into another
             * @param {function} constructor
             * @param {function} superConstructor
             * @param {object} [props]
             * @param {object} [descriptors]
             */

            function inherits(constructor, superConstructor, props, descriptors) {
                constructor.prototype = Object.create(superConstructor.prototype, descriptors);
                constructor.prototype.constructor = constructor;
                props && Object.assign(constructor.prototype, props);
            }

            /**
             * Resolve object with deep prototype chain to a flat object
             * @param {Object} sourceObj source object
             * @param {Object} [destObj]
             * @param {Function} [filter]
             * @returns {Object}
             */

            function toFlatObject(sourceObj, destObj, filter) {
                var props;
                var i;
                var prop;
                var merged = {};

                destObj = destObj || {};

                do {
                    props = Object.getOwnPropertyNames(sourceObj);
                    i = props.length;
                    while (i-- > 0) {
                        prop = props[i];
                        if (!merged[prop]) {
                            destObj[prop] = sourceObj[prop];
                            merged[prop] = true;
                        }
                    }
                    sourceObj = Object.getPrototypeOf(sourceObj);
                } while (
                    sourceObj &&
                    (!filter || filter(sourceObj, destObj)) &&
                    sourceObj !== Object.prototype
                );

                return destObj;
            }

            /*
             * determines whether a string ends with the characters of a specified string
             * @param {String} str
             * @param {String} searchString
             * @param {Number} [position= 0]
             * @returns {boolean}
             */
            function endsWith(str, searchString, position) {
                str = String(str);
                if (position === undefined || position > str.length) {
                    position = str.length;
                }
                position -= searchString.length;
                var lastIndex = str.indexOf(searchString, position);
                return lastIndex !== -1 && lastIndex === position;
            }

            /**
             * Returns new array from array like object
             * @param {*} [thing]
             * @returns {Array}
             */
            function toArray(thing) {
                if (!thing) return null;
                var i = thing.length;
                if (isUndefined(i)) return null;
                var arr = new Array(i);
                while (i-- > 0) {
                    arr[i] = thing[i];
                }
                return arr;
            }

            // eslint-disable-next-line func-names
            var isTypedArray = (function (TypedArray) {
                // eslint-disable-next-line func-names
                return function (thing) {
                    return TypedArray && thing instanceof TypedArray;
                };
            })(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

            module.exports = {
                isArray: isArray,
                isArrayBuffer: isArrayBuffer,
                isBuffer: isBuffer,
                isFormData: isFormData,
                isArrayBufferView: isArrayBufferView,
                isString: isString,
                isNumber: isNumber,
                isObject: isObject,
                isPlainObject: isPlainObject,
                isUndefined: isUndefined,
                isDate: isDate,
                isFile: isFile,
                isBlob: isBlob,
                isFunction: isFunction,
                isStream: isStream,
                isURLSearchParams: isURLSearchParams,
                isStandardBrowserEnv: isStandardBrowserEnv,
                forEach: forEach,
                merge: merge,
                extend: extend,
                trim: trim,
                stripBOM: stripBOM,
                inherits: inherits,
                toFlatObject: toFlatObject,
                kindOf: kindOf,
                kindOfTest: kindOfTest,
                endsWith: endsWith,
                toArray: toArray,
                isTypedArray: isTypedArray,
                isFileList: isFileList
            };

            /***/
        },
        /* 80 */
        /***/ (module) => {
            'use strict';

            module.exports = function bind(fn, thisArg) {
                return function wrap() {
                    var args = new Array(arguments.length);
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i];
                    }
                    return fn.apply(thisArg, args);
                };
            };

            /***/
        },
        /* 81 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);
            var buildURL = __webpack_require__(82);
            var InterceptorManager = __webpack_require__(83);
            var dispatchRequest = __webpack_require__(84);
            var mergeConfig = __webpack_require__(137);
            var buildFullPath = __webpack_require__(94);
            var validator = __webpack_require__(138);

            var validators = validator.validators;
            /**
             * Create a new instance of Axios
             *
             * @param {Object} instanceConfig The default config for the instance
             */
            function Axios(instanceConfig) {
                this.defaults = instanceConfig;
                this.interceptors = {
                    request: new InterceptorManager(),
                    response: new InterceptorManager()
                };
            }

            /**
             * Dispatch a request
             *
             * @param {Object} config The config specific for this request (merged with this.defaults)
             */
            Axios.prototype.request = function request(configOrUrl, config) {
                /*eslint no-param-reassign:0*/
                // Allow for axios('example/url'[, config]) a la fetch API
                if (typeof configOrUrl === 'string') {
                    config = config || {};
                    config.url = configOrUrl;
                } else {
                    config = configOrUrl || {};
                }

                config = mergeConfig(this.defaults, config);

                // Set config.method
                if (config.method) {
                    config.method = config.method.toLowerCase();
                } else if (this.defaults.method) {
                    config.method = this.defaults.method.toLowerCase();
                } else {
                    config.method = 'get';
                }

                var transitional = config.transitional;

                if (transitional !== undefined) {
                    validator.assertOptions(
                        transitional,
                        {
                            silentJSONParsing: validators.transitional(validators.boolean),
                            forcedJSONParsing: validators.transitional(validators.boolean),
                            clarifyTimeoutError: validators.transitional(validators.boolean)
                        },
                        false
                    );
                }

                // filter out skipped interceptors
                var requestInterceptorChain = [];
                var synchronousRequestInterceptors = true;
                this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
                    if (
                        typeof interceptor.runWhen === 'function' &&
                        interceptor.runWhen(config) === false
                    ) {
                        return;
                    }

                    synchronousRequestInterceptors =
                        synchronousRequestInterceptors && interceptor.synchronous;

                    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
                });

                var responseInterceptorChain = [];
                this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
                    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
                });

                var promise;

                if (!synchronousRequestInterceptors) {
                    var chain = [dispatchRequest, undefined];

                    Array.prototype.unshift.apply(chain, requestInterceptorChain);
                    chain = chain.concat(responseInterceptorChain);

                    promise = Promise.resolve(config);
                    while (chain.length) {
                        promise = promise.then(chain.shift(), chain.shift());
                    }

                    return promise;
                }

                var newConfig = config;
                while (requestInterceptorChain.length) {
                    var onFulfilled = requestInterceptorChain.shift();
                    var onRejected = requestInterceptorChain.shift();
                    try {
                        newConfig = onFulfilled(newConfig);
                    } catch (error) {
                        onRejected(error);
                        break;
                    }
                }

                try {
                    promise = dispatchRequest(newConfig);
                } catch (error) {
                    return Promise.reject(error);
                }

                while (responseInterceptorChain.length) {
                    promise = promise.then(
                        responseInterceptorChain.shift(),
                        responseInterceptorChain.shift()
                    );
                }

                return promise;
            };

            Axios.prototype.getUri = function getUri(config) {
                config = mergeConfig(this.defaults, config);
                var fullPath = buildFullPath(config.baseURL, config.url);
                return buildURL(fullPath, config.params, config.paramsSerializer);
            };

            // Provide aliases for supported request methods
            utils.forEach(
                ['delete', 'get', 'head', 'options'],
                function forEachMethodNoData(method) {
                    /*eslint func-names:0*/
                    Axios.prototype[method] = function (url, config) {
                        return this.request(
                            mergeConfig(config || {}, {
                                method: method,
                                url: url,
                                data: (config || {}).data
                            })
                        );
                    };
                }
            );

            utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
                /*eslint func-names:0*/

                function generateHTTPMethod(isForm) {
                    return function httpMethod(url, data, config) {
                        return this.request(
                            mergeConfig(config || {}, {
                                method: method,
                                headers: isForm
                                    ? {
                                          'Content-Type': 'multipart/form-data'
                                      }
                                    : {},
                                url: url,
                                data: data
                            })
                        );
                    };
                }

                Axios.prototype[method] = generateHTTPMethod();

                Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
            });

            module.exports = Axios;

            /***/
        },
        /* 82 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            function encode(val) {
                return encodeURIComponent(val)
                    .replace(/%3A/gi, ':')
                    .replace(/%24/g, '$')
                    .replace(/%2C/gi, ',')
                    .replace(/%20/g, '+')
                    .replace(/%5B/gi, '[')
                    .replace(/%5D/gi, ']');
            }

            /**
             * Build a URL by appending params to the end
             *
             * @param {string} url The base of the url (e.g., http://www.google.com)
             * @param {object} [params] The params to be appended
             * @returns {string} The formatted url
             */
            module.exports = function buildURL(url, params, paramsSerializer) {
                /*eslint no-param-reassign:0*/
                if (!params) {
                    return url;
                }

                var serializedParams;
                if (paramsSerializer) {
                    serializedParams = paramsSerializer(params);
                } else if (utils.isURLSearchParams(params)) {
                    serializedParams = params.toString();
                } else {
                    var parts = [];

                    utils.forEach(params, function serialize(val, key) {
                        if (val === null || typeof val === 'undefined') {
                            return;
                        }

                        if (utils.isArray(val)) {
                            key = key + '[]';
                        } else {
                            val = [val];
                        }

                        utils.forEach(val, function parseValue(v) {
                            if (utils.isDate(v)) {
                                v = v.toISOString();
                            } else if (utils.isObject(v)) {
                                v = JSON.stringify(v);
                            }
                            parts.push(encode(key) + '=' + encode(v));
                        });
                    });

                    serializedParams = parts.join('&');
                }

                if (serializedParams) {
                    var hashmarkIndex = url.indexOf('#');
                    if (hashmarkIndex !== -1) {
                        url = url.slice(0, hashmarkIndex);
                    }

                    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
                }

                return url;
            };

            /***/
        },
        /* 83 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            function InterceptorManager() {
                this.handlers = [];
            }

            /**
             * Add a new interceptor to the stack
             *
             * @param {Function} fulfilled The function to handle `then` for a `Promise`
             * @param {Function} rejected The function to handle `reject` for a `Promise`
             *
             * @return {Number} An ID used to remove interceptor later
             */
            InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
                this.handlers.push({
                    fulfilled: fulfilled,
                    rejected: rejected,
                    synchronous: options ? options.synchronous : false,
                    runWhen: options ? options.runWhen : null
                });
                return this.handlers.length - 1;
            };

            /**
             * Remove an interceptor from the stack
             *
             * @param {Number} id The ID that was returned by `use`
             */
            InterceptorManager.prototype.eject = function eject(id) {
                if (this.handlers[id]) {
                    this.handlers[id] = null;
                }
            };

            /**
             * Iterate over all the registered interceptors
             *
             * This method is particularly useful for skipping over any
             * interceptors that may have become `null` calling `eject`.
             *
             * @param {Function} fn The function to call for each interceptor
             */
            InterceptorManager.prototype.forEach = function forEach(fn) {
                utils.forEach(this.handlers, function forEachHandler(h) {
                    if (h !== null) {
                        fn(h);
                    }
                });
            };

            module.exports = InterceptorManager;

            /***/
        },
        /* 84 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);
            var transformData = __webpack_require__(85);
            var isCancel = __webpack_require__(136);
            var defaults = __webpack_require__(86);
            var CanceledError = __webpack_require__(99);

            /**
             * Throws a `CanceledError` if cancellation has been requested.
             */
            function throwIfCancellationRequested(config) {
                if (config.cancelToken) {
                    config.cancelToken.throwIfRequested();
                }

                if (config.signal && config.signal.aborted) {
                    throw new CanceledError();
                }
            }

            /**
             * Dispatch a request to the server using the configured adapter.
             *
             * @param {object} config The config that is to be used for the request
             * @returns {Promise} The Promise to be fulfilled
             */
            module.exports = function dispatchRequest(config) {
                throwIfCancellationRequested(config);

                // Ensure headers exist
                config.headers = config.headers || {};

                // Transform request data
                config.data = transformData.call(
                    config,
                    config.data,
                    config.headers,
                    config.transformRequest
                );

                // Flatten headers
                config.headers = utils.merge(
                    config.headers.common || {},
                    config.headers[config.method] || {},
                    config.headers
                );

                utils.forEach(
                    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
                    function cleanHeaderConfig(method) {
                        delete config.headers[method];
                    }
                );

                var adapter = config.adapter || defaults.adapter;

                return adapter(config).then(
                    function onAdapterResolution(response) {
                        throwIfCancellationRequested(config);

                        // Transform response data
                        response.data = transformData.call(
                            config,
                            response.data,
                            response.headers,
                            config.transformResponse
                        );

                        return response;
                    },
                    function onAdapterRejection(reason) {
                        if (!isCancel(reason)) {
                            throwIfCancellationRequested(config);

                            // Transform response data
                            if (reason && reason.response) {
                                reason.response.data = transformData.call(
                                    config,
                                    reason.response.data,
                                    reason.response.headers,
                                    config.transformResponse
                                );
                            }
                        }

                        return Promise.reject(reason);
                    }
                );
            };

            /***/
        },
        /* 85 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);
            var defaults = __webpack_require__(86);

            /**
             * Transform the data for a request or a response
             *
             * @param {Object|String} data The data to be transformed
             * @param {Array} headers The headers for the request or response
             * @param {Array|Function} fns A single function or Array of functions
             * @returns {*} The resulting transformed data
             */
            module.exports = function transformData(data, headers, fns) {
                var context = this || defaults;
                /*eslint no-param-reassign:0*/
                utils.forEach(fns, function transform(fn) {
                    data = fn.call(context, data, headers);
                });

                return data;
            };

            /***/
        },
        /* 86 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);
            var normalizeHeaderName = __webpack_require__(87);
            var AxiosError = __webpack_require__(88);
            var transitionalDefaults = __webpack_require__(89);
            var toFormData = __webpack_require__(90);

            var DEFAULT_CONTENT_TYPE = {
                'Content-Type': 'application/x-www-form-urlencoded'
            };

            function setContentTypeIfUnset(headers, value) {
                if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
                    headers['Content-Type'] = value;
                }
            }

            function getDefaultAdapter() {
                var adapter;
                if (typeof XMLHttpRequest !== 'undefined') {
                    // For browsers use XHR adapter
                    adapter = __webpack_require__(91);
                } else if (
                    typeof process !== 'undefined' &&
                    Object.prototype.toString.call(process) === '[object process]'
                ) {
                    // For node use HTTP adapter
                    adapter = __webpack_require__(101);
                }
                return adapter;
            }

            function stringifySafely(rawValue, parser, encoder) {
                if (utils.isString(rawValue)) {
                    try {
                        (parser || JSON.parse)(rawValue);
                        return utils.trim(rawValue);
                    } catch (e) {
                        if (e.name !== 'SyntaxError') {
                            throw e;
                        }
                    }
                }

                return (encoder || JSON.stringify)(rawValue);
            }

            var defaults = {
                transitional: transitionalDefaults,

                adapter: getDefaultAdapter(),

                transformRequest: [
                    function transformRequest(data, headers) {
                        normalizeHeaderName(headers, 'Accept');
                        normalizeHeaderName(headers, 'Content-Type');

                        if (
                            utils.isFormData(data) ||
                            utils.isArrayBuffer(data) ||
                            utils.isBuffer(data) ||
                            utils.isStream(data) ||
                            utils.isFile(data) ||
                            utils.isBlob(data)
                        ) {
                            return data;
                        }
                        if (utils.isArrayBufferView(data)) {
                            return data.buffer;
                        }
                        if (utils.isURLSearchParams(data)) {
                            setContentTypeIfUnset(
                                headers,
                                'application/x-www-form-urlencoded;charset=utf-8'
                            );
                            return data.toString();
                        }

                        var isObjectPayload = utils.isObject(data);
                        var contentType = headers && headers['Content-Type'];

                        var isFileList;

                        if (
                            (isFileList = utils.isFileList(data)) ||
                            (isObjectPayload && contentType === 'multipart/form-data')
                        ) {
                            var _FormData = this.env && this.env.FormData;
                            return toFormData(
                                isFileList ? { 'files[]': data } : data,
                                _FormData && new _FormData()
                            );
                        } else if (isObjectPayload || contentType === 'application/json') {
                            setContentTypeIfUnset(headers, 'application/json');
                            return stringifySafely(data);
                        }

                        return data;
                    }
                ],

                transformResponse: [
                    function transformResponse(data) {
                        var transitional = this.transitional || defaults.transitional;
                        var silentJSONParsing = transitional && transitional.silentJSONParsing;
                        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
                        var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

                        if (
                            strictJSONParsing ||
                            (forcedJSONParsing && utils.isString(data) && data.length)
                        ) {
                            try {
                                return JSON.parse(data);
                            } catch (e) {
                                if (strictJSONParsing) {
                                    if (e.name === 'SyntaxError') {
                                        throw AxiosError.from(
                                            e,
                                            AxiosError.ERR_BAD_RESPONSE,
                                            this,
                                            null,
                                            this.response
                                        );
                                    }
                                    throw e;
                                }
                            }
                        }

                        return data;
                    }
                ],

                /**
                 * A timeout in milliseconds to abort a request. If set to 0 (default) a
                 * timeout is not created.
                 */
                timeout: 0,

                xsrfCookieName: 'XSRF-TOKEN',
                xsrfHeaderName: 'X-XSRF-TOKEN',

                maxContentLength: -1,
                maxBodyLength: -1,

                env: {
                    FormData: __webpack_require__(118)
                },

                validateStatus: function validateStatus(status) {
                    return status >= 200 && status < 300;
                },

                headers: {
                    common: {
                        Accept: 'application/json, text/plain, */*'
                    }
                }
            };

            utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
                defaults.headers[method] = {};
            });

            utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
                defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
            });

            module.exports = defaults;

            /***/
        },
        /* 87 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            module.exports = function normalizeHeaderName(headers, normalizedName) {
                utils.forEach(headers, function processHeader(value, name) {
                    if (
                        name !== normalizedName &&
                        name.toUpperCase() === normalizedName.toUpperCase()
                    ) {
                        headers[normalizedName] = value;
                        delete headers[name];
                    }
                });
            };

            /***/
        },
        /* 88 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            /**
             * Create an Error with the specified message, config, error code, request and response.
             *
             * @param {string} message The error message.
             * @param {string} [code] The error code (for example, 'ECONNABORTED').
             * @param {Object} [config] The config.
             * @param {Object} [request] The request.
             * @param {Object} [response] The response.
             * @returns {Error} The created error.
             */
            function AxiosError(message, code, config, request, response) {
                Error.call(this);
                this.message = message;
                this.name = 'AxiosError';
                code && (this.code = code);
                config && (this.config = config);
                request && (this.request = request);
                response && (this.response = response);
            }

            utils.inherits(AxiosError, Error, {
                toJSON: function toJSON() {
                    return {
                        // Standard
                        message: this.message,
                        name: this.name,
                        // Microsoft
                        description: this.description,
                        number: this.number,
                        // Mozilla
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        // Axios
                        config: this.config,
                        code: this.code,
                        status: this.response && this.response.status ? this.response.status : null
                    };
                }
            });

            var prototype = AxiosError.prototype;
            var descriptors = {};

            [
                'ERR_BAD_OPTION_VALUE',
                'ERR_BAD_OPTION',
                'ECONNABORTED',
                'ETIMEDOUT',
                'ERR_NETWORK',
                'ERR_FR_TOO_MANY_REDIRECTS',
                'ERR_DEPRECATED',
                'ERR_BAD_RESPONSE',
                'ERR_BAD_REQUEST',
                'ERR_CANCELED'
                // eslint-disable-next-line func-names
            ].forEach(function (code) {
                descriptors[code] = { value: code };
            });

            Object.defineProperties(AxiosError, descriptors);
            Object.defineProperty(prototype, 'isAxiosError', { value: true });

            // eslint-disable-next-line func-names
            AxiosError.from = function (error, code, config, request, response, customProps) {
                var axiosError = Object.create(prototype);

                utils.toFlatObject(error, axiosError, function filter(obj) {
                    return obj !== Error.prototype;
                });

                AxiosError.call(axiosError, error.message, code, config, request, response);

                axiosError.name = error.name;

                customProps && Object.assign(axiosError, customProps);

                return axiosError;
            };

            module.exports = AxiosError;

            /***/
        },
        /* 89 */
        /***/ (module) => {
            'use strict';

            module.exports = {
                silentJSONParsing: true,
                forcedJSONParsing: true,
                clarifyTimeoutError: false
            };

            /***/
        },
        /* 90 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            /**
             * Convert a data object to FormData
             * @param {Object} obj
             * @param {?Object} [formData]
             * @returns {Object}
             **/

            function toFormData(obj, formData) {
                // eslint-disable-next-line no-param-reassign
                formData = formData || new FormData();

                var stack = [];

                function convertValue(value) {
                    if (value === null) return '';

                    if (utils.isDate(value)) {
                        return value.toISOString();
                    }

                    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
                        return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
                    }

                    return value;
                }

                function build(data, parentKey) {
                    if (utils.isPlainObject(data) || utils.isArray(data)) {
                        if (stack.indexOf(data) !== -1) {
                            throw Error('Circular reference detected in ' + parentKey);
                        }

                        stack.push(data);

                        utils.forEach(data, function each(value, key) {
                            if (utils.isUndefined(value)) return;
                            var fullKey = parentKey ? parentKey + '.' + key : key;
                            var arr;

                            if (value && !parentKey && typeof value === 'object') {
                                if (utils.endsWith(key, '{}')) {
                                    // eslint-disable-next-line no-param-reassign
                                    value = JSON.stringify(value);
                                } else if (
                                    utils.endsWith(key, '[]') &&
                                    (arr = utils.toArray(value))
                                ) {
                                    // eslint-disable-next-line func-names
                                    arr.forEach(function (el) {
                                        !utils.isUndefined(el) &&
                                            formData.append(fullKey, convertValue(el));
                                    });
                                    return;
                                }
                            }

                            build(value, fullKey);
                        });

                        stack.pop();
                    } else {
                        formData.append(parentKey, convertValue(data));
                    }
                }

                build(obj);

                return formData;
            }

            module.exports = toFormData;

            /***/
        },
        /* 91 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);
            var settle = __webpack_require__(92);
            var cookies = __webpack_require__(93);
            var buildURL = __webpack_require__(82);
            var buildFullPath = __webpack_require__(94);
            var parseHeaders = __webpack_require__(97);
            var isURLSameOrigin = __webpack_require__(98);
            var transitionalDefaults = __webpack_require__(89);
            var AxiosError = __webpack_require__(88);
            var CanceledError = __webpack_require__(99);
            var parseProtocol = __webpack_require__(100);

            module.exports = function xhrAdapter(config) {
                return new Promise(function dispatchXhrRequest(resolve, reject) {
                    var requestData = config.data;
                    var requestHeaders = config.headers;
                    var responseType = config.responseType;
                    var onCanceled;
                    function done() {
                        if (config.cancelToken) {
                            config.cancelToken.unsubscribe(onCanceled);
                        }

                        if (config.signal) {
                            config.signal.removeEventListener('abort', onCanceled);
                        }
                    }

                    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
                        delete requestHeaders['Content-Type']; // Let the browser set it
                    }

                    var request = new XMLHttpRequest();

                    // HTTP basic authentication
                    if (config.auth) {
                        var username = config.auth.username || '';
                        var password = config.auth.password
                            ? unescape(encodeURIComponent(config.auth.password))
                            : '';
                        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
                    }

                    var fullPath = buildFullPath(config.baseURL, config.url);

                    request.open(
                        config.method.toUpperCase(),
                        buildURL(fullPath, config.params, config.paramsSerializer),
                        true
                    );

                    // Set the request timeout in MS
                    request.timeout = config.timeout;

                    function onloadend() {
                        if (!request) {
                            return;
                        }
                        // Prepare the response
                        var responseHeaders =
                            'getAllResponseHeaders' in request
                                ? parseHeaders(request.getAllResponseHeaders())
                                : null;
                        var responseData =
                            !responseType || responseType === 'text' || responseType === 'json'
                                ? request.responseText
                                : request.response;
                        var response = {
                            data: responseData,
                            status: request.status,
                            statusText: request.statusText,
                            headers: responseHeaders,
                            config: config,
                            request: request
                        };

                        settle(
                            function _resolve(value) {
                                resolve(value);
                                done();
                            },
                            function _reject(err) {
                                reject(err);
                                done();
                            },
                            response
                        );

                        // Clean up request
                        request = null;
                    }

                    if ('onloadend' in request) {
                        // Use onloadend if available
                        request.onloadend = onloadend;
                    } else {
                        // Listen for ready state to emulate onloadend
                        request.onreadystatechange = function handleLoad() {
                            if (!request || request.readyState !== 4) {
                                return;
                            }

                            // The request errored out and we didn't get a response, this will be
                            // handled by onerror instead
                            // With one exception: request that using file: protocol, most browsers
                            // will return status as 0 even though it's a successful request
                            if (
                                request.status === 0 &&
                                !(request.responseURL && request.responseURL.indexOf('file:') === 0)
                            ) {
                                return;
                            }
                            // readystate handler is calling before onerror or ontimeout handlers,
                            // so we should call onloadend on the next 'tick'
                            setTimeout(onloadend);
                        };
                    }

                    // Handle browser request cancellation (as opposed to a manual cancellation)
                    request.onabort = function handleAbort() {
                        if (!request) {
                            return;
                        }

                        reject(
                            new AxiosError(
                                'Request aborted',
                                AxiosError.ECONNABORTED,
                                config,
                                request
                            )
                        );

                        // Clean up request
                        request = null;
                    };

                    // Handle low level network errors
                    request.onerror = function handleError() {
                        // Real errors are hidden from us by the browser
                        // onerror should only fire if it's a network error
                        reject(
                            new AxiosError(
                                'Network Error',
                                AxiosError.ERR_NETWORK,
                                config,
                                request,
                                request
                            )
                        );

                        // Clean up request
                        request = null;
                    };

                    // Handle timeout
                    request.ontimeout = function handleTimeout() {
                        var timeoutErrorMessage = config.timeout
                            ? 'timeout of ' + config.timeout + 'ms exceeded'
                            : 'timeout exceeded';
                        var transitional = config.transitional || transitionalDefaults;
                        if (config.timeoutErrorMessage) {
                            timeoutErrorMessage = config.timeoutErrorMessage;
                        }
                        reject(
                            new AxiosError(
                                timeoutErrorMessage,
                                transitional.clarifyTimeoutError
                                    ? AxiosError.ETIMEDOUT
                                    : AxiosError.ECONNABORTED,
                                config,
                                request
                            )
                        );

                        // Clean up request
                        request = null;
                    };

                    // Add xsrf header
                    // This is only done if running in a standard browser environment.
                    // Specifically not if we're in a web worker, or react-native.
                    if (utils.isStandardBrowserEnv()) {
                        // Add xsrf header
                        var xsrfValue =
                            (config.withCredentials || isURLSameOrigin(fullPath)) &&
                            config.xsrfCookieName
                                ? cookies.read(config.xsrfCookieName)
                                : undefined;

                        if (xsrfValue) {
                            requestHeaders[config.xsrfHeaderName] = xsrfValue;
                        }
                    }

                    // Add headers to the request
                    if ('setRequestHeader' in request) {
                        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                            if (
                                typeof requestData === 'undefined' &&
                                key.toLowerCase() === 'content-type'
                            ) {
                                // Remove Content-Type if data is undefined
                                delete requestHeaders[key];
                            } else {
                                // Otherwise add header to the request
                                request.setRequestHeader(key, val);
                            }
                        });
                    }

                    // Add withCredentials to request if needed
                    if (!utils.isUndefined(config.withCredentials)) {
                        request.withCredentials = !!config.withCredentials;
                    }

                    // Add responseType to request if needed
                    if (responseType && responseType !== 'json') {
                        request.responseType = config.responseType;
                    }

                    // Handle progress if needed
                    if (typeof config.onDownloadProgress === 'function') {
                        request.addEventListener('progress', config.onDownloadProgress);
                    }

                    // Not all browsers support upload events
                    if (typeof config.onUploadProgress === 'function' && request.upload) {
                        request.upload.addEventListener('progress', config.onUploadProgress);
                    }

                    if (config.cancelToken || config.signal) {
                        // Handle cancellation
                        // eslint-disable-next-line func-names
                        onCanceled = function (cancel) {
                            if (!request) {
                                return;
                            }
                            reject(
                                !cancel || (cancel && cancel.type) ? new CanceledError() : cancel
                            );
                            request.abort();
                            request = null;
                        };

                        config.cancelToken && config.cancelToken.subscribe(onCanceled);
                        if (config.signal) {
                            config.signal.aborted
                                ? onCanceled()
                                : config.signal.addEventListener('abort', onCanceled);
                        }
                    }

                    if (!requestData) {
                        requestData = null;
                    }

                    var protocol = parseProtocol(fullPath);

                    if (protocol && ['http', 'https', 'file'].indexOf(protocol) === -1) {
                        reject(
                            new AxiosError(
                                'Unsupported protocol ' + protocol + ':',
                                AxiosError.ERR_BAD_REQUEST,
                                config
                            )
                        );
                        return;
                    }

                    // Send the request
                    request.send(requestData);
                });
            };

            /***/
        },
        /* 92 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var AxiosError = __webpack_require__(88);

            /**
             * Resolve or reject a Promise based on response status.
             *
             * @param {Function} resolve A function that resolves the promise.
             * @param {Function} reject A function that rejects the promise.
             * @param {object} response The response.
             */
            module.exports = function settle(resolve, reject, response) {
                var validateStatus = response.config.validateStatus;
                if (!response.status || !validateStatus || validateStatus(response.status)) {
                    resolve(response);
                } else {
                    reject(
                        new AxiosError(
                            'Request failed with status code ' + response.status,
                            [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][
                                Math.floor(response.status / 100) - 4
                            ],
                            response.config,
                            response.request,
                            response
                        )
                    );
                }
            };

            /***/
        },
        /* 93 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            module.exports = utils.isStandardBrowserEnv()
                ? // Standard browser envs support document.cookie
                  (function standardBrowserEnv() {
                      return {
                          write: function write(name, value, expires, path, domain, secure) {
                              var cookie = [];
                              cookie.push(name + '=' + encodeURIComponent(value));

                              if (utils.isNumber(expires)) {
                                  cookie.push('expires=' + new Date(expires).toGMTString());
                              }

                              if (utils.isString(path)) {
                                  cookie.push('path=' + path);
                              }

                              if (utils.isString(domain)) {
                                  cookie.push('domain=' + domain);
                              }

                              if (secure === true) {
                                  cookie.push('secure');
                              }

                              document.cookie = cookie.join('; ');
                          },

                          read: function read(name) {
                              var match = document.cookie.match(
                                  new RegExp('(^|;\\s*)(' + name + ')=([^;]*)')
                              );
                              return match ? decodeURIComponent(match[3]) : null;
                          },

                          remove: function remove(name) {
                              this.write(name, '', Date.now() - 86400000);
                          }
                      };
                  })()
                : // Non standard browser env (web workers, react-native) lack needed support.
                  (function nonStandardBrowserEnv() {
                      return {
                          write: function write() {},
                          read: function read() {
                              return null;
                          },
                          remove: function remove() {}
                      };
                  })();

            /***/
        },
        /* 94 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var isAbsoluteURL = __webpack_require__(95);
            var combineURLs = __webpack_require__(96);

            /**
             * Creates a new URL by combining the baseURL with the requestedURL,
             * only when the requestedURL is not already an absolute URL.
             * If the requestURL is absolute, this function returns the requestedURL untouched.
             *
             * @param {string} baseURL The base URL
             * @param {string} requestedURL Absolute or relative URL to combine
             * @returns {string} The combined full path
             */
            module.exports = function buildFullPath(baseURL, requestedURL) {
                if (baseURL && !isAbsoluteURL(requestedURL)) {
                    return combineURLs(baseURL, requestedURL);
                }
                return requestedURL;
            };

            /***/
        },
        /* 95 */
        /***/ (module) => {
            'use strict';

            /**
             * Determines whether the specified URL is absolute
             *
             * @param {string} url The URL to test
             * @returns {boolean} True if the specified URL is absolute, otherwise false
             */
            module.exports = function isAbsoluteURL(url) {
                // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
                // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
                // by any combination of letters, digits, plus, period, or hyphen.
                return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
            };

            /***/
        },
        /* 96 */
        /***/ (module) => {
            'use strict';

            /**
             * Creates a new URL by combining the specified URLs
             *
             * @param {string} baseURL The base URL
             * @param {string} relativeURL The relative URL
             * @returns {string} The combined URL
             */
            module.exports = function combineURLs(baseURL, relativeURL) {
                return relativeURL
                    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
                    : baseURL;
            };

            /***/
        },
        /* 97 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            // Headers whose duplicates are ignored by node
            // c.f. https://nodejs.org/api/http.html#http_message_headers
            var ignoreDuplicateOf = [
                'age',
                'authorization',
                'content-length',
                'content-type',
                'etag',
                'expires',
                'from',
                'host',
                'if-modified-since',
                'if-unmodified-since',
                'last-modified',
                'location',
                'max-forwards',
                'proxy-authorization',
                'referer',
                'retry-after',
                'user-agent'
            ];

            /**
             * Parse headers into an object
             *
             * ```
             * Date: Wed, 27 Aug 2014 08:58:49 GMT
             * Content-Type: application/json
             * Connection: keep-alive
             * Transfer-Encoding: chunked
             * ```
             *
             * @param {String} headers Headers needing to be parsed
             * @returns {Object} Headers parsed into an object
             */
            module.exports = function parseHeaders(headers) {
                var parsed = {};
                var key;
                var val;
                var i;

                if (!headers) {
                    return parsed;
                }

                utils.forEach(headers.split('\n'), function parser(line) {
                    i = line.indexOf(':');
                    key = utils.trim(line.substr(0, i)).toLowerCase();
                    val = utils.trim(line.substr(i + 1));

                    if (key) {
                        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                            return;
                        }
                        if (key === 'set-cookie') {
                            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
                        } else {
                            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
                        }
                    }
                });

                return parsed;
            };

            /***/
        },
        /* 98 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            module.exports = utils.isStandardBrowserEnv()
                ? // Standard browser envs have full support of the APIs needed to test
                  // whether the request URL is of the same origin as current location.
                  (function standardBrowserEnv() {
                      var msie = /(msie|trident)/i.test(navigator.userAgent);
                      var urlParsingNode = document.createElement('a');
                      var originURL;

                      /**
                       * Parse a URL to discover it's components
                       *
                       * @param {String} url The URL to be parsed
                       * @returns {Object}
                       */
                      function resolveURL(url) {
                          var href = url;

                          if (msie) {
                              // IE needs attribute set twice to normalize properties
                              urlParsingNode.setAttribute('href', href);
                              href = urlParsingNode.href;
                          }

                          urlParsingNode.setAttribute('href', href);

                          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
                          return {
                              href: urlParsingNode.href,
                              protocol: urlParsingNode.protocol
                                  ? urlParsingNode.protocol.replace(/:$/, '')
                                  : '',
                              host: urlParsingNode.host,
                              search: urlParsingNode.search
                                  ? urlParsingNode.search.replace(/^\?/, '')
                                  : '',
                              hash: urlParsingNode.hash
                                  ? urlParsingNode.hash.replace(/^#/, '')
                                  : '',
                              hostname: urlParsingNode.hostname,
                              port: urlParsingNode.port,
                              pathname:
                                  urlParsingNode.pathname.charAt(0) === '/'
                                      ? urlParsingNode.pathname
                                      : '/' + urlParsingNode.pathname
                          };
                      }

                      originURL = resolveURL(window.location.href);

                      /**
                       * Determine if a URL shares the same origin as the current location
                       *
                       * @param {String} requestURL The URL to test
                       * @returns {boolean} True if URL shares the same origin, otherwise false
                       */
                      return function isURLSameOrigin(requestURL) {
                          var parsed = utils.isString(requestURL)
                              ? resolveURL(requestURL)
                              : requestURL;
                          return (
                              parsed.protocol === originURL.protocol &&
                              parsed.host === originURL.host
                          );
                      };
                  })()
                : // Non standard browser envs (web workers, react-native) lack needed support.
                  (function nonStandardBrowserEnv() {
                      return function isURLSameOrigin() {
                          return true;
                      };
                  })();

            /***/
        },
        /* 99 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var AxiosError = __webpack_require__(88);
            var utils = __webpack_require__(79);

            /**
             * A `CanceledError` is an object that is thrown when an operation is canceled.
             *
             * @class
             * @param {string=} message The message.
             */
            function CanceledError(message) {
                // eslint-disable-next-line no-eq-null,eqeqeq
                AxiosError.call(
                    this,
                    message == null ? 'canceled' : message,
                    AxiosError.ERR_CANCELED
                );
                this.name = 'CanceledError';
            }

            utils.inherits(CanceledError, AxiosError, {
                __CANCEL__: true
            });

            module.exports = CanceledError;

            /***/
        },
        /* 100 */
        /***/ (module) => {
            'use strict';

            module.exports = function parseProtocol(url) {
                var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
                return (match && match[1]) || '';
            };

            /***/
        },
        /* 101 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);
            var settle = __webpack_require__(92);
            var buildFullPath = __webpack_require__(94);
            var buildURL = __webpack_require__(82);
            var http = __webpack_require__(102);
            var https = __webpack_require__(103);
            var httpFollow = __webpack_require__(104).http;
            var httpsFollow = __webpack_require__(104).https;
            var url = __webpack_require__(105);
            var zlib = __webpack_require__(116);
            var VERSION = __webpack_require__(117).version;
            var transitionalDefaults = __webpack_require__(89);
            var AxiosError = __webpack_require__(88);
            var CanceledError = __webpack_require__(99);

            var isHttps = /https:?/;

            var supportedProtocols = ['http:', 'https:', 'file:'];

            /**
             *
             * @param {http.ClientRequestArgs} options
             * @param {AxiosProxyConfig} proxy
             * @param {string} location
             */
            function setProxy(options, proxy, location) {
                options.hostname = proxy.host;
                options.host = proxy.host;
                options.port = proxy.port;
                options.path = location;

                // Basic proxy authorization
                if (proxy.auth) {
                    var base64 = Buffer.from(
                        proxy.auth.username + ':' + proxy.auth.password,
                        'utf8'
                    ).toString('base64');
                    options.headers['Proxy-Authorization'] = 'Basic ' + base64;
                }

                // If a proxy is used, any redirects must also pass through the proxy
                options.beforeRedirect = function beforeRedirect(redirection) {
                    redirection.headers.host = redirection.host;
                    setProxy(redirection, proxy, redirection.href);
                };
            }

            /*eslint consistent-return:0*/
            module.exports = function httpAdapter(config) {
                return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
                    var onCanceled;
                    function done() {
                        if (config.cancelToken) {
                            config.cancelToken.unsubscribe(onCanceled);
                        }

                        if (config.signal) {
                            config.signal.removeEventListener('abort', onCanceled);
                        }
                    }
                    var resolve = function resolve(value) {
                        done();
                        resolvePromise(value);
                    };
                    var rejected = false;
                    var reject = function reject(value) {
                        done();
                        rejected = true;
                        rejectPromise(value);
                    };
                    var data = config.data;
                    var headers = config.headers;
                    var headerNames = {};

                    Object.keys(headers).forEach(function storeLowerName(name) {
                        headerNames[name.toLowerCase()] = name;
                    });

                    // Set User-Agent (required by some servers)
                    // See https://github.com/axios/axios/issues/69
                    if ('user-agent' in headerNames) {
                        // User-Agent is specified; handle case where no UA header is desired
                        if (!headers[headerNames['user-agent']]) {
                            delete headers[headerNames['user-agent']];
                        }
                        // Otherwise, use specified value
                    } else {
                        // Only set header if it hasn't been set in config
                        headers['User-Agent'] = 'axios/' + VERSION;
                    }

                    // support for https://www.npmjs.com/package/form-data api
                    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
                        Object.assign(headers, data.getHeaders());
                    } else if (data && !utils.isStream(data)) {
                        if (Buffer.isBuffer(data)) {
                            // Nothing to do...
                        } else if (utils.isArrayBuffer(data)) {
                            data = Buffer.from(new Uint8Array(data));
                        } else if (utils.isString(data)) {
                            data = Buffer.from(data, 'utf-8');
                        } else {
                            return reject(
                                new AxiosError(
                                    'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
                                    AxiosError.ERR_BAD_REQUEST,
                                    config
                                )
                            );
                        }

                        if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
                            return reject(
                                new AxiosError(
                                    'Request body larger than maxBodyLength limit',
                                    AxiosError.ERR_BAD_REQUEST,
                                    config
                                )
                            );
                        }

                        // Add Content-Length header if data exists
                        if (!headerNames['content-length']) {
                            headers['Content-Length'] = data.length;
                        }
                    }

                    // HTTP basic authentication
                    var auth = undefined;
                    if (config.auth) {
                        var username = config.auth.username || '';
                        var password = config.auth.password || '';
                        auth = username + ':' + password;
                    }

                    // Parse url
                    var fullPath = buildFullPath(config.baseURL, config.url);
                    var parsed = url.parse(fullPath);
                    var protocol = parsed.protocol || supportedProtocols[0];

                    if (supportedProtocols.indexOf(protocol) === -1) {
                        return reject(
                            new AxiosError(
                                'Unsupported protocol ' + protocol,
                                AxiosError.ERR_BAD_REQUEST,
                                config
                            )
                        );
                    }

                    if (!auth && parsed.auth) {
                        var urlAuth = parsed.auth.split(':');
                        var urlUsername = urlAuth[0] || '';
                        var urlPassword = urlAuth[1] || '';
                        auth = urlUsername + ':' + urlPassword;
                    }

                    if (auth && headerNames.authorization) {
                        delete headers[headerNames.authorization];
                    }

                    var isHttpsRequest = isHttps.test(protocol);
                    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

                    try {
                        buildURL(parsed.path, config.params, config.paramsSerializer).replace(
                            /^\?/,
                            ''
                        );
                    } catch (err) {
                        var customErr = new Error(err.message);
                        customErr.config = config;
                        customErr.url = config.url;
                        customErr.exists = true;
                        reject(customErr);
                    }

                    var options = {
                        path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(
                            /^\?/,
                            ''
                        ),
                        method: config.method.toUpperCase(),
                        headers: headers,
                        agent: agent,
                        agents: { http: config.httpAgent, https: config.httpsAgent },
                        auth: auth
                    };

                    if (config.socketPath) {
                        options.socketPath = config.socketPath;
                    } else {
                        options.hostname = parsed.hostname;
                        options.port = parsed.port;
                    }

                    var proxy = config.proxy;
                    if (!proxy && proxy !== false) {
                        var proxyEnv = protocol.slice(0, -1) + '_proxy';
                        var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
                        if (proxyUrl) {
                            var parsedProxyUrl = url.parse(proxyUrl);
                            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
                            var shouldProxy = true;

                            if (noProxyEnv) {
                                var noProxy = noProxyEnv.split(',').map(function trim(s) {
                                    return s.trim();
                                });

                                shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                                    if (!proxyElement) {
                                        return false;
                                    }
                                    if (proxyElement === '*') {
                                        return true;
                                    }
                                    if (
                                        proxyElement[0] === '.' &&
                                        parsed.hostname.substr(
                                            parsed.hostname.length - proxyElement.length
                                        ) === proxyElement
                                    ) {
                                        return true;
                                    }

                                    return parsed.hostname === proxyElement;
                                });
                            }

                            if (shouldProxy) {
                                proxy = {
                                    host: parsedProxyUrl.hostname,
                                    port: parsedProxyUrl.port,
                                    protocol: parsedProxyUrl.protocol
                                };

                                if (parsedProxyUrl.auth) {
                                    var proxyUrlAuth = parsedProxyUrl.auth.split(':');
                                    proxy.auth = {
                                        username: proxyUrlAuth[0],
                                        password: proxyUrlAuth[1]
                                    };
                                }
                            }
                        }
                    }

                    if (proxy) {
                        options.headers.host =
                            parsed.hostname + (parsed.port ? ':' + parsed.port : '');
                        setProxy(
                            options,
                            proxy,
                            protocol +
                                '//' +
                                parsed.hostname +
                                (parsed.port ? ':' + parsed.port : '') +
                                options.path
                        );
                    }

                    var transport;
                    var isHttpsProxy =
                        isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
                    if (config.transport) {
                        transport = config.transport;
                    } else if (config.maxRedirects === 0) {
                        transport = isHttpsProxy ? https : http;
                    } else {
                        if (config.maxRedirects) {
                            options.maxRedirects = config.maxRedirects;
                        }
                        if (config.beforeRedirect) {
                            options.beforeRedirect = config.beforeRedirect;
                        }
                        transport = isHttpsProxy ? httpsFollow : httpFollow;
                    }

                    if (config.maxBodyLength > -1) {
                        options.maxBodyLength = config.maxBodyLength;
                    }

                    if (config.insecureHTTPParser) {
                        options.insecureHTTPParser = config.insecureHTTPParser;
                    }

                    // Create the request
                    var req = transport.request(options, function handleResponse(res) {
                        if (req.aborted) return;

                        // uncompress the response body transparently if required
                        var stream = res;

                        // return the last request in case of redirects
                        var lastRequest = res.req || req;

                        // if no content, is HEAD request or decompress disabled we should not decompress
                        if (
                            res.statusCode !== 204 &&
                            lastRequest.method !== 'HEAD' &&
                            config.decompress !== false
                        ) {
                            switch (res.headers['content-encoding']) {
                                /*eslint default-case:0*/
                                case 'gzip':
                                case 'compress':
                                case 'deflate':
                                    // add the unzipper to the body stream processing pipeline
                                    stream = stream.pipe(zlib.createUnzip());

                                    // remove the content-encoding in order to not confuse downstream operations
                                    delete res.headers['content-encoding'];
                                    break;
                            }
                        }

                        var response = {
                            status: res.statusCode,
                            statusText: res.statusMessage,
                            headers: res.headers,
                            config: config,
                            request: lastRequest
                        };

                        if (config.responseType === 'stream') {
                            response.data = stream;
                            settle(resolve, reject, response);
                        } else {
                            var responseBuffer = [];
                            var totalResponseBytes = 0;
                            stream.on('data', function handleStreamData(chunk) {
                                responseBuffer.push(chunk);
                                totalResponseBytes += chunk.length;

                                // make sure the content length is not over the maxContentLength if specified
                                if (
                                    config.maxContentLength > -1 &&
                                    totalResponseBytes > config.maxContentLength
                                ) {
                                    // stream.destoy() emit aborted event before calling reject() on Node.js v16
                                    rejected = true;
                                    stream.destroy();
                                    reject(
                                        new AxiosError(
                                            'maxContentLength size of ' +
                                                config.maxContentLength +
                                                ' exceeded',
                                            AxiosError.ERR_BAD_RESPONSE,
                                            config,
                                            lastRequest
                                        )
                                    );
                                }
                            });

                            stream.on('aborted', function handlerStreamAborted() {
                                if (rejected) {
                                    return;
                                }
                                stream.destroy();
                                reject(
                                    new AxiosError(
                                        'maxContentLength size of ' +
                                            config.maxContentLength +
                                            ' exceeded',
                                        AxiosError.ERR_BAD_RESPONSE,
                                        config,
                                        lastRequest
                                    )
                                );
                            });

                            stream.on('error', function handleStreamError(err) {
                                if (req.aborted) return;
                                reject(AxiosError.from(err, null, config, lastRequest));
                            });

                            stream.on('end', function handleStreamEnd() {
                                try {
                                    var responseData =
                                        responseBuffer.length === 1
                                            ? responseBuffer[0]
                                            : Buffer.concat(responseBuffer);
                                    if (config.responseType !== 'arraybuffer') {
                                        responseData = responseData.toString(
                                            config.responseEncoding
                                        );
                                        if (
                                            !config.responseEncoding ||
                                            config.responseEncoding === 'utf8'
                                        ) {
                                            responseData = utils.stripBOM(responseData);
                                        }
                                    }
                                    response.data = responseData;
                                } catch (err) {
                                    reject(
                                        AxiosError.from(
                                            err,
                                            null,
                                            config,
                                            response.request,
                                            response
                                        )
                                    );
                                }
                                settle(resolve, reject, response);
                            });
                        }
                    });

                    // Handle errors
                    req.on('error', function handleRequestError(err) {
                        // @todo remove
                        // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
                        reject(AxiosError.from(err, null, config, req));
                    });

                    // set tcp keep alive to prevent drop connection by peer
                    req.on('socket', function handleRequestSocket(socket) {
                        // default interval of sending ack packet is 1 minute
                        socket.setKeepAlive(true, 1000 * 60);
                    });

                    // Handle request timeout
                    if (config.timeout) {
                        // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
                        var timeout = parseInt(config.timeout, 10);

                        if (isNaN(timeout)) {
                            reject(
                                new AxiosError(
                                    'error trying to parse `config.timeout` to int',
                                    AxiosError.ERR_BAD_OPTION_VALUE,
                                    config,
                                    req
                                )
                            );

                            return;
                        }

                        // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
                        // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
                        // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
                        // And then these socket which be hang up will devoring CPU little by little.
                        // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
                        req.setTimeout(timeout, function handleRequestTimeout() {
                            req.abort();
                            var transitional = config.transitional || transitionalDefaults;
                            reject(
                                new AxiosError(
                                    'timeout of ' + timeout + 'ms exceeded',
                                    transitional.clarifyTimeoutError
                                        ? AxiosError.ETIMEDOUT
                                        : AxiosError.ECONNABORTED,
                                    config,
                                    req
                                )
                            );
                        });
                    }

                    if (config.cancelToken || config.signal) {
                        // Handle cancellation
                        // eslint-disable-next-line func-names
                        onCanceled = function (cancel) {
                            if (req.aborted) return;

                            req.abort();
                            reject(
                                !cancel || (cancel && cancel.type) ? new CanceledError() : cancel
                            );
                        };

                        config.cancelToken && config.cancelToken.subscribe(onCanceled);
                        if (config.signal) {
                            config.signal.aborted
                                ? onCanceled()
                                : config.signal.addEventListener('abort', onCanceled);
                        }
                    }

                    // Send the request
                    if (utils.isStream(data)) {
                        data.on('error', function handleStreamError(err) {
                            reject(AxiosError.from(err, config, null, req));
                        }).pipe(req);
                    } else {
                        req.end(data);
                    }
                });
            };

            /***/
        },
        /* 102 */
        /***/ (module) => {
            'use strict';
            module.exports = require('http');

            /***/
        },
        /* 103 */
        /***/ (module) => {
            'use strict';
            module.exports = require('https');

            /***/
        },
        /* 104 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var url = __webpack_require__(105);
            var URL = url.URL;
            var http = __webpack_require__(102);
            var https = __webpack_require__(103);
            var Writable = __webpack_require__(14).Writable;
            var assert = __webpack_require__(17);
            var debug = __webpack_require__(106);

            // Create handlers that pass events from native requests
            var events = ['abort', 'aborted', 'connect', 'error', 'socket', 'timeout'];
            var eventHandlers = Object.create(null);
            events.forEach(function (event) {
                eventHandlers[event] = function (arg1, arg2, arg3) {
                    this._redirectable.emit(event, arg1, arg2, arg3);
                };
            });

            // Error types with codes
            var RedirectionError = createErrorType(
                'ERR_FR_REDIRECTION_FAILURE',
                'Redirected request failed'
            );
            var TooManyRedirectsError = createErrorType(
                'ERR_FR_TOO_MANY_REDIRECTS',
                'Maximum number of redirects exceeded'
            );
            var MaxBodyLengthExceededError = createErrorType(
                'ERR_FR_MAX_BODY_LENGTH_EXCEEDED',
                'Request body larger than maxBodyLength limit'
            );
            var WriteAfterEndError = createErrorType(
                'ERR_STREAM_WRITE_AFTER_END',
                'write after end'
            );

            // An HTTP(S) request that can be redirected
            function RedirectableRequest(options, responseCallback) {
                // Initialize the request
                Writable.call(this);
                this._sanitizeOptions(options);
                this._options = options;
                this._ended = false;
                this._ending = false;
                this._redirectCount = 0;
                this._redirects = [];
                this._requestBodyLength = 0;
                this._requestBodyBuffers = [];

                // Attach a callback if passed
                if (responseCallback) {
                    this.on('response', responseCallback);
                }

                // React to responses of native requests
                var self = this;
                this._onNativeResponse = function (response) {
                    self._processResponse(response);
                };

                // Perform the first request
                this._performRequest();
            }
            RedirectableRequest.prototype = Object.create(Writable.prototype);

            RedirectableRequest.prototype.abort = function () {
                abortRequest(this._currentRequest);
                this.emit('abort');
            };

            // Writes buffered data to the current native request
            RedirectableRequest.prototype.write = function (data, encoding, callback) {
                // Writing is not allowed if end has been called
                if (this._ending) {
                    throw new WriteAfterEndError();
                }

                // Validate input and shift parameters if necessary
                if (!(typeof data === 'string' || (typeof data === 'object' && 'length' in data))) {
                    throw new TypeError('data should be a string, Buffer or Uint8Array');
                }
                if (typeof encoding === 'function') {
                    callback = encoding;
                    encoding = null;
                }

                // Ignore empty buffers, since writing them doesn't invoke the callback
                // https://github.com/nodejs/node/issues/22066
                if (data.length === 0) {
                    if (callback) {
                        callback();
                    }
                    return;
                }
                // Only write when we don't exceed the maximum body length
                if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
                    this._requestBodyLength += data.length;
                    this._requestBodyBuffers.push({ data: data, encoding: encoding });
                    this._currentRequest.write(data, encoding, callback);
                }
                // Error when we exceed the maximum body length
                else {
                    this.emit('error', new MaxBodyLengthExceededError());
                    this.abort();
                }
            };

            // Ends the current native request
            RedirectableRequest.prototype.end = function (data, encoding, callback) {
                // Shift parameters if necessary
                if (typeof data === 'function') {
                    callback = data;
                    data = encoding = null;
                } else if (typeof encoding === 'function') {
                    callback = encoding;
                    encoding = null;
                }

                // Write data if needed and end
                if (!data) {
                    this._ended = this._ending = true;
                    this._currentRequest.end(null, null, callback);
                } else {
                    var self = this;
                    var currentRequest = this._currentRequest;
                    this.write(data, encoding, function () {
                        self._ended = true;
                        currentRequest.end(null, null, callback);
                    });
                    this._ending = true;
                }
            };

            // Sets a header value on the current native request
            RedirectableRequest.prototype.setHeader = function (name, value) {
                this._options.headers[name] = value;
                this._currentRequest.setHeader(name, value);
            };

            // Clears a header value on the current native request
            RedirectableRequest.prototype.removeHeader = function (name) {
                delete this._options.headers[name];
                this._currentRequest.removeHeader(name);
            };

            // Global timeout for all underlying requests
            RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
                var self = this;

                // Destroys the socket on timeout
                function destroyOnTimeout(socket) {
                    socket.setTimeout(msecs);
                    socket.removeListener('timeout', socket.destroy);
                    socket.addListener('timeout', socket.destroy);
                }

                // Sets up a timer to trigger a timeout event
                function startTimer(socket) {
                    if (self._timeout) {
                        clearTimeout(self._timeout);
                    }
                    self._timeout = setTimeout(function () {
                        self.emit('timeout');
                        clearTimer();
                    }, msecs);
                    destroyOnTimeout(socket);
                }

                // Stops a timeout from triggering
                function clearTimer() {
                    // Clear the timeout
                    if (self._timeout) {
                        clearTimeout(self._timeout);
                        self._timeout = null;
                    }

                    // Clean up all attached listeners
                    self.removeListener('abort', clearTimer);
                    self.removeListener('error', clearTimer);
                    self.removeListener('response', clearTimer);
                    if (callback) {
                        self.removeListener('timeout', callback);
                    }
                    if (!self.socket) {
                        self._currentRequest.removeListener('socket', startTimer);
                    }
                }

                // Attach callback if passed
                if (callback) {
                    this.on('timeout', callback);
                }

                // Start the timer if or when the socket is opened
                if (this.socket) {
                    startTimer(this.socket);
                } else {
                    this._currentRequest.once('socket', startTimer);
                }

                // Clean up on events
                this.on('socket', destroyOnTimeout);
                this.on('abort', clearTimer);
                this.on('error', clearTimer);
                this.on('response', clearTimer);

                return this;
            };

            // Proxy all other public ClientRequest methods
            ['flushHeaders', 'getHeader', 'setNoDelay', 'setSocketKeepAlive'].forEach(function (
                method
            ) {
                RedirectableRequest.prototype[method] = function (a, b) {
                    return this._currentRequest[method](a, b);
                };
            });

            // Proxy all public ClientRequest properties
            ['aborted', 'connection', 'socket'].forEach(function (property) {
                Object.defineProperty(RedirectableRequest.prototype, property, {
                    get: function () {
                        return this._currentRequest[property];
                    }
                });
            });

            RedirectableRequest.prototype._sanitizeOptions = function (options) {
                // Ensure headers are always present
                if (!options.headers) {
                    options.headers = {};
                }

                // Since http.request treats host as an alias of hostname,
                // but the url module interprets host as hostname plus port,
                // eliminate the host property to avoid confusion.
                if (options.host) {
                    // Use hostname if set, because it has precedence
                    if (!options.hostname) {
                        options.hostname = options.host;
                    }
                    delete options.host;
                }

                // Complete the URL object when necessary
                if (!options.pathname && options.path) {
                    var searchPos = options.path.indexOf('?');
                    if (searchPos < 0) {
                        options.pathname = options.path;
                    } else {
                        options.pathname = options.path.substring(0, searchPos);
                        options.search = options.path.substring(searchPos);
                    }
                }
            };

            // Executes the next native request (initial or redirect)
            RedirectableRequest.prototype._performRequest = function () {
                // Load the native protocol
                var protocol = this._options.protocol;
                var nativeProtocol = this._options.nativeProtocols[protocol];
                if (!nativeProtocol) {
                    this.emit('error', new TypeError('Unsupported protocol ' + protocol));
                    return;
                }

                // If specified, use the agent corresponding to the protocol
                // (HTTP and HTTPS use different types of agents)
                if (this._options.agents) {
                    var scheme = protocol.slice(0, -1);
                    this._options.agent = this._options.agents[scheme];
                }

                // Create the native request and set up its event handlers
                var request = (this._currentRequest = nativeProtocol.request(
                    this._options,
                    this._onNativeResponse
                ));
                request._redirectable = this;
                for (var event of events) {
                    request.on(event, eventHandlers[event]);
                }

                // RFC7230§5.3.1: When making a request directly to an origin server, […]
                // a client MUST send only the absolute path […] as the request-target.
                this._currentUrl = /^\//.test(this._options.path)
                    ? url.format(this._options)
                    : // When making a request to a proxy, […]
                      // a client MUST send the target URI in absolute-form […].
                      (this._currentUrl = this._options.path);

                // End a redirected request
                // (The first request must be ended explicitly with RedirectableRequest#end)
                if (this._isRedirect) {
                    // Write the request entity and end
                    var i = 0;
                    var self = this;
                    var buffers = this._requestBodyBuffers;
                    (function writeNext(error) {
                        // Only write if this request has not been redirected yet
                        /* istanbul ignore else */
                        if (request === self._currentRequest) {
                            // Report any write errors
                            /* istanbul ignore if */
                            if (error) {
                                self.emit('error', error);
                            }
                            // Write the next buffer if there are still left
                            else if (i < buffers.length) {
                                var buffer = buffers[i++];
                                /* istanbul ignore else */
                                if (!request.finished) {
                                    request.write(buffer.data, buffer.encoding, writeNext);
                                }
                            }
                            // End the request if `end` has been called on us
                            else if (self._ended) {
                                request.end();
                            }
                        }
                    })();
                }
            };

            // Processes a response from the current native request
            RedirectableRequest.prototype._processResponse = function (response) {
                // Store the redirected response
                var statusCode = response.statusCode;
                if (this._options.trackRedirects) {
                    this._redirects.push({
                        url: this._currentUrl,
                        headers: response.headers,
                        statusCode: statusCode
                    });
                }

                // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
                // that further action needs to be taken by the user agent in order to
                // fulfill the request. If a Location header field is provided,
                // the user agent MAY automatically redirect its request to the URI
                // referenced by the Location field value,
                // even if the specific status code is not understood.

                // If the response is not a redirect; return it as-is
                var location = response.headers.location;
                if (
                    !location ||
                    this._options.followRedirects === false ||
                    statusCode < 300 ||
                    statusCode >= 400
                ) {
                    response.responseUrl = this._currentUrl;
                    response.redirects = this._redirects;
                    this.emit('response', response);

                    // Clean up
                    this._requestBodyBuffers = [];
                    return;
                }

                // The response is a redirect, so abort the current request
                abortRequest(this._currentRequest);
                // Discard the remainder of the response to avoid waiting for data
                response.destroy();

                // RFC7231§6.4: A client SHOULD detect and intervene
                // in cyclical redirections (i.e., "infinite" redirection loops).
                if (++this._redirectCount > this._options.maxRedirects) {
                    this.emit('error', new TooManyRedirectsError());
                    return;
                }

                // Store the request headers if applicable
                var requestHeaders;
                var beforeRedirect = this._options.beforeRedirect;
                if (beforeRedirect) {
                    requestHeaders = Object.assign(
                        {
                            // The Host header was set by nativeProtocol.request
                            Host: response.req.getHeader('host')
                        },
                        this._options.headers
                    );
                }

                // RFC7231§6.4: Automatic redirection needs to done with
                // care for methods not known to be safe, […]
                // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
                // the request method from POST to GET for the subsequent request.
                var method = this._options.method;
                if (
                    ((statusCode === 301 || statusCode === 302) &&
                        this._options.method === 'POST') ||
                    // RFC7231§6.4.4: The 303 (See Other) status code indicates that
                    // the server is redirecting the user agent to a different resource […]
                    // A user agent can perform a retrieval request targeting that URI
                    // (a GET or HEAD request if using HTTP) […]
                    (statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method))
                ) {
                    this._options.method = 'GET';
                    // Drop a possible entity and headers related to it
                    this._requestBodyBuffers = [];
                    removeMatchingHeaders(/^content-/i, this._options.headers);
                }

                // Drop the Host header, as the redirect might lead to a different host
                var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

                // If the redirect is relative, carry over the host of the last request
                var currentUrlParts = url.parse(this._currentUrl);
                var currentHost = currentHostHeader || currentUrlParts.host;
                var currentUrl = /^\w+:/.test(location)
                    ? this._currentUrl
                    : url.format(Object.assign(currentUrlParts, { host: currentHost }));

                // Determine the URL of the redirection
                var redirectUrl;
                try {
                    redirectUrl = url.resolve(currentUrl, location);
                } catch (cause) {
                    this.emit('error', new RedirectionError(cause));
                    return;
                }

                // Create the redirected request
                debug('redirecting to', redirectUrl);
                this._isRedirect = true;
                var redirectUrlParts = url.parse(redirectUrl);
                Object.assign(this._options, redirectUrlParts);

                // Drop confidential headers when redirecting to a less secure protocol
                // or to a different domain that is not a superdomain
                if (
                    (redirectUrlParts.protocol !== currentUrlParts.protocol &&
                        redirectUrlParts.protocol !== 'https:') ||
                    (redirectUrlParts.host !== currentHost &&
                        !isSubdomain(redirectUrlParts.host, currentHost))
                ) {
                    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
                }

                // Evaluate the beforeRedirect callback
                if (typeof beforeRedirect === 'function') {
                    var responseDetails = {
                        headers: response.headers,
                        statusCode: statusCode
                    };
                    var requestDetails = {
                        url: currentUrl,
                        method: method,
                        headers: requestHeaders
                    };
                    try {
                        beforeRedirect(this._options, responseDetails, requestDetails);
                    } catch (err) {
                        this.emit('error', err);
                        return;
                    }
                    this._sanitizeOptions(this._options);
                }

                // Perform the redirected request
                try {
                    this._performRequest();
                } catch (cause) {
                    this.emit('error', new RedirectionError(cause));
                }
            };

            // Wraps the key/value object of protocols with redirect functionality
            function wrap(protocols) {
                // Default settings
                var exports = {
                    maxRedirects: 21,
                    maxBodyLength: 10 * 1024 * 1024
                };

                // Wrap each protocol
                var nativeProtocols = {};
                Object.keys(protocols).forEach(function (scheme) {
                    var protocol = scheme + ':';
                    var nativeProtocol = (nativeProtocols[protocol] = protocols[scheme]);
                    var wrappedProtocol = (exports[scheme] = Object.create(nativeProtocol));

                    // Executes a request, following redirects
                    function request(input, options, callback) {
                        // Parse parameters
                        if (typeof input === 'string') {
                            var urlStr = input;
                            try {
                                input = urlToOptions(new URL(urlStr));
                            } catch (err) {
                                /* istanbul ignore next */
                                input = url.parse(urlStr);
                            }
                        } else if (URL && input instanceof URL) {
                            input = urlToOptions(input);
                        } else {
                            callback = options;
                            options = input;
                            input = { protocol: protocol };
                        }
                        if (typeof options === 'function') {
                            callback = options;
                            options = null;
                        }

                        // Set defaults
                        options = Object.assign(
                            {
                                maxRedirects: exports.maxRedirects,
                                maxBodyLength: exports.maxBodyLength
                            },
                            input,
                            options
                        );
                        options.nativeProtocols = nativeProtocols;

                        assert.equal(options.protocol, protocol, 'protocol mismatch');
                        debug('options', options);
                        return new RedirectableRequest(options, callback);
                    }

                    // Executes a GET request, following redirects
                    function get(input, options, callback) {
                        var wrappedRequest = wrappedProtocol.request(input, options, callback);
                        wrappedRequest.end();
                        return wrappedRequest;
                    }

                    // Expose the properties on the wrapped protocol
                    Object.defineProperties(wrappedProtocol, {
                        request: {
                            value: request,
                            configurable: true,
                            enumerable: true,
                            writable: true
                        },
                        get: { value: get, configurable: true, enumerable: true, writable: true }
                    });
                });
                return exports;
            }

            /* istanbul ignore next */
            function noop() {
                /* empty */
            }

            // from https://github.com/nodejs/node/blob/master/lib/internal/url.js
            function urlToOptions(urlObject) {
                var options = {
                    protocol: urlObject.protocol,
                    hostname: urlObject.hostname.startsWith('[')
                        ? /* istanbul ignore next */
                          urlObject.hostname.slice(1, -1)
                        : urlObject.hostname,
                    hash: urlObject.hash,
                    search: urlObject.search,
                    pathname: urlObject.pathname,
                    path: urlObject.pathname + urlObject.search,
                    href: urlObject.href
                };
                if (urlObject.port !== '') {
                    options.port = Number(urlObject.port);
                }
                return options;
            }

            function removeMatchingHeaders(regex, headers) {
                var lastValue;
                for (var header in headers) {
                    if (regex.test(header)) {
                        lastValue = headers[header];
                        delete headers[header];
                    }
                }
                return lastValue === null || typeof lastValue === 'undefined'
                    ? undefined
                    : String(lastValue).trim();
            }

            function createErrorType(code, defaultMessage) {
                function CustomError(cause) {
                    Error.captureStackTrace(this, this.constructor);
                    if (!cause) {
                        this.message = defaultMessage;
                    } else {
                        this.message = defaultMessage + ': ' + cause.message;
                        this.cause = cause;
                    }
                }
                CustomError.prototype = new Error();
                CustomError.prototype.constructor = CustomError;
                CustomError.prototype.name = 'Error [' + code + ']';
                CustomError.prototype.code = code;
                return CustomError;
            }

            function abortRequest(request) {
                for (var event of events) {
                    request.removeListener(event, eventHandlers[event]);
                }
                request.on('error', noop);
                request.abort();
            }

            function isSubdomain(subdomain, domain) {
                const dot = subdomain.length - domain.length - 1;
                return dot > 0 && subdomain[dot] === '.' && subdomain.endsWith(domain);
            }

            // Exports
            module.exports = wrap({ http: http, https: https });
            module.exports.wrap = wrap;

            /***/
        },
        /* 105 */
        /***/ (module) => {
            'use strict';
            module.exports = require('url');

            /***/
        },
        /* 106 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var debug;

            module.exports = function () {
                if (!debug) {
                    try {
                        /* eslint global-require: off */
                        debug = __webpack_require__(107)('follow-redirects');
                    } catch (error) {
                        /* */
                    }
                    if (typeof debug !== 'function') {
                        debug = function () {
                            /* */
                        };
                    }
                }
                debug.apply(null, arguments);
            };

            /***/
        },
        /* 107 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            /**
             * Detect Electron renderer / nwjs process, which is node, but we should
             * treat as a browser.
             */

            if (
                typeof process === 'undefined' ||
                process.type === 'renderer' ||
                process.browser === true ||
                process.__nwjs
            ) {
                module.exports = __webpack_require__(108);
            } else {
                module.exports = __webpack_require__(111);
            }

            /***/
        },
        /* 108 */
        /***/ (module, exports, __webpack_require__) => {
            /* eslint-env browser */

            /**
             * This is the web browser implementation of `debug()`.
             */

            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage = localstorage();
            exports.destroy = (() => {
                let warned = false;

                return () => {
                    if (!warned) {
                        warned = true;
                        console.warn(
                            'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
                        );
                    }
                };
            })();

            /**
             * Colors.
             */

            exports.colors = [
                '#0000CC',
                '#0000FF',
                '#0033CC',
                '#0033FF',
                '#0066CC',
                '#0066FF',
                '#0099CC',
                '#0099FF',
                '#00CC00',
                '#00CC33',
                '#00CC66',
                '#00CC99',
                '#00CCCC',
                '#00CCFF',
                '#3300CC',
                '#3300FF',
                '#3333CC',
                '#3333FF',
                '#3366CC',
                '#3366FF',
                '#3399CC',
                '#3399FF',
                '#33CC00',
                '#33CC33',
                '#33CC66',
                '#33CC99',
                '#33CCCC',
                '#33CCFF',
                '#6600CC',
                '#6600FF',
                '#6633CC',
                '#6633FF',
                '#66CC00',
                '#66CC33',
                '#9900CC',
                '#9900FF',
                '#9933CC',
                '#9933FF',
                '#99CC00',
                '#99CC33',
                '#CC0000',
                '#CC0033',
                '#CC0066',
                '#CC0099',
                '#CC00CC',
                '#CC00FF',
                '#CC3300',
                '#CC3333',
                '#CC3366',
                '#CC3399',
                '#CC33CC',
                '#CC33FF',
                '#CC6600',
                '#CC6633',
                '#CC9900',
                '#CC9933',
                '#CCCC00',
                '#CCCC33',
                '#FF0000',
                '#FF0033',
                '#FF0066',
                '#FF0099',
                '#FF00CC',
                '#FF00FF',
                '#FF3300',
                '#FF3333',
                '#FF3366',
                '#FF3399',
                '#FF33CC',
                '#FF33FF',
                '#FF6600',
                '#FF6633',
                '#FF9900',
                '#FF9933',
                '#FFCC00',
                '#FFCC33'
            ];

            /**
             * Currently only WebKit-based Web Inspectors, Firefox >= v31,
             * and the Firebug extension (any Firefox version) are known
             * to support "%c" CSS customizations.
             *
             * TODO: add a `localStorage` variable to explicitly enable/disable colors
             */

            // eslint-disable-next-line complexity
            function useColors() {
                // NB: In an Electron preload script, document will be defined but not fully
                // initialized. Since we know we're in Chrome, we'll just detect this case
                // explicitly
                if (
                    typeof window !== 'undefined' &&
                    window.process &&
                    (window.process.type === 'renderer' || window.process.__nwjs)
                ) {
                    return true;
                }

                // Internet Explorer and Edge do not support colors.
                if (
                    typeof navigator !== 'undefined' &&
                    navigator.userAgent &&
                    navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
                ) {
                    return false;
                }

                // Is webkit? http://stackoverflow.com/a/16459606/376773
                // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
                return (
                    (typeof document !== 'undefined' &&
                        document.documentElement &&
                        document.documentElement.style &&
                        document.documentElement.style.WebkitAppearance) ||
                    // Is firebug? http://stackoverflow.com/a/398120/376773
                    (typeof window !== 'undefined' &&
                        window.console &&
                        (window.console.firebug ||
                            (window.console.exception && window.console.table))) ||
                    // Is firefox >= v31?
                    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                    (typeof navigator !== 'undefined' &&
                        navigator.userAgent &&
                        navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                        parseInt(RegExp.$1, 10) >= 31) ||
                    // Double check webkit in userAgent just in case we are in a worker
                    (typeof navigator !== 'undefined' &&
                        navigator.userAgent &&
                        navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
                );
            }

            /**
             * Colorize log arguments if enabled.
             *
             * @api public
             */

            function formatArgs(args) {
                args[0] =
                    (this.useColors ? '%c' : '') +
                    this.namespace +
                    (this.useColors ? ' %c' : ' ') +
                    args[0] +
                    (this.useColors ? '%c ' : ' ') +
                    '+' +
                    module.exports.humanize(this.diff);

                if (!this.useColors) {
                    return;
                }

                const c = 'color: ' + this.color;
                args.splice(1, 0, c, 'color: inherit');

                // The final "%c" is somewhat tricky, because there could be other
                // arguments passed either before or after the %c, so we need to
                // figure out the correct index to insert the CSS into
                let index = 0;
                let lastC = 0;
                args[0].replace(/%[a-zA-Z%]/g, (match) => {
                    if (match === '%%') {
                        return;
                    }
                    index++;
                    if (match === '%c') {
                        // We only are interested in the *last* %c
                        // (the user may have provided their own)
                        lastC = index;
                    }
                });

                args.splice(lastC, 0, c);
            }

            /**
             * Invokes `console.debug()` when available.
             * No-op when `console.debug` is not a "function".
             * If `console.debug` is not available, falls back
             * to `console.log`.
             *
             * @api public
             */
            exports.log = console.debug || console.log || (() => {});

            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */
            function save(namespaces) {
                try {
                    if (namespaces) {
                        exports.storage.setItem('debug', namespaces);
                    } else {
                        exports.storage.removeItem('debug');
                    }
                } catch (error) {
                    // Swallow
                    // XXX (@Qix-) should we be logging these?
                }
            }

            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */
            function load() {
                let r;
                try {
                    r = exports.storage.getItem('debug');
                } catch (error) {
                    // Swallow
                    // XXX (@Qix-) should we be logging these?
                }

                // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
                if (!r && typeof process !== 'undefined' && 'env' in process) {
                    r = process.env.DEBUG;
                }

                return r;
            }

            /**
             * Localstorage attempts to return the localstorage.
             *
             * This is necessary because safari throws
             * when a user disables cookies/localstorage
             * and you attempt to access it.
             *
             * @return {LocalStorage}
             * @api private
             */

            function localstorage() {
                try {
                    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
                    // The Browser also has localStorage in the global context.
                    return localStorage;
                } catch (error) {
                    // Swallow
                    // XXX (@Qix-) should we be logging these?
                }
            }

            module.exports = __webpack_require__(109)(exports);

            const { formatters } = module.exports;

            /**
             * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
             */

            formatters.j = function (v) {
                try {
                    return JSON.stringify(v);
                } catch (error) {
                    return '[UnexpectedJSONParseError]: ' + error.message;
                }
            };

            /***/
        },
        /* 109 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            /**
             * This is the common logic for both the Node.js and web browser
             * implementations of `debug()`.
             */

            function setup(env) {
                createDebug.debug = createDebug;
                createDebug.default = createDebug;
                createDebug.coerce = coerce;
                createDebug.disable = disable;
                createDebug.enable = enable;
                createDebug.enabled = enabled;
                createDebug.humanize = __webpack_require__(110);
                createDebug.destroy = destroy;

                Object.keys(env).forEach((key) => {
                    createDebug[key] = env[key];
                });

                /**
                 * The currently active debug mode names, and names to skip.
                 */

                createDebug.names = [];
                createDebug.skips = [];

                /**
                 * Map of special "%n" handling functions, for the debug "format" argument.
                 *
                 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
                 */
                createDebug.formatters = {};

                /**
                 * Selects a color for a debug namespace
                 * @param {String} namespace The namespace string for the debug instance to be colored
                 * @return {Number|String} An ANSI color code for the given namespace
                 * @api private
                 */
                function selectColor(namespace) {
                    let hash = 0;

                    for (let i = 0; i < namespace.length; i++) {
                        hash = (hash << 5) - hash + namespace.charCodeAt(i);
                        hash |= 0; // Convert to 32bit integer
                    }

                    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
                }
                createDebug.selectColor = selectColor;

                /**
                 * Create a debugger with the given `namespace`.
                 *
                 * @param {String} namespace
                 * @return {Function}
                 * @api public
                 */
                function createDebug(namespace) {
                    let prevTime;
                    let enableOverride = null;
                    let namespacesCache;
                    let enabledCache;

                    function debug(...args) {
                        // Disabled?
                        if (!debug.enabled) {
                            return;
                        }

                        const self = debug;

                        // Set `diff` timestamp
                        const curr = Number(new Date());
                        const ms = curr - (prevTime || curr);
                        self.diff = ms;
                        self.prev = prevTime;
                        self.curr = curr;
                        prevTime = curr;

                        args[0] = createDebug.coerce(args[0]);

                        if (typeof args[0] !== 'string') {
                            // Anything else let's inspect with %O
                            args.unshift('%O');
                        }

                        // Apply any `formatters` transformations
                        let index = 0;
                        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                            // If we encounter an escaped % then don't increase the array index
                            if (match === '%%') {
                                return '%';
                            }
                            index++;
                            const formatter = createDebug.formatters[format];
                            if (typeof formatter === 'function') {
                                const val = args[index];
                                match = formatter.call(self, val);

                                // Now we need to remove `args[index]` since it's inlined in the `format`
                                args.splice(index, 1);
                                index--;
                            }
                            return match;
                        });

                        // Apply env-specific formatting (colors, etc.)
                        createDebug.formatArgs.call(self, args);

                        const logFn = self.log || createDebug.log;
                        logFn.apply(self, args);
                    }

                    debug.namespace = namespace;
                    debug.useColors = createDebug.useColors();
                    debug.color = createDebug.selectColor(namespace);
                    debug.extend = extend;
                    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

                    Object.defineProperty(debug, 'enabled', {
                        enumerable: true,
                        configurable: false,
                        get: () => {
                            if (enableOverride !== null) {
                                return enableOverride;
                            }
                            if (namespacesCache !== createDebug.namespaces) {
                                namespacesCache = createDebug.namespaces;
                                enabledCache = createDebug.enabled(namespace);
                            }

                            return enabledCache;
                        },
                        set: (v) => {
                            enableOverride = v;
                        }
                    });

                    // Env-specific initialization logic for debug instances
                    if (typeof createDebug.init === 'function') {
                        createDebug.init(debug);
                    }

                    return debug;
                }

                function extend(namespace, delimiter) {
                    const newDebug = createDebug(
                        this.namespace +
                            (typeof delimiter === 'undefined' ? ':' : delimiter) +
                            namespace
                    );
                    newDebug.log = this.log;
                    return newDebug;
                }

                /**
                 * Enables a debug mode by namespaces. This can include modes
                 * separated by a colon and wildcards.
                 *
                 * @param {String} namespaces
                 * @api public
                 */
                function enable(namespaces) {
                    createDebug.save(namespaces);
                    createDebug.namespaces = namespaces;

                    createDebug.names = [];
                    createDebug.skips = [];

                    let i;
                    const split = (typeof namespaces === 'string' ? namespaces : '').split(
                        /[\s,]+/
                    );
                    const len = split.length;

                    for (i = 0; i < len; i++) {
                        if (!split[i]) {
                            // ignore empty strings
                            continue;
                        }

                        namespaces = split[i].replace(/\*/g, '.*?');

                        if (namespaces[0] === '-') {
                            createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
                        } else {
                            createDebug.names.push(new RegExp('^' + namespaces + '$'));
                        }
                    }
                }

                /**
                 * Disable debug output.
                 *
                 * @return {String} namespaces
                 * @api public
                 */
                function disable() {
                    const namespaces = [
                        ...createDebug.names.map(toNamespace),
                        ...createDebug.skips.map(toNamespace).map((namespace) => '-' + namespace)
                    ].join(',');
                    createDebug.enable('');
                    return namespaces;
                }

                /**
                 * Returns true if the given mode name is enabled, false otherwise.
                 *
                 * @param {String} name
                 * @return {Boolean}
                 * @api public
                 */
                function enabled(name) {
                    if (name[name.length - 1] === '*') {
                        return true;
                    }

                    let i;
                    let len;

                    for (i = 0, len = createDebug.skips.length; i < len; i++) {
                        if (createDebug.skips[i].test(name)) {
                            return false;
                        }
                    }

                    for (i = 0, len = createDebug.names.length; i < len; i++) {
                        if (createDebug.names[i].test(name)) {
                            return true;
                        }
                    }

                    return false;
                }

                /**
                 * Convert regexp to namespace
                 *
                 * @param {RegExp} regxep
                 * @return {String} namespace
                 * @api private
                 */
                function toNamespace(regexp) {
                    return regexp
                        .toString()
                        .substring(2, regexp.toString().length - 2)
                        .replace(/\.\*\?$/, '*');
                }

                /**
                 * Coerce `val`.
                 *
                 * @param {Mixed} val
                 * @return {Mixed}
                 * @api private
                 */
                function coerce(val) {
                    if (val instanceof Error) {
                        return val.stack || val.message;
                    }
                    return val;
                }

                /**
                 * XXX DO NOT USE. This is a temporary stub function.
                 * XXX It WILL be removed in the next major release.
                 */
                function destroy() {
                    console.warn(
                        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
                    );
                }

                createDebug.enable(createDebug.load());

                return createDebug;
            }

            module.exports = setup;

            /***/
        },
        /* 110 */
        /***/ (module) => {
            /**
             * Helpers.
             */

            var s = 1000;
            var m = s * 60;
            var h = m * 60;
            var d = h * 24;
            var w = d * 7;
            var y = d * 365.25;

            /**
             * Parse or format the given `val`.
             *
             * Options:
             *
             *  - `long` verbose formatting [false]
             *
             * @param {String|Number} val
             * @param {Object} [options]
             * @throws {Error} throw an error if val is not a non-empty string or a number
             * @return {String|Number}
             * @api public
             */

            module.exports = function (val, options) {
                options = options || {};
                var type = typeof val;
                if (type === 'string' && val.length > 0) {
                    return parse(val);
                } else if (type === 'number' && isFinite(val)) {
                    return options.long ? fmtLong(val) : fmtShort(val);
                }
                throw new Error(
                    'val is not a non-empty string or a valid number. val=' + JSON.stringify(val)
                );
            };

            /**
             * Parse the given `str` and return milliseconds.
             *
             * @param {String} str
             * @return {Number}
             * @api private
             */

            function parse(str) {
                str = String(str);
                if (str.length > 100) {
                    return;
                }
                var match =
                    /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                        str
                    );
                if (!match) {
                    return;
                }
                var n = parseFloat(match[1]);
                var type = (match[2] || 'ms').toLowerCase();
                switch (type) {
                    case 'years':
                    case 'year':
                    case 'yrs':
                    case 'yr':
                    case 'y':
                        return n * y;
                    case 'weeks':
                    case 'week':
                    case 'w':
                        return n * w;
                    case 'days':
                    case 'day':
                    case 'd':
                        return n * d;
                    case 'hours':
                    case 'hour':
                    case 'hrs':
                    case 'hr':
                    case 'h':
                        return n * h;
                    case 'minutes':
                    case 'minute':
                    case 'mins':
                    case 'min':
                    case 'm':
                        return n * m;
                    case 'seconds':
                    case 'second':
                    case 'secs':
                    case 'sec':
                    case 's':
                        return n * s;
                    case 'milliseconds':
                    case 'millisecond':
                    case 'msecs':
                    case 'msec':
                    case 'ms':
                        return n;
                    default:
                        return undefined;
                }
            }

            /**
             * Short format for `ms`.
             *
             * @param {Number} ms
             * @return {String}
             * @api private
             */

            function fmtShort(ms) {
                var msAbs = Math.abs(ms);
                if (msAbs >= d) {
                    return Math.round(ms / d) + 'd';
                }
                if (msAbs >= h) {
                    return Math.round(ms / h) + 'h';
                }
                if (msAbs >= m) {
                    return Math.round(ms / m) + 'm';
                }
                if (msAbs >= s) {
                    return Math.round(ms / s) + 's';
                }
                return ms + 'ms';
            }

            /**
             * Long format for `ms`.
             *
             * @param {Number} ms
             * @return {String}
             * @api private
             */

            function fmtLong(ms) {
                var msAbs = Math.abs(ms);
                if (msAbs >= d) {
                    return plural(ms, msAbs, d, 'day');
                }
                if (msAbs >= h) {
                    return plural(ms, msAbs, h, 'hour');
                }
                if (msAbs >= m) {
                    return plural(ms, msAbs, m, 'minute');
                }
                if (msAbs >= s) {
                    return plural(ms, msAbs, s, 'second');
                }
                return ms + ' ms';
            }

            /**
             * Pluralization helper.
             */

            function plural(ms, msAbs, n, name) {
                var isPlural = msAbs >= n * 1.5;
                return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
            }

            /***/
        },
        /* 111 */
        /***/ (module, exports, __webpack_require__) => {
            /**
             * Module dependencies.
             */

            const tty = __webpack_require__(112);
            const util = __webpack_require__(16);

            /**
             * This is the Node.js implementation of `debug()`.
             */

            exports.init = init;
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.destroy = util.deprecate(() => {},
            'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');

            /**
             * Colors.
             */

            exports.colors = [6, 2, 3, 4, 5, 1];

            try {
                // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
                // eslint-disable-next-line import/no-extraneous-dependencies
                const supportsColor = __webpack_require__(113);

                if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
                    exports.colors = [
                        20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,
                        69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,
                        135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
                        172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,
                        205, 206, 207, 208, 209, 214, 215, 220, 221
                    ];
                }
            } catch (error) {
                // Swallow - we only care if `supports-color` is available; it doesn't have to be.
            }

            /**
             * Build up the default `inspectOpts` object from the environment variables.
             *
             *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
             */

            exports.inspectOpts = Object.keys(process.env)
                .filter((key) => {
                    return /^debug_/i.test(key);
                })
                .reduce((obj, key) => {
                    // Camel-case
                    const prop = key
                        .substring(6)
                        .toLowerCase()
                        .replace(/_([a-z])/g, (_, k) => {
                            return k.toUpperCase();
                        });

                    // Coerce string value into JS value
                    let val = process.env[key];
                    if (/^(yes|on|true|enabled)$/i.test(val)) {
                        val = true;
                    } else if (/^(no|off|false|disabled)$/i.test(val)) {
                        val = false;
                    } else if (val === 'null') {
                        val = null;
                    } else {
                        val = Number(val);
                    }

                    obj[prop] = val;
                    return obj;
                }, {});

            /**
             * Is stdout a TTY? Colored output is enabled when `true`.
             */

            function useColors() {
                return 'colors' in exports.inspectOpts
                    ? Boolean(exports.inspectOpts.colors)
                    : tty.isatty(process.stderr.fd);
            }

            /**
             * Adds ANSI color escape codes if enabled.
             *
             * @api public
             */

            function formatArgs(args) {
                const { namespace: name, useColors } = this;

                if (useColors) {
                    const c = this.color;
                    const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
                    const prefix = `  ${colorCode};1m${name} \u001B[0m`;

                    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
                    args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
                } else {
                    args[0] = getDate() + name + ' ' + args[0];
                }
            }

            function getDate() {
                if (exports.inspectOpts.hideDate) {
                    return '';
                }
                return new Date().toISOString() + ' ';
            }

            /**
             * Invokes `util.format()` with the specified arguments and writes to stderr.
             */

            function log(...args) {
                return process.stderr.write(util.format(...args) + '\n');
            }

            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */
            function save(namespaces) {
                if (namespaces) {
                    process.env.DEBUG = namespaces;
                } else {
                    // If you set a process.env field to null or undefined, it gets cast to the
                    // string 'null' or 'undefined'. Just delete instead.
                    delete process.env.DEBUG;
                }
            }

            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */

            function load() {
                return process.env.DEBUG;
            }

            /**
             * Init logic for `debug` instances.
             *
             * Create a new `inspectOpts` object in case `useColors` is set
             * differently for a particular `debug` instance.
             */

            function init(debug) {
                debug.inspectOpts = {};

                const keys = Object.keys(exports.inspectOpts);
                for (let i = 0; i < keys.length; i++) {
                    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
                }
            }

            module.exports = __webpack_require__(109)(exports);

            const { formatters } = module.exports;

            /**
             * Map %o to `util.inspect()`, all on a single line.
             */

            formatters.o = function (v) {
                this.inspectOpts.colors = this.useColors;
                return util
                    .inspect(v, this.inspectOpts)
                    .split('\n')
                    .map((str) => str.trim())
                    .join(' ');
            };

            /**
             * Map %O to `util.inspect()`, allowing multiple lines if needed.
             */

            formatters.O = function (v) {
                this.inspectOpts.colors = this.useColors;
                return util.inspect(v, this.inspectOpts);
            };

            /***/
        },
        /* 112 */
        /***/ (module) => {
            'use strict';
            module.exports = require('tty');

            /***/
        },
        /* 113 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            const os = __webpack_require__(114);
            const tty = __webpack_require__(112);
            const hasFlag = __webpack_require__(115);

            const { env } = process;

            let forceColor;
            if (
                hasFlag('no-color') ||
                hasFlag('no-colors') ||
                hasFlag('color=false') ||
                hasFlag('color=never')
            ) {
                forceColor = 0;
            } else if (
                hasFlag('color') ||
                hasFlag('colors') ||
                hasFlag('color=true') ||
                hasFlag('color=always')
            ) {
                forceColor = 1;
            }

            if ('FORCE_COLOR' in env) {
                if (env.FORCE_COLOR === 'true') {
                    forceColor = 1;
                } else if (env.FORCE_COLOR === 'false') {
                    forceColor = 0;
                } else {
                    forceColor =
                        env.FORCE_COLOR.length === 0
                            ? 1
                            : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
                }
            }

            function translateLevel(level) {
                if (level === 0) {
                    return false;
                }

                return {
                    level,
                    hasBasic: true,
                    has256: level >= 2,
                    has16m: level >= 3
                };
            }

            function supportsColor(haveStream, streamIsTTY) {
                if (forceColor === 0) {
                    return 0;
                }

                if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
                    return 3;
                }

                if (hasFlag('color=256')) {
                    return 2;
                }

                if (haveStream && !streamIsTTY && forceColor === undefined) {
                    return 0;
                }

                const min = forceColor || 0;

                if (env.TERM === 'dumb') {
                    return min;
                }

                if (process.platform === 'win32') {
                    // Windows 10 build 10586 is the first Windows release that supports 256 colors.
                    // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
                    const osRelease = os.release().split('.');
                    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
                        return Number(osRelease[2]) >= 14931 ? 3 : 2;
                    }

                    return 1;
                }

                if ('CI' in env) {
                    if (
                        [
                            'TRAVIS',
                            'CIRCLECI',
                            'APPVEYOR',
                            'GITLAB_CI',
                            'GITHUB_ACTIONS',
                            'BUILDKITE'
                        ].some((sign) => sign in env) ||
                        env.CI_NAME === 'codeship'
                    ) {
                        return 1;
                    }

                    return min;
                }

                if ('TEAMCITY_VERSION' in env) {
                    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
                }

                if (env.COLORTERM === 'truecolor') {
                    return 3;
                }

                if ('TERM_PROGRAM' in env) {
                    const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

                    switch (env.TERM_PROGRAM) {
                        case 'iTerm.app':
                            return version >= 3 ? 3 : 2;
                        case 'Apple_Terminal':
                            return 2;
                        // No default
                    }
                }

                if (/-256(color)?$/i.test(env.TERM)) {
                    return 2;
                }

                if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
                    return 1;
                }

                if ('COLORTERM' in env) {
                    return 1;
                }

                return min;
            }

            function getSupportLevel(stream) {
                const level = supportsColor(stream, stream && stream.isTTY);
                return translateLevel(level);
            }

            module.exports = {
                supportsColor: getSupportLevel,
                stdout: translateLevel(supportsColor(true, tty.isatty(1))),
                stderr: translateLevel(supportsColor(true, tty.isatty(2)))
            };

            /***/
        },
        /* 114 */
        /***/ (module) => {
            'use strict';
            module.exports = require('os');

            /***/
        },
        /* 115 */
        /***/ (module) => {
            'use strict';

            module.exports = (flag, argv = process.argv) => {
                const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
                const position = argv.indexOf(prefix + flag);
                const terminatorPosition = argv.indexOf('--');
                return (
                    position !== -1 && (terminatorPosition === -1 || position < terminatorPosition)
                );
            };

            /***/
        },
        /* 116 */
        /***/ (module) => {
            'use strict';
            module.exports = require('zlib');

            /***/
        },
        /* 117 */
        /***/ (module) => {
            module.exports = {
                version: '0.27.2'
            };

            /***/
        },
        /* 118 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            // eslint-disable-next-line strict
            module.exports = __webpack_require__(119);

            /***/
        },
        /* 119 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var CombinedStream = __webpack_require__(120);
            var util = __webpack_require__(16);
            var path = __webpack_require__(4);
            var http = __webpack_require__(102);
            var https = __webpack_require__(103);
            var parseUrl = __webpack_require__(105).parse;
            var fs = __webpack_require__(3);
            var Stream = __webpack_require__(14).Stream;
            var mime = __webpack_require__(122);
            var asynckit = __webpack_require__(125);
            var populate = __webpack_require__(135);

            // Public API
            module.exports = FormData;

            // make it a Stream
            util.inherits(FormData, CombinedStream);

            /**
             * Create readable "multipart/form-data" streams.
             * Can be used to submit forms
             * and file uploads to other web applications.
             *
             * @constructor
             * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
             */
            function FormData(options) {
                if (!(this instanceof FormData)) {
                    return new FormData(options);
                }

                this._overheadLength = 0;
                this._valueLength = 0;
                this._valuesToMeasure = [];

                CombinedStream.call(this);

                options = options || {};
                for (var option in options) {
                    this[option] = options[option];
                }
            }

            FormData.LINE_BREAK = '\r\n';
            FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

            FormData.prototype.append = function (field, value, options) {
                options = options || {};

                // allow filename as single option
                if (typeof options == 'string') {
                    options = { filename: options };
                }

                var append = CombinedStream.prototype.append.bind(this);

                // all that streamy business can't handle numbers
                if (typeof value == 'number') {
                    value = '' + value;
                }

                // https://github.com/felixge/node-form-data/issues/38
                if (util.isArray(value)) {
                    // Please convert your array into string
                    // the way web server expects it
                    this._error(new Error('Arrays are not supported.'));
                    return;
                }

                var header = this._multiPartHeader(field, value, options);
                var footer = this._multiPartFooter();

                append(header);
                append(value);
                append(footer);

                // pass along options.knownLength
                this._trackLength(header, value, options);
            };

            FormData.prototype._trackLength = function (header, value, options) {
                var valueLength = 0;

                // used w/ getLengthSync(), when length is known.
                // e.g. for streaming directly from a remote server,
                // w/ a known file a size, and not wanting to wait for
                // incoming file to finish to get its size.
                if (options.knownLength != null) {
                    valueLength += +options.knownLength;
                } else if (Buffer.isBuffer(value)) {
                    valueLength = value.length;
                } else if (typeof value === 'string') {
                    valueLength = Buffer.byteLength(value);
                }

                this._valueLength += valueLength;

                // @check why add CRLF? does this account for custom/multiple CRLFs?
                this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;

                // empty or either doesn't have path or not an http response or not a stream
                if (
                    !value ||
                    (!value.path &&
                        !(value.readable && value.hasOwnProperty('httpVersion')) &&
                        !(value instanceof Stream))
                ) {
                    return;
                }

                // no need to bother with the length
                if (!options.knownLength) {
                    this._valuesToMeasure.push(value);
                }
            };

            FormData.prototype._lengthRetriever = function (value, callback) {
                if (value.hasOwnProperty('fd')) {
                    // take read range into a account
                    // `end` = Infinity –> read file till the end
                    //
                    // TODO: Looks like there is bug in Node fs.createReadStream
                    // it doesn't respect `end` options without `start` options
                    // Fix it when node fixes it.
                    // https://github.com/joyent/node/issues/7819
                    if (
                        value.end != undefined &&
                        value.end != Infinity &&
                        value.start != undefined
                    ) {
                        // when end specified
                        // no need to calculate range
                        // inclusive, starts with 0
                        callback(null, value.end + 1 - (value.start ? value.start : 0));

                        // not that fast snoopy
                    } else {
                        // still need to fetch file size from fs
                        fs.stat(value.path, function (err, stat) {
                            var fileSize;

                            if (err) {
                                callback(err);
                                return;
                            }

                            // update final size based on the range options
                            fileSize = stat.size - (value.start ? value.start : 0);
                            callback(null, fileSize);
                        });
                    }

                    // or http response
                } else if (value.hasOwnProperty('httpVersion')) {
                    callback(null, +value.headers['content-length']);

                    // or request stream http://github.com/mikeal/request
                } else if (value.hasOwnProperty('httpModule')) {
                    // wait till response come back
                    value.on('response', function (response) {
                        value.pause();
                        callback(null, +response.headers['content-length']);
                    });
                    value.resume();

                    // something else
                } else {
                    callback('Unknown stream');
                }
            };

            FormData.prototype._multiPartHeader = function (field, value, options) {
                // custom header specified (as string)?
                // it becomes responsible for boundary
                // (e.g. to handle extra CRLFs on .NET servers)
                if (typeof options.header == 'string') {
                    return options.header;
                }

                var contentDisposition = this._getContentDisposition(value, options);
                var contentType = this._getContentType(value, options);

                var contents = '';
                var headers = {
                    // add custom disposition as third element or keep it two elements if not
                    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(
                        contentDisposition || []
                    ),
                    // if no content type. allow it to be empty array
                    'Content-Type': [].concat(contentType || [])
                };

                // allow custom headers.
                if (typeof options.header == 'object') {
                    populate(headers, options.header);
                }

                var header;
                for (var prop in headers) {
                    if (!headers.hasOwnProperty(prop)) continue;
                    header = headers[prop];

                    // skip nullish headers.
                    if (header == null) {
                        continue;
                    }

                    // convert all headers to arrays.
                    if (!Array.isArray(header)) {
                        header = [header];
                    }

                    // add non-empty headers.
                    if (header.length) {
                        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
                    }
                }

                return (
                    '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK
                );
            };

            FormData.prototype._getContentDisposition = function (value, options) {
                var filename, contentDisposition;

                if (typeof options.filepath === 'string') {
                    // custom filepath for relative paths
                    filename = path.normalize(options.filepath).replace(/\\/g, '/');
                } else if (options.filename || value.name || value.path) {
                    // custom filename take precedence
                    // formidable and the browser add a name property
                    // fs- and request- streams have path property
                    filename = path.basename(options.filename || value.name || value.path);
                } else if (value.readable && value.hasOwnProperty('httpVersion')) {
                    // or try http response
                    filename = path.basename(value.client._httpMessage.path || '');
                }

                if (filename) {
                    contentDisposition = 'filename="' + filename + '"';
                }

                return contentDisposition;
            };

            FormData.prototype._getContentType = function (value, options) {
                // use custom content-type above all
                var contentType = options.contentType;

                // or try `name` from formidable, browser
                if (!contentType && value.name) {
                    contentType = mime.lookup(value.name);
                }

                // or try `path` from fs-, request- streams
                if (!contentType && value.path) {
                    contentType = mime.lookup(value.path);
                }

                // or if it's http-reponse
                if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
                    contentType = value.headers['content-type'];
                }

                // or guess it from the filepath or filename
                if (!contentType && (options.filepath || options.filename)) {
                    contentType = mime.lookup(options.filepath || options.filename);
                }

                // fallback to the default content type if `value` is not simple value
                if (!contentType && typeof value == 'object') {
                    contentType = FormData.DEFAULT_CONTENT_TYPE;
                }

                return contentType;
            };

            FormData.prototype._multiPartFooter = function () {
                return function (next) {
                    var footer = FormData.LINE_BREAK;

                    var lastPart = this._streams.length === 0;
                    if (lastPart) {
                        footer += this._lastBoundary();
                    }

                    next(footer);
                }.bind(this);
            };

            FormData.prototype._lastBoundary = function () {
                return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
            };

            FormData.prototype.getHeaders = function (userHeaders) {
                var header;
                var formHeaders = {
                    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
                };

                for (header in userHeaders) {
                    if (userHeaders.hasOwnProperty(header)) {
                        formHeaders[header.toLowerCase()] = userHeaders[header];
                    }
                }

                return formHeaders;
            };

            FormData.prototype.setBoundary = function (boundary) {
                this._boundary = boundary;
            };

            FormData.prototype.getBoundary = function () {
                if (!this._boundary) {
                    this._generateBoundary();
                }

                return this._boundary;
            };

            FormData.prototype.getBuffer = function () {
                var dataBuffer = new Buffer.alloc(0);
                var boundary = this.getBoundary();

                // Create the form content. Add Line breaks to the end of data.
                for (var i = 0, len = this._streams.length; i < len; i++) {
                    if (typeof this._streams[i] !== 'function') {
                        // Add content to the buffer.
                        if (Buffer.isBuffer(this._streams[i])) {
                            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
                        } else {
                            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
                        }

                        // Add break after content.
                        if (
                            typeof this._streams[i] !== 'string' ||
                            this._streams[i].substring(2, boundary.length + 2) !== boundary
                        ) {
                            dataBuffer = Buffer.concat([
                                dataBuffer,
                                Buffer.from(FormData.LINE_BREAK)
                            ]);
                        }
                    }
                }

                // Add the footer and return the Buffer object.
                return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
            };

            FormData.prototype._generateBoundary = function () {
                // This generates a 50 character boundary similar to those used by Firefox.
                // They are optimized for boyer-moore parsing.
                var boundary = '--------------------------';
                for (var i = 0; i < 24; i++) {
                    boundary += Math.floor(Math.random() * 10).toString(16);
                }

                this._boundary = boundary;
            };

            // Note: getLengthSync DOESN'T calculate streams length
            // As workaround one can calculate file size manually
            // and add it as knownLength option
            FormData.prototype.getLengthSync = function () {
                var knownLength = this._overheadLength + this._valueLength;

                // Don't get confused, there are 3 "internal" streams for each keyval pair
                // so it basically checks if there is any value added to the form
                if (this._streams.length) {
                    knownLength += this._lastBoundary().length;
                }

                // https://github.com/form-data/form-data/issues/40
                if (!this.hasKnownLength()) {
                    // Some async length retrievers are present
                    // therefore synchronous length calculation is false.
                    // Please use getLength(callback) to get proper length
                    this._error(new Error('Cannot calculate proper length in synchronous way.'));
                }

                return knownLength;
            };

            // Public API to check if length of added values is known
            // https://github.com/form-data/form-data/issues/196
            // https://github.com/form-data/form-data/issues/262
            FormData.prototype.hasKnownLength = function () {
                var hasKnownLength = true;

                if (this._valuesToMeasure.length) {
                    hasKnownLength = false;
                }

                return hasKnownLength;
            };

            FormData.prototype.getLength = function (cb) {
                var knownLength = this._overheadLength + this._valueLength;

                if (this._streams.length) {
                    knownLength += this._lastBoundary().length;
                }

                if (!this._valuesToMeasure.length) {
                    process.nextTick(cb.bind(this, null, knownLength));
                    return;
                }

                asynckit.parallel(
                    this._valuesToMeasure,
                    this._lengthRetriever,
                    function (err, values) {
                        if (err) {
                            cb(err);
                            return;
                        }

                        values.forEach(function (length) {
                            knownLength += length;
                        });

                        cb(null, knownLength);
                    }
                );
            };

            FormData.prototype.submit = function (params, cb) {
                var request,
                    options,
                    defaults = { method: 'post' };
                // parse provided url if it's string
                // or treat it as options object
                if (typeof params == 'string') {
                    params = parseUrl(params);
                    options = populate(
                        {
                            port: params.port,
                            path: params.pathname,
                            host: params.hostname,
                            protocol: params.protocol
                        },
                        defaults
                    );

                    // use custom params
                } else {
                    options = populate(params, defaults);
                    // if no port provided use default one
                    if (!options.port) {
                        options.port = options.protocol == 'https:' ? 443 : 80;
                    }
                }

                // put that good code in getHeaders to some use
                options.headers = this.getHeaders(params.headers);

                // https if specified, fallback to http in any other case
                if (options.protocol == 'https:') {
                    request = https.request(options);
                } else {
                    request = http.request(options);
                }

                // get content length and fire away
                this.getLength(
                    function (err, length) {
                        if (err && err !== 'Unknown stream') {
                            this._error(err);
                            return;
                        }

                        // add content length
                        if (length) {
                            request.setHeader('Content-Length', length);
                        }

                        this.pipe(request);
                        if (cb) {
                            var onResponse;

                            var callback = function (error, responce) {
                                request.removeListener('error', callback);
                                request.removeListener('response', onResponse);

                                return cb.call(this, error, responce);
                            };

                            onResponse = callback.bind(this, null);

                            request.on('error', callback);
                            request.on('response', onResponse);
                        }
                    }.bind(this)
                );

                return request;
            };

            FormData.prototype._error = function (err) {
                if (!this.error) {
                    this.error = err;
                    this.pause();
                    this.emit('error', err);
                }
            };

            FormData.prototype.toString = function () {
                return '[object FormData]';
            };

            /***/
        },
        /* 120 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var util = __webpack_require__(16);
            var Stream = __webpack_require__(14).Stream;
            var DelayedStream = __webpack_require__(121);

            module.exports = CombinedStream;
            function CombinedStream() {
                this.writable = false;
                this.readable = true;
                this.dataSize = 0;
                this.maxDataSize = 2 * 1024 * 1024;
                this.pauseStreams = true;

                this._released = false;
                this._streams = [];
                this._currentStream = null;
                this._insideLoop = false;
                this._pendingNext = false;
            }
            util.inherits(CombinedStream, Stream);

            CombinedStream.create = function (options) {
                var combinedStream = new this();

                options = options || {};
                for (var option in options) {
                    combinedStream[option] = options[option];
                }

                return combinedStream;
            };

            CombinedStream.isStreamLike = function (stream) {
                return (
                    typeof stream !== 'function' &&
                    typeof stream !== 'string' &&
                    typeof stream !== 'boolean' &&
                    typeof stream !== 'number' &&
                    !Buffer.isBuffer(stream)
                );
            };

            CombinedStream.prototype.append = function (stream) {
                var isStreamLike = CombinedStream.isStreamLike(stream);

                if (isStreamLike) {
                    if (!(stream instanceof DelayedStream)) {
                        var newStream = DelayedStream.create(stream, {
                            maxDataSize: Infinity,
                            pauseStream: this.pauseStreams
                        });
                        stream.on('data', this._checkDataSize.bind(this));
                        stream = newStream;
                    }

                    this._handleErrors(stream);

                    if (this.pauseStreams) {
                        stream.pause();
                    }
                }

                this._streams.push(stream);
                return this;
            };

            CombinedStream.prototype.pipe = function (dest, options) {
                Stream.prototype.pipe.call(this, dest, options);
                this.resume();
                return dest;
            };

            CombinedStream.prototype._getNext = function () {
                this._currentStream = null;

                if (this._insideLoop) {
                    this._pendingNext = true;
                    return; // defer call
                }

                this._insideLoop = true;
                try {
                    do {
                        this._pendingNext = false;
                        this._realGetNext();
                    } while (this._pendingNext);
                } finally {
                    this._insideLoop = false;
                }
            };

            CombinedStream.prototype._realGetNext = function () {
                var stream = this._streams.shift();

                if (typeof stream == 'undefined') {
                    this.end();
                    return;
                }

                if (typeof stream !== 'function') {
                    this._pipeNext(stream);
                    return;
                }

                var getStream = stream;
                getStream(
                    function (stream) {
                        var isStreamLike = CombinedStream.isStreamLike(stream);
                        if (isStreamLike) {
                            stream.on('data', this._checkDataSize.bind(this));
                            this._handleErrors(stream);
                        }

                        this._pipeNext(stream);
                    }.bind(this)
                );
            };

            CombinedStream.prototype._pipeNext = function (stream) {
                this._currentStream = stream;

                var isStreamLike = CombinedStream.isStreamLike(stream);
                if (isStreamLike) {
                    stream.on('end', this._getNext.bind(this));
                    stream.pipe(this, { end: false });
                    return;
                }

                var value = stream;
                this.write(value);
                this._getNext();
            };

            CombinedStream.prototype._handleErrors = function (stream) {
                var self = this;
                stream.on('error', function (err) {
                    self._emitError(err);
                });
            };

            CombinedStream.prototype.write = function (data) {
                this.emit('data', data);
            };

            CombinedStream.prototype.pause = function () {
                if (!this.pauseStreams) {
                    return;
                }

                if (
                    this.pauseStreams &&
                    this._currentStream &&
                    typeof this._currentStream.pause == 'function'
                )
                    this._currentStream.pause();
                this.emit('pause');
            };

            CombinedStream.prototype.resume = function () {
                if (!this._released) {
                    this._released = true;
                    this.writable = true;
                    this._getNext();
                }

                if (
                    this.pauseStreams &&
                    this._currentStream &&
                    typeof this._currentStream.resume == 'function'
                )
                    this._currentStream.resume();
                this.emit('resume');
            };

            CombinedStream.prototype.end = function () {
                this._reset();
                this.emit('end');
            };

            CombinedStream.prototype.destroy = function () {
                this._reset();
                this.emit('close');
            };

            CombinedStream.prototype._reset = function () {
                this.writable = false;
                this._streams = [];
                this._currentStream = null;
            };

            CombinedStream.prototype._checkDataSize = function () {
                this._updateDataSize();
                if (this.dataSize <= this.maxDataSize) {
                    return;
                }

                var message =
                    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
                this._emitError(new Error(message));
            };

            CombinedStream.prototype._updateDataSize = function () {
                this.dataSize = 0;

                var self = this;
                this._streams.forEach(function (stream) {
                    if (!stream.dataSize) {
                        return;
                    }

                    self.dataSize += stream.dataSize;
                });

                if (this._currentStream && this._currentStream.dataSize) {
                    this.dataSize += this._currentStream.dataSize;
                }
            };

            CombinedStream.prototype._emitError = function (err) {
                this._reset();
                this.emit('error', err);
            };

            /***/
        },
        /* 121 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var Stream = __webpack_require__(14).Stream;
            var util = __webpack_require__(16);

            module.exports = DelayedStream;
            function DelayedStream() {
                this.source = null;
                this.dataSize = 0;
                this.maxDataSize = 1024 * 1024;
                this.pauseStream = true;

                this._maxDataSizeExceeded = false;
                this._released = false;
                this._bufferedEvents = [];
            }
            util.inherits(DelayedStream, Stream);

            DelayedStream.create = function (source, options) {
                var delayedStream = new this();

                options = options || {};
                for (var option in options) {
                    delayedStream[option] = options[option];
                }

                delayedStream.source = source;

                var realEmit = source.emit;
                source.emit = function () {
                    delayedStream._handleEmit(arguments);
                    return realEmit.apply(source, arguments);
                };

                source.on('error', function () {});
                if (delayedStream.pauseStream) {
                    source.pause();
                }

                return delayedStream;
            };

            Object.defineProperty(DelayedStream.prototype, 'readable', {
                configurable: true,
                enumerable: true,
                get: function () {
                    return this.source.readable;
                }
            });

            DelayedStream.prototype.setEncoding = function () {
                return this.source.setEncoding.apply(this.source, arguments);
            };

            DelayedStream.prototype.resume = function () {
                if (!this._released) {
                    this.release();
                }

                this.source.resume();
            };

            DelayedStream.prototype.pause = function () {
                this.source.pause();
            };

            DelayedStream.prototype.release = function () {
                this._released = true;

                this._bufferedEvents.forEach(
                    function (args) {
                        this.emit.apply(this, args);
                    }.bind(this)
                );
                this._bufferedEvents = [];
            };

            DelayedStream.prototype.pipe = function () {
                var r = Stream.prototype.pipe.apply(this, arguments);
                this.resume();
                return r;
            };

            DelayedStream.prototype._handleEmit = function (args) {
                if (this._released) {
                    this.emit.apply(this, args);
                    return;
                }

                if (args[0] === 'data') {
                    this.dataSize += args[1].length;
                    this._checkIfMaxDataSizeExceeded();
                }

                this._bufferedEvents.push(args);
            };

            DelayedStream.prototype._checkIfMaxDataSizeExceeded = function () {
                if (this._maxDataSizeExceeded) {
                    return;
                }

                if (this.dataSize <= this.maxDataSize) {
                    return;
                }

                this._maxDataSizeExceeded = true;
                var message =
                    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
                this.emit('error', new Error(message));
            };

            /***/
        },
        /* 122 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';
            /*!
             * mime-types
             * Copyright(c) 2014 Jonathan Ong
             * Copyright(c) 2015 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module dependencies.
             * @private
             */

            var db = __webpack_require__(123);
            var extname = __webpack_require__(4).extname;

            /**
             * Module variables.
             * @private
             */

            var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
            var TEXT_TYPE_REGEXP = /^text\//i;

            /**
             * Module exports.
             * @public
             */

            exports.charset = charset;
            exports.charsets = { lookup: charset };
            exports.contentType = contentType;
            exports.extension = extension;
            exports.extensions = Object.create(null);
            exports.lookup = lookup;
            exports.types = Object.create(null);

            // Populate the extensions/types maps
            populateMaps(exports.extensions, exports.types);

            /**
             * Get the default charset for a MIME type.
             *
             * @param {string} type
             * @return {boolean|string}
             */

            function charset(type) {
                if (!type || typeof type !== 'string') {
                    return false;
                }

                // TODO: use media-typer
                var match = EXTRACT_TYPE_REGEXP.exec(type);
                var mime = match && db[match[1].toLowerCase()];

                if (mime && mime.charset) {
                    return mime.charset;
                }

                // default text/* to utf-8
                if (match && TEXT_TYPE_REGEXP.test(match[1])) {
                    return 'UTF-8';
                }

                return false;
            }

            /**
             * Create a full Content-Type header given a MIME type or extension.
             *
             * @param {string} str
             * @return {boolean|string}
             */

            function contentType(str) {
                // TODO: should this even be in this module?
                if (!str || typeof str !== 'string') {
                    return false;
                }

                var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;

                if (!mime) {
                    return false;
                }

                // TODO: use content-type or other module
                if (mime.indexOf('charset') === -1) {
                    var charset = exports.charset(mime);
                    if (charset) mime += '; charset=' + charset.toLowerCase();
                }

                return mime;
            }

            /**
             * Get the default extension for a MIME type.
             *
             * @param {string} type
             * @return {boolean|string}
             */

            function extension(type) {
                if (!type || typeof type !== 'string') {
                    return false;
                }

                // TODO: use media-typer
                var match = EXTRACT_TYPE_REGEXP.exec(type);

                // get extensions
                var exts = match && exports.extensions[match[1].toLowerCase()];

                if (!exts || !exts.length) {
                    return false;
                }

                return exts[0];
            }

            /**
             * Lookup the MIME type for a file path/extension.
             *
             * @param {string} path
             * @return {boolean|string}
             */

            function lookup(path) {
                if (!path || typeof path !== 'string') {
                    return false;
                }

                // get the extension ("ext" or ".ext" or full path)
                var extension = extname('x.' + path)
                    .toLowerCase()
                    .substr(1);

                if (!extension) {
                    return false;
                }

                return exports.types[extension] || false;
            }

            /**
             * Populate the extensions and types maps.
             * @private
             */

            function populateMaps(extensions, types) {
                // source preference (least -> most)
                var preference = ['nginx', 'apache', undefined, 'iana'];

                Object.keys(db).forEach(function forEachMimeType(type) {
                    var mime = db[type];
                    var exts = mime.extensions;

                    if (!exts || !exts.length) {
                        return;
                    }

                    // mime -> extensions
                    extensions[type] = exts;

                    // extension -> mime
                    for (var i = 0; i < exts.length; i++) {
                        var extension = exts[i];

                        if (types[extension]) {
                            var from = preference.indexOf(db[types[extension]].source);
                            var to = preference.indexOf(mime.source);

                            if (
                                types[extension] !== 'application/octet-stream' &&
                                (from > to ||
                                    (from === to &&
                                        types[extension].substr(0, 12) === 'application/'))
                            ) {
                                // skip the remapping
                                continue;
                            }
                        }

                        // set the extension -> mime
                        types[extension] = type;
                    }
                });
            }

            /***/
        },
        /* 123 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            /*!
             * mime-db
             * Copyright(c) 2014 Jonathan Ong
             * Copyright(c) 2015-2022 Douglas Christopher Wilson
             * MIT Licensed
             */

            /**
             * Module exports.
             */

            module.exports = __webpack_require__(124);

            /***/
        },
        /* 124 */
        /***/ (module) => {
            'use strict';
            module.exports = JSON.parse(
                '{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}'
            );

            /***/
        },
        /* 125 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            module.exports = {
                parallel: __webpack_require__(126),
                serial: __webpack_require__(133),
                serialOrdered: __webpack_require__(134)
            };

            /***/
        },
        /* 126 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var iterate = __webpack_require__(127),
                initState = __webpack_require__(131),
                terminator = __webpack_require__(132);
            // Public API
            module.exports = parallel;

            /**
             * Runs iterator over provided array elements in parallel
             *
             * @param   {array|object} list - array or object (named list) to iterate over
             * @param   {function} iterator - iterator to run
             * @param   {function} callback - invoked when all elements processed
             * @returns {function} - jobs terminator
             */
            function parallel(list, iterator, callback) {
                var state = initState(list);

                while (state.index < (state['keyedList'] || list).length) {
                    iterate(list, iterator, state, function (error, result) {
                        if (error) {
                            callback(error, result);
                            return;
                        }

                        // looks like it's the last one
                        if (Object.keys(state.jobs).length === 0) {
                            callback(null, state.results);
                            return;
                        }
                    });

                    state.index++;
                }

                return terminator.bind(state, callback);
            }

            /***/
        },
        /* 127 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var async = __webpack_require__(128),
                abort = __webpack_require__(130);
            // API
            module.exports = iterate;

            /**
             * Iterates over each job object
             *
             * @param {array|object} list - array or object (named list) to iterate over
             * @param {function} iterator - iterator to run
             * @param {object} state - current job status
             * @param {function} callback - invoked when all elements processed
             */
            function iterate(list, iterator, state, callback) {
                // store current index
                var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

                state.jobs[key] = runJob(iterator, key, list[key], function (error, output) {
                    // don't repeat yourself
                    // skip secondary callbacks
                    if (!(key in state.jobs)) {
                        return;
                    }

                    // clean up jobs
                    delete state.jobs[key];

                    if (error) {
                        // don't process rest of the results
                        // stop still active jobs
                        // and reset the list
                        abort(state);
                    } else {
                        state.results[key] = output;
                    }

                    // return salvaged results
                    callback(error, state.results);
                });
            }

            /**
             * Runs iterator over provided job element
             *
             * @param   {function} iterator - iterator to invoke
             * @param   {string|number} key - key/index of the element in the list of jobs
             * @param   {mixed} item - job description
             * @param   {function} callback - invoked after iterator is done with the job
             * @returns {function|mixed} - job abort function or something else
             */
            function runJob(iterator, key, item, callback) {
                var aborter;

                // allow shortcut if iterator expects only two arguments
                if (iterator.length == 2) {
                    aborter = iterator(item, async(callback));
                }
                // otherwise go with full three arguments
                else {
                    aborter = iterator(item, key, async(callback));
                }

                return aborter;
            }

            /***/
        },
        /* 128 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var defer = __webpack_require__(129);

            // API
            module.exports = async;

            /**
             * Runs provided callback asynchronously
             * even if callback itself is not
             *
             * @param   {function} callback - callback to invoke
             * @returns {function} - augmented callback
             */
            function async(callback) {
                var isAsync = false;

                // check if async happened
                defer(function () {
                    isAsync = true;
                });

                return function async_callback(err, result) {
                    if (isAsync) {
                        callback(err, result);
                    } else {
                        defer(function nextTick_callback() {
                            callback(err, result);
                        });
                    }
                };
            }

            /***/
        },
        /* 129 */
        /***/ (module) => {
            module.exports = defer;

            /**
             * Runs provided function on next iteration of the event loop
             *
             * @param {function} fn - function to run
             */
            function defer(fn) {
                var nextTick =
                    typeof setImmediate == 'function'
                        ? setImmediate
                        : typeof process == 'object' && typeof process.nextTick == 'function'
                        ? process.nextTick
                        : null;

                if (nextTick) {
                    nextTick(fn);
                } else {
                    setTimeout(fn, 0);
                }
            }

            /***/
        },
        /* 130 */
        /***/ (module) => {
            // API
            module.exports = abort;

            /**
             * Aborts leftover active jobs
             *
             * @param {object} state - current state object
             */
            function abort(state) {
                Object.keys(state.jobs).forEach(clean.bind(state));

                // reset leftover jobs
                state.jobs = {};
            }

            /**
             * Cleans up leftover job by invoking abort function for the provided job id
             *
             * @this  state
             * @param {string|number} key - job id to abort
             */
            function clean(key) {
                if (typeof this.jobs[key] == 'function') {
                    this.jobs[key]();
                }
            }

            /***/
        },
        /* 131 */
        /***/ (module) => {
            // API
            module.exports = state;

            /**
             * Creates initial state object
             * for iteration over list
             *
             * @param   {array|object} list - list to iterate over
             * @param   {function|null} sortMethod - function to use for keys sort,
             *                                     or `null` to keep them as is
             * @returns {object} - initial state object
             */
            function state(list, sortMethod) {
                var isNamedList = !Array.isArray(list),
                    initState = {
                        index: 0,
                        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
                        jobs: {},
                        results: isNamedList ? {} : [],
                        size: isNamedList ? Object.keys(list).length : list.length
                    };
                if (sortMethod) {
                    // sort array keys based on it's values
                    // sort object's keys just on own merit
                    initState.keyedList.sort(
                        isNamedList
                            ? sortMethod
                            : function (a, b) {
                                  return sortMethod(list[a], list[b]);
                              }
                    );
                }

                return initState;
            }

            /***/
        },
        /* 132 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var abort = __webpack_require__(130),
                async = __webpack_require__(128);
            // API
            module.exports = terminator;

            /**
             * Terminates jobs in the attached state context
             *
             * @this  AsyncKitState#
             * @param {function} callback - final callback to invoke after termination
             */
            function terminator(callback) {
                if (!Object.keys(this.jobs).length) {
                    return;
                }

                // fast forward iteration index
                this.index = this.size;

                // abort jobs
                abort(this);

                // send back results we have so far
                async(callback)(null, this.results);
            }

            /***/
        },
        /* 133 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var serialOrdered = __webpack_require__(134);

            // Public API
            module.exports = serial;

            /**
             * Runs iterator over provided array elements in series
             *
             * @param   {array|object} list - array or object (named list) to iterate over
             * @param   {function} iterator - iterator to run
             * @param   {function} callback - invoked when all elements processed
             * @returns {function} - jobs terminator
             */
            function serial(list, iterator, callback) {
                return serialOrdered(list, iterator, null, callback);
            }

            /***/
        },
        /* 134 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var iterate = __webpack_require__(127),
                initState = __webpack_require__(131),
                terminator = __webpack_require__(132);
            // Public API
            module.exports = serialOrdered;
            // sorting helpers
            module.exports.ascending = ascending;
            module.exports.descending = descending;

            /**
             * Runs iterator over provided sorted array elements in series
             *
             * @param   {array|object} list - array or object (named list) to iterate over
             * @param   {function} iterator - iterator to run
             * @param   {function} sortMethod - custom sort function
             * @param   {function} callback - invoked when all elements processed
             * @returns {function} - jobs terminator
             */
            function serialOrdered(list, iterator, sortMethod, callback) {
                var state = initState(list, sortMethod);

                iterate(list, iterator, state, function iteratorHandler(error, result) {
                    if (error) {
                        callback(error, result);
                        return;
                    }

                    state.index++;

                    // are we there yet?
                    if (state.index < (state['keyedList'] || list).length) {
                        iterate(list, iterator, state, iteratorHandler);
                        return;
                    }

                    // done here
                    callback(null, state.results);
                });

                return terminator.bind(state, callback);
            }

            /*
             * -- Sort methods
             */

            /**
             * sort helper to sort array elements in ascending order
             *
             * @param   {mixed} a - an item to compare
             * @param   {mixed} b - an item to compare
             * @returns {number} - comparison result
             */
            function ascending(a, b) {
                return a < b ? -1 : a > b ? 1 : 0;
            }

            /**
             * sort helper to sort array elements in descending order
             *
             * @param   {mixed} a - an item to compare
             * @param   {mixed} b - an item to compare
             * @returns {number} - comparison result
             */
            function descending(a, b) {
                return -1 * ascending(a, b);
            }

            /***/
        },
        /* 135 */
        /***/ (module) => {
            // populates missing values
            module.exports = function (dst, src) {
                Object.keys(src).forEach(function (prop) {
                    dst[prop] = dst[prop] || src[prop];
                });

                return dst;
            };

            /***/
        },
        /* 136 */
        /***/ (module) => {
            'use strict';

            module.exports = function isCancel(value) {
                return !!(value && value.__CANCEL__);
            };

            /***/
        },
        /* 137 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            /**
             * Config-specific merge-function which creates a new config-object
             * by merging two configuration objects together.
             *
             * @param {Object} config1
             * @param {Object} config2
             * @returns {Object} New object resulting from merging config2 to config1
             */
            module.exports = function mergeConfig(config1, config2) {
                // eslint-disable-next-line no-param-reassign
                config2 = config2 || {};
                var config = {};

                function getMergedValue(target, source) {
                    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
                        return utils.merge(target, source);
                    } else if (utils.isPlainObject(source)) {
                        return utils.merge({}, source);
                    } else if (utils.isArray(source)) {
                        return source.slice();
                    }
                    return source;
                }

                // eslint-disable-next-line consistent-return
                function mergeDeepProperties(prop) {
                    if (!utils.isUndefined(config2[prop])) {
                        return getMergedValue(config1[prop], config2[prop]);
                    } else if (!utils.isUndefined(config1[prop])) {
                        return getMergedValue(undefined, config1[prop]);
                    }
                }

                // eslint-disable-next-line consistent-return
                function valueFromConfig2(prop) {
                    if (!utils.isUndefined(config2[prop])) {
                        return getMergedValue(undefined, config2[prop]);
                    }
                }

                // eslint-disable-next-line consistent-return
                function defaultToConfig2(prop) {
                    if (!utils.isUndefined(config2[prop])) {
                        return getMergedValue(undefined, config2[prop]);
                    } else if (!utils.isUndefined(config1[prop])) {
                        return getMergedValue(undefined, config1[prop]);
                    }
                }

                // eslint-disable-next-line consistent-return
                function mergeDirectKeys(prop) {
                    if (prop in config2) {
                        return getMergedValue(config1[prop], config2[prop]);
                    } else if (prop in config1) {
                        return getMergedValue(undefined, config1[prop]);
                    }
                }

                var mergeMap = {
                    url: valueFromConfig2,
                    method: valueFromConfig2,
                    data: valueFromConfig2,
                    baseURL: defaultToConfig2,
                    transformRequest: defaultToConfig2,
                    transformResponse: defaultToConfig2,
                    paramsSerializer: defaultToConfig2,
                    timeout: defaultToConfig2,
                    timeoutMessage: defaultToConfig2,
                    withCredentials: defaultToConfig2,
                    adapter: defaultToConfig2,
                    responseType: defaultToConfig2,
                    xsrfCookieName: defaultToConfig2,
                    xsrfHeaderName: defaultToConfig2,
                    onUploadProgress: defaultToConfig2,
                    onDownloadProgress: defaultToConfig2,
                    decompress: defaultToConfig2,
                    maxContentLength: defaultToConfig2,
                    maxBodyLength: defaultToConfig2,
                    beforeRedirect: defaultToConfig2,
                    transport: defaultToConfig2,
                    httpAgent: defaultToConfig2,
                    httpsAgent: defaultToConfig2,
                    cancelToken: defaultToConfig2,
                    socketPath: defaultToConfig2,
                    responseEncoding: defaultToConfig2,
                    validateStatus: mergeDirectKeys
                };

                utils.forEach(
                    Object.keys(config1).concat(Object.keys(config2)),
                    function computeConfigValue(prop) {
                        var merge = mergeMap[prop] || mergeDeepProperties;
                        var configValue = merge(prop);
                        (utils.isUndefined(configValue) && merge !== mergeDirectKeys) ||
                            (config[prop] = configValue);
                    }
                );

                return config;
            };

            /***/
        },
        /* 138 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var VERSION = __webpack_require__(117).version;
            var AxiosError = __webpack_require__(88);

            var validators = {};

            // eslint-disable-next-line func-names
            ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (
                type,
                i
            ) {
                validators[type] = function validator(thing) {
                    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
                };
            });

            var deprecatedWarnings = {};

            /**
             * Transitional option validator
             * @param {function|boolean?} validator - set to false if the transitional option has been removed
             * @param {string?} version - deprecated version / removed since version
             * @param {string?} message - some message with additional info
             * @returns {function}
             */
            validators.transitional = function transitional(validator, version, message) {
                function formatMessage(opt, desc) {
                    return (
                        '[Axios v' +
                        VERSION +
                        "] Transitional option '" +
                        opt +
                        "'" +
                        desc +
                        (message ? '. ' + message : '')
                    );
                }

                // eslint-disable-next-line func-names
                return function (value, opt, opts) {
                    if (validator === false) {
                        throw new AxiosError(
                            formatMessage(
                                opt,
                                ' has been removed' + (version ? ' in ' + version : '')
                            ),
                            AxiosError.ERR_DEPRECATED
                        );
                    }

                    if (version && !deprecatedWarnings[opt]) {
                        deprecatedWarnings[opt] = true;
                        // eslint-disable-next-line no-console
                        console.warn(
                            formatMessage(
                                opt,
                                ' has been deprecated since v' +
                                    version +
                                    ' and will be removed in the near future'
                            )
                        );
                    }

                    return validator ? validator(value, opt, opts) : true;
                };
            };

            /**
             * Assert object's properties type
             * @param {object} options
             * @param {object} schema
             * @param {boolean?} allowUnknown
             */

            function assertOptions(options, schema, allowUnknown) {
                if (typeof options !== 'object') {
                    throw new AxiosError(
                        'options must be an object',
                        AxiosError.ERR_BAD_OPTION_VALUE
                    );
                }
                var keys = Object.keys(options);
                var i = keys.length;
                while (i-- > 0) {
                    var opt = keys[i];
                    var validator = schema[opt];
                    if (validator) {
                        var value = options[opt];
                        var result = value === undefined || validator(value, opt, options);
                        if (result !== true) {
                            throw new AxiosError(
                                'option ' + opt + ' must be ' + result,
                                AxiosError.ERR_BAD_OPTION_VALUE
                            );
                        }
                        continue;
                    }
                    if (allowUnknown !== true) {
                        throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
                    }
                }
            }

            module.exports = {
                assertOptions: assertOptions,
                validators: validators
            };

            /***/
        },
        /* 139 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var CanceledError = __webpack_require__(99);

            /**
             * A `CancelToken` is an object that can be used to request cancellation of an operation.
             *
             * @class
             * @param {Function} executor The executor function.
             */
            function CancelToken(executor) {
                if (typeof executor !== 'function') {
                    throw new TypeError('executor must be a function.');
                }

                var resolvePromise;

                this.promise = new Promise(function promiseExecutor(resolve) {
                    resolvePromise = resolve;
                });

                var token = this;

                // eslint-disable-next-line func-names
                this.promise.then(function (cancel) {
                    if (!token._listeners) return;

                    var i;
                    var l = token._listeners.length;

                    for (i = 0; i < l; i++) {
                        token._listeners[i](cancel);
                    }
                    token._listeners = null;
                });

                // eslint-disable-next-line func-names
                this.promise.then = function (onfulfilled) {
                    var _resolve;
                    // eslint-disable-next-line func-names
                    var promise = new Promise(function (resolve) {
                        token.subscribe(resolve);
                        _resolve = resolve;
                    }).then(onfulfilled);

                    promise.cancel = function reject() {
                        token.unsubscribe(_resolve);
                    };

                    return promise;
                };

                executor(function cancel(message) {
                    if (token.reason) {
                        // Cancellation has already been requested
                        return;
                    }

                    token.reason = new CanceledError(message);
                    resolvePromise(token.reason);
                });
            }

            /**
             * Throws a `CanceledError` if cancellation has been requested.
             */
            CancelToken.prototype.throwIfRequested = function throwIfRequested() {
                if (this.reason) {
                    throw this.reason;
                }
            };

            /**
             * Subscribe to the cancel signal
             */

            CancelToken.prototype.subscribe = function subscribe(listener) {
                if (this.reason) {
                    listener(this.reason);
                    return;
                }

                if (this._listeners) {
                    this._listeners.push(listener);
                } else {
                    this._listeners = [listener];
                }
            };

            /**
             * Unsubscribe from the cancel signal
             */

            CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
                if (!this._listeners) {
                    return;
                }
                var index = this._listeners.indexOf(listener);
                if (index !== -1) {
                    this._listeners.splice(index, 1);
                }
            };

            /**
             * Returns an object that contains a new `CancelToken` and a function that, when called,
             * cancels the `CancelToken`.
             */
            CancelToken.source = function source() {
                var cancel;
                var token = new CancelToken(function executor(c) {
                    cancel = c;
                });
                return {
                    token: token,
                    cancel: cancel
                };
            };

            module.exports = CancelToken;

            /***/
        },
        /* 140 */
        /***/ (module) => {
            'use strict';

            /**
             * Syntactic sugar for invoking a function and expanding an array for arguments.
             *
             * Common use case would be to use `Function.prototype.apply`.
             *
             *  ```js
             *  function f(x, y, z) {}
             *  var args = [1, 2, 3];
             *  f.apply(null, args);
             *  ```
             *
             * With `spread` this example can be re-written.
             *
             *  ```js
             *  spread(function(x, y, z) {})([1, 2, 3]);
             *  ```
             *
             * @param {Function} callback
             * @returns {Function}
             */
            module.exports = function spread(callback) {
                return function wrap(arr) {
                    return callback.apply(null, arr);
                };
            };

            /***/
        },
        /* 141 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            var utils = __webpack_require__(79);

            /**
             * Determines whether the payload is an error thrown by Axios
             *
             * @param {*} payload The value to test
             * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
             */
            module.exports = function isAxiosError(payload) {
                return utils.isObject(payload) && payload.isAxiosError === true;
            };

            /***/
        },
        /* 142 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.getPatcher = void 0;
            var hot_patcher_1 = __importDefault(__webpack_require__(143));
            var __patcher = null;
            function getPatcher() {
                if (!__patcher) {
                    __patcher = new hot_patcher_1.default();
                }
                return __patcher;
            }
            exports.getPatcher = getPatcher;

            /***/
        },
        /* 143 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            const { sequence } = __webpack_require__(144);

            const HOT_PATCHER_TYPE = '@@HOTPATCHER';
            const NOOP = () => {};

            function createNewItem(method) {
                return {
                    original: method,
                    methods: [method],
                    final: false
                };
            }

            /**
             * Hot patching manager class
             */
            class HotPatcher {
                constructor() {
                    this._configuration = {
                        registry: {},
                        getEmptyAction: 'null'
                    };
                    this.__type__ = HOT_PATCHER_TYPE;
                }

                /**
                 * Configuration object reference
                 * @type {Object}
                 * @memberof HotPatcher
                 * @readonly
                 */
                get configuration() {
                    return this._configuration;
                }

                /**
                 * The action to take when a non-set method is requested
                 * Possible values: null/throw
                 * @type {String}
                 * @memberof HotPatcher
                 */
                get getEmptyAction() {
                    return this.configuration.getEmptyAction;
                }

                set getEmptyAction(newAction) {
                    this.configuration.getEmptyAction = newAction;
                }

                /**
                 * Control another hot-patcher instance
                 * Force the remote instance to use patched methods from calling instance
                 * @param {HotPatcher} target The target instance to control
                 * @param {Boolean=} allowTargetOverrides Allow the target to override patched methods on
                 * the controller (default is false)
                 * @memberof HotPatcher
                 * @returns {HotPatcher} Returns self
                 * @throws {Error} Throws if the target is invalid
                 */
                control(target, allowTargetOverrides = false) {
                    if (!target || target.__type__ !== HOT_PATCHER_TYPE) {
                        throw new Error(
                            'Failed taking control of target HotPatcher instance: Invalid type or object'
                        );
                    }
                    Object.keys(target.configuration.registry).forEach((foreignKey) => {
                        if (this.configuration.registry.hasOwnProperty(foreignKey)) {
                            if (allowTargetOverrides) {
                                this.configuration.registry[foreignKey] = Object.assign(
                                    {},
                                    target.configuration.registry[foreignKey]
                                );
                            }
                        } else {
                            this.configuration.registry[foreignKey] = Object.assign(
                                {},
                                target.configuration.registry[foreignKey]
                            );
                        }
                    });
                    target._configuration = this.configuration;
                    return this;
                }

                /**
                 * Execute a patched method
                 * @param {String} key The method key
                 * @param {...*} args Arguments to pass to the method (optional)
                 * @memberof HotPatcher
                 * @see HotPatcher#get
                 * @returns {*} The output of the called method
                 */
                execute(key, ...args) {
                    const method = this.get(key) || NOOP;
                    return method(...args);
                }

                /**
                 * Get a method for a key
                 * @param {String} key The method key
                 * @returns {Function|null} Returns the requested function or null if the function
                 * does not exist and the host is configured to return null (and not throw)
                 * @memberof HotPatcher
                 * @throws {Error} Throws if the configuration specifies to throw and the method
                 * does not exist
                 * @throws {Error} Throws if the `getEmptyAction` value is invalid
                 */
                get(key) {
                    const item = this.configuration.registry[key];
                    if (!item) {
                        switch (this.getEmptyAction) {
                            case 'null':
                                return null;
                            case 'throw':
                                throw new Error(
                                    `Failed handling method request: No method provided for override: ${key}`
                                );
                            default:
                                throw new Error(
                                    `Failed handling request which resulted in an empty method: Invalid empty-action specified: ${this.getEmptyAction}`
                                );
                        }
                    }
                    return sequence(...item.methods);
                }

                /**
                 * Check if a method has been patched
                 * @param {String} key The function key
                 * @returns {Boolean} True if already patched
                 * @memberof HotPatcher
                 */
                isPatched(key) {
                    return !!this.configuration.registry[key];
                }

                /**
                 * @typedef {Object} PatchOptions
                 * @property {Boolean=} chain - Whether or not to allow chaining execution. Chained
                 *  execution allows for attaching multiple callbacks to a key, where the callbacks
                 *  will be executed in order of when they were patched (oldest to newest), the
                 *  values being passed from one method to another.
                 */

                /**
                 * Patch a method name
                 * @param {String} key The method key to patch
                 * @param {Function} method The function to set
                 * @param {PatchOptions=} options Patch options
                 * @memberof HotPatcher
                 * @returns {HotPatcher} Returns self
                 */
                patch(key, method, { chain = false } = {}) {
                    if (
                        this.configuration.registry[key] &&
                        this.configuration.registry[key].final
                    ) {
                        throw new Error(`Failed patching '${key}': Method marked as being final`);
                    }
                    if (typeof method !== 'function') {
                        throw new Error(
                            `Failed patching '${key}': Provided method is not a function`
                        );
                    }
                    if (chain) {
                        // Add new method to the chain
                        if (!this.configuration.registry[key]) {
                            // New key, create item
                            this.configuration.registry[key] = createNewItem(method);
                        } else {
                            // Existing, push the method
                            this.configuration.registry[key].methods.push(method);
                        }
                    } else {
                        // Replace the original
                        if (this.isPatched(key)) {
                            const { original } = this.configuration.registry[key];
                            this.configuration.registry[key] = Object.assign(
                                createNewItem(method),
                                {
                                    original
                                }
                            );
                        } else {
                            this.configuration.registry[key] = createNewItem(method);
                        }
                    }
                    return this;
                }

                /**
                 * Patch a method inline, execute it and return the value
                 * Used for patching contents of functions. This method will not apply a patched
                 * function if it has already been patched, allowing for external overrides to
                 * function. It also means that the function is cached so that it is not
                 * instantiated every time the outer function is invoked.
                 * @param {String} key The function key to use
                 * @param {Function} method The function to patch (once, only if not patched)
                 * @param {...*} args Arguments to pass to the function
                 * @returns {*} The output of the patched function
                 * @memberof HotPatcher
                 * @example
                 *  function mySpecialFunction(a, b) {
                 *      return hotPatcher.patchInline("func", (a, b) => {
                 *          return a + b;
                 *      }, a, b);
                 *  }
                 */
                patchInline(key, method, ...args) {
                    if (!this.isPatched(key)) {
                        this.patch(key, method);
                    }
                    return this.execute(key, ...args);
                }

                /**
                 * Patch a method (or methods) in sequential-mode
                 * See `patch()` with the option `chain: true`
                 * @see patch
                 * @param {String} key The key to patch
                 * @param {...Function} methods The methods to patch
                 * @returns {HotPatcher} Returns self
                 * @memberof HotPatcher
                 */
                plugin(key, ...methods) {
                    methods.forEach((method) => {
                        this.patch(key, method, { chain: true });
                    });
                    return this;
                }

                /**
                 * Restore a patched method if it has been overridden
                 * @param {String} key The method key
                 * @memberof HotPatcher
                 */
                restore(key) {
                    if (!this.isPatched(key)) {
                        throw new Error(
                            `Failed restoring method: No method present for key: ${key}`
                        );
                    } else if (typeof this.configuration.registry[key].original !== 'function') {
                        throw new Error(
                            `Failed restoring method: Original method not found or of invalid type for key: ${key}`
                        );
                    }
                    this.configuration.registry[key].methods = [
                        this.configuration.registry[key].original
                    ];
                }

                /**
                 * Set a method as being final
                 * This sets a method as having been finally overridden. Attempts at overriding
                 * again will fail with an error.
                 * @param {String} key The key to make final
                 * @memberof HotPatcher
                 * @returns {HotPatcher} Returns self
                 */
                setFinal(key) {
                    if (!this.configuration.registry.hasOwnProperty(key)) {
                        throw new Error(
                            `Failed marking '${key}' as final: No method found for key`
                        );
                    }
                    this.configuration.registry[key].final = true;
                    return this;
                }
            }

            module.exports = HotPatcher;

            /***/
        },
        /* 144 */
        /***/ (module) => {
            function sequence(...methods) {
                if (methods.length === 0) {
                    throw new Error('Failed creating sequence: No functions provided');
                }
                return function __executeSequence(...args) {
                    let result = args;
                    const _this = this;
                    while (methods.length > 0) {
                        const method = methods.shift();
                        result = [method.apply(_this, result)];
                    }
                    return result[0];
                };
            }

            module.exports = {
                sequence
            };

            /***/
        },
        /* 145 */
        /***/ function (__unused_webpack_module, exports) {
            'use strict';

            var __spreadArray =
                (this && this.__spreadArray) ||
                function (to, from, pack) {
                    if (pack || arguments.length === 2)
                        for (var i = 0, l = from.length, ar; i < l; i++) {
                            if (ar || !(i in from)) {
                                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                                ar[i] = from[i];
                            }
                        }
                    return to.concat(ar || Array.prototype.slice.call(from));
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.merge = exports.cloneShallow = void 0;
            function cloneShallow(obj) {
                return isPlainObject(obj)
                    ? Object.assign({}, obj)
                    : Object.setPrototypeOf(Object.assign({}, obj), Object.getPrototypeOf(obj));
            }
            exports.cloneShallow = cloneShallow;
            function isPlainObject(obj) {
                if (
                    typeof obj !== 'object' ||
                    obj === null ||
                    Object.prototype.toString.call(obj) != '[object Object]'
                ) {
                    // Not an object
                    return false;
                }
                if (Object.getPrototypeOf(obj) === null) {
                    return true;
                }
                var proto = obj;
                // Find the prototype
                while (Object.getPrototypeOf(proto) !== null) {
                    proto = Object.getPrototypeOf(proto);
                }
                return Object.getPrototypeOf(obj) === proto;
            }
            function merge() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var output = null,
                    items = __spreadArray([], args, true);
                while (items.length > 0) {
                    var nextItem = items.shift();
                    if (!output) {
                        output = cloneShallow(nextItem);
                    } else {
                        output = mergeObjects(output, nextItem);
                    }
                }
                return output;
            }
            exports.merge = merge;
            function mergeObjects(obj1, obj2) {
                var output = cloneShallow(obj1);
                Object.keys(obj2).forEach(function (key) {
                    if (!output.hasOwnProperty(key)) {
                        output[key] = obj2[key];
                        return;
                    }
                    if (Array.isArray(obj2[key])) {
                        output[key] = Array.isArray(output[key])
                            ? __spreadArray(__spreadArray([], output[key], true), obj2[key], true)
                            : __spreadArray([], obj2[key], true);
                    } else if (typeof obj2[key] === 'object' && !!obj2[key]) {
                        output[key] =
                            typeof output[key] === 'object' && !!output[key]
                                ? mergeObjects(output[key], obj2[key])
                                : cloneShallow(obj2[key]);
                    } else {
                        output[key] = obj2[key];
                    }
                });
                return output;
            }

            /***/
        },
        /* 146 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.mergeHeaders = void 0;
            function mergeHeaders() {
                var headerPayloads = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    headerPayloads[_i] = arguments[_i];
                }
                if (headerPayloads.length === 0) return {};
                var headerKeys = {};
                return headerPayloads.reduce(function (output, headers) {
                    Object.keys(headers).forEach(function (header) {
                        var lowerHeader = header.toLowerCase();
                        if (headerKeys.hasOwnProperty(lowerHeader)) {
                            output[headerKeys[lowerHeader]] = headers[header];
                        } else {
                            headerKeys[lowerHeader] = header;
                            output[header] = headers[header];
                        }
                    });
                    return output;
                }, {});
            }
            exports.mergeHeaders = mergeHeaders;

            /***/
        },
        /* 147 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.processResponsePayload =
                exports.processGlobFilter =
                exports.handleResponseCode =
                exports.createErrorFromResponse =
                    void 0;
            var minimatch_1 = __importDefault(__webpack_require__(148));
            function createErrorFromResponse(response, prefix) {
                if (prefix === void 0) {
                    prefix = '';
                }
                var err = new Error(
                    ''
                        .concat(prefix, 'Invalid response: ')
                        .concat(response.status, ' ')
                        .concat(response.statusText)
                );
                err.status = response.status;
                err.response = response;
                return err;
            }
            exports.createErrorFromResponse = createErrorFromResponse;
            function handleResponseCode(context, response) {
                var status = response.status;
                if (status === 401 && context.digest) return response;
                if (status >= 400) {
                    var err = createErrorFromResponse(response);
                    throw err;
                }
                return response;
            }
            exports.handleResponseCode = handleResponseCode;
            function processGlobFilter(files, glob) {
                return files.filter(function (file) {
                    return (0, minimatch_1.default)(file.filename, glob, { matchBase: true });
                });
            }
            exports.processGlobFilter = processGlobFilter;
            function processResponsePayload(response, data, isDetailed) {
                if (isDetailed === void 0) {
                    isDetailed = false;
                }
                return isDetailed
                    ? {
                          data: data,
                          headers: response.headers || {},
                          status: response.status,
                          statusText: response.statusText
                      }
                    : data;
            }
            exports.processResponsePayload = processResponsePayload;

            /***/
        },
        /* 148 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            const minimatch = (module.exports = (p, pattern, options = {}) => {
                assertValidPattern(pattern);

                // shortcut: comments match nothing.
                if (!options.nocomment && pattern.charAt(0) === '#') {
                    return false;
                }

                return new Minimatch(pattern, options).match(p);
            });

            module.exports = minimatch;

            const path = __webpack_require__(149);
            minimatch.sep = path.sep;

            const GLOBSTAR = Symbol('globstar **');
            minimatch.GLOBSTAR = GLOBSTAR;
            const expand = __webpack_require__(150);

            const plTypes = {
                '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
                '?': { open: '(?:', close: ')?' },
                '+': { open: '(?:', close: ')+' },
                '*': { open: '(?:', close: ')*' },
                '@': { open: '(?:', close: ')' }
            };

            // any single thing other than /
            // don't need to escape / when using new RegExp()
            const qmark = '[^/]';

            // * => any number of characters
            const star = qmark + '*?';

            // ** when dots are allowed.  Anything goes, except .. and .
            // not (^ or / followed by one or two dots followed by $ or /),
            // followed by anything, any number of times.
            const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';

            // not a ^ or / followed by a dot,
            // followed by anything, any number of times.
            const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';

            // "abc" -> { a:true, b:true, c:true }
            const charSet = (s) =>
                s.split('').reduce((set, c) => {
                    set[c] = true;
                    return set;
                }, {});

            // characters that need to be escaped in RegExp.
            const reSpecials = charSet('().*{}+?[]^$\\!');

            // characters that indicate we have to add the pattern start
            const addPatternStartSet = charSet('[.(');

            // normalizes slashes.
            const slashSplit = /\/+/;

            minimatch.filter =
                (pattern, options = {}) =>
                (p, i, list) =>
                    minimatch(p, pattern, options);

            const ext = (a, b = {}) => {
                const t = {};
                Object.keys(a).forEach((k) => (t[k] = a[k]));
                Object.keys(b).forEach((k) => (t[k] = b[k]));
                return t;
            };

            minimatch.defaults = (def) => {
                if (!def || typeof def !== 'object' || !Object.keys(def).length) {
                    return minimatch;
                }

                const orig = minimatch;

                const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
                m.Minimatch = class Minimatch extends orig.Minimatch {
                    constructor(pattern, options) {
                        super(pattern, ext(def, options));
                    }
                };
                m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
                m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
                m.defaults = (options) => orig.defaults(ext(def, options));
                m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
                m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
                m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));

                return m;
            };

            // Brace expansion:
            // a{b,c}d -> abd acd
            // a{b,}c -> abc ac
            // a{0..3}d -> a0d a1d a2d a3d
            // a{b,c{d,e}f}g -> abg acdfg acefg
            // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
            //
            // Invalid sets are not expanded.
            // a{2..}b -> a{2..}b
            // a{b}c -> a{b}c
            minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);

            const braceExpand = (pattern, options = {}) => {
                assertValidPattern(pattern);

                // Thanks to Yeting Li <https://github.com/yetingli> for
                // improving this regexp to avoid a ReDOS vulnerability.
                if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
                    // shortcut. no need to expand.
                    return [pattern];
                }

                return expand(pattern);
            };

            const MAX_PATTERN_LENGTH = 1024 * 64;
            const assertValidPattern = (pattern) => {
                if (typeof pattern !== 'string') {
                    throw new TypeError('invalid pattern');
                }

                if (pattern.length > MAX_PATTERN_LENGTH) {
                    throw new TypeError('pattern is too long');
                }
            };

            // parse a component of the expanded set.
            // At this point, no pattern may contain "/" in it
            // so we're going to return a 2d array, where each entry is the full
            // pattern, split on '/', and then turned into a regular expression.
            // A regexp is made at the end which joins each array with an
            // escaped /, and another full one which joins each regexp with |.
            //
            // Following the lead of Bash 4.1, note that "**" only has special meaning
            // when it is the *only* thing in a path portion.  Otherwise, any series
            // of * is equivalent to a single *.  Globstar behavior is enabled by
            // default, and can be disabled by setting options.noglobstar.
            const SUBPARSE = Symbol('subparse');

            minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();

            minimatch.match = (list, pattern, options = {}) => {
                const mm = new Minimatch(pattern, options);
                list = list.filter((f) => mm.match(f));
                if (mm.options.nonull && !list.length) {
                    list.push(pattern);
                }
                return list;
            };

            // replace stuff like \* with *
            const globUnescape = (s) => s.replace(/\\(.)/g, '$1');
            const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');

            class Minimatch {
                constructor(pattern, options) {
                    assertValidPattern(pattern);

                    if (!options) options = {};

                    this.options = options;
                    this.set = [];
                    this.pattern = pattern;
                    this.windowsPathsNoEscape =
                        !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
                    if (this.windowsPathsNoEscape) {
                        this.pattern = this.pattern.replace(/\\/g, '/');
                    }
                    this.regexp = null;
                    this.negate = false;
                    this.comment = false;
                    this.empty = false;
                    this.partial = !!options.partial;

                    // make the set of regexps etc.
                    this.make();
                }

                debug() {}

                make() {
                    const pattern = this.pattern;
                    const options = this.options;

                    // empty patterns and comments match nothing.
                    if (!options.nocomment && pattern.charAt(0) === '#') {
                        this.comment = true;
                        return;
                    }
                    if (!pattern) {
                        this.empty = true;
                        return;
                    }

                    // step 1: figure out negation, etc.
                    this.parseNegate();

                    // step 2: expand braces
                    let set = (this.globSet = this.braceExpand());

                    if (options.debug) this.debug = (...args) => console.error(...args);

                    this.debug(this.pattern, set);

                    // step 3: now we have a set, so turn each one into a series of path-portion
                    // matching patterns.
                    // These will be regexps, except in the case of "**", which is
                    // set to the GLOBSTAR object for globstar behavior,
                    // and will not contain any / characters
                    set = this.globParts = set.map((s) => s.split(slashSplit));

                    this.debug(this.pattern, set);

                    // glob --> regexps
                    set = set.map((s, si, set) => s.map(this.parse, this));

                    this.debug(this.pattern, set);

                    // filter out everything that didn't compile properly.
                    set = set.filter((s) => s.indexOf(false) === -1);

                    this.debug(this.pattern, set);

                    this.set = set;
                }

                parseNegate() {
                    if (this.options.nonegate) return;

                    const pattern = this.pattern;
                    let negate = false;
                    let negateOffset = 0;

                    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
                        negate = !negate;
                        negateOffset++;
                    }

                    if (negateOffset) this.pattern = pattern.substr(negateOffset);
                    this.negate = negate;
                }

                // set partial to true to test if, for example,
                // "/a/b" matches the start of "/*/b/*/d"
                // Partial means, if you run out of file before you run
                // out of pattern, then that's fine, as long as all
                // the parts match.
                matchOne(file, pattern, partial) {
                    var options = this.options;

                    this.debug('matchOne', { this: this, file: file, pattern: pattern });

                    this.debug('matchOne', file.length, pattern.length);

                    for (
                        var fi = 0, pi = 0, fl = file.length, pl = pattern.length;
                        fi < fl && pi < pl;
                        fi++, pi++
                    ) {
                        this.debug('matchOne loop');
                        var p = pattern[pi];
                        var f = file[fi];

                        this.debug(pattern, p, f);

                        // should be impossible.
                        // some invalid regexp stuff in the set.
                        /* istanbul ignore if */
                        if (p === false) return false;

                        if (p === GLOBSTAR) {
                            this.debug('GLOBSTAR', [pattern, p, f]);

                            // "**"
                            // a/**/b/**/c would match the following:
                            // a/b/x/y/z/c
                            // a/x/y/z/b/c
                            // a/b/x/b/x/c
                            // a/b/c
                            // To do this, take the rest of the pattern after
                            // the **, and see if it would match the file remainder.
                            // If so, return success.
                            // If not, the ** "swallows" a segment, and try again.
                            // This is recursively awful.
                            //
                            // a/**/b/**/c matching a/b/x/y/z/c
                            // - a matches a
                            // - doublestar
                            //   - matchOne(b/x/y/z/c, b/**/c)
                            //     - b matches b
                            //     - doublestar
                            //       - matchOne(x/y/z/c, c) -> no
                            //       - matchOne(y/z/c, c) -> no
                            //       - matchOne(z/c, c) -> no
                            //       - matchOne(c, c) yes, hit
                            var fr = fi;
                            var pr = pi + 1;
                            if (pr === pl) {
                                this.debug('** at the end');
                                // a ** at the end will just swallow the rest.
                                // We have found a match.
                                // however, it will not swallow /.x, unless
                                // options.dot is set.
                                // . and .. are *never* matched by **, for explosively
                                // exponential reasons.
                                for (; fi < fl; fi++) {
                                    if (
                                        file[fi] === '.' ||
                                        file[fi] === '..' ||
                                        (!options.dot && file[fi].charAt(0) === '.')
                                    )
                                        return false;
                                }
                                return true;
                            }

                            // ok, let's see if we can swallow whatever we can.
                            while (fr < fl) {
                                var swallowee = file[fr];

                                this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

                                // XXX remove this slice.  Just pass the start index.
                                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                                    this.debug('globstar found match!', fr, fl, swallowee);
                                    // found a match.
                                    return true;
                                } else {
                                    // can't swallow "." or ".." ever.
                                    // can only swallow ".foo" when explicitly asked.
                                    if (
                                        swallowee === '.' ||
                                        swallowee === '..' ||
                                        (!options.dot && swallowee.charAt(0) === '.')
                                    ) {
                                        this.debug('dot detected!', file, fr, pattern, pr);
                                        break;
                                    }

                                    // ** swallows a segment, and continue.
                                    this.debug('globstar swallow a segment, and continue');
                                    fr++;
                                }
                            }

                            // no match was found.
                            // However, in partial mode, we can't say this is necessarily over.
                            // If there's more *pattern* left, then
                            /* istanbul ignore if */
                            if (partial) {
                                // ran out of file
                                this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                                if (fr === fl) return true;
                            }
                            return false;
                        }

                        // something other than **
                        // non-magic patterns just have to match exactly
                        // patterns with magic have been turned into regexps.
                        var hit;
                        if (typeof p === 'string') {
                            hit = f === p;
                            this.debug('string match', p, f, hit);
                        } else {
                            hit = f.match(p);
                            this.debug('pattern match', p, f, hit);
                        }

                        if (!hit) return false;
                    }

                    // Note: ending in / means that we'll get a final ""
                    // at the end of the pattern.  This can only match a
                    // corresponding "" at the end of the file.
                    // If the file ends in /, then it can only match a
                    // a pattern that ends in /, unless the pattern just
                    // doesn't have any more for it. But, a/b/ should *not*
                    // match "a/b/*", even though "" matches against the
                    // [^/]*? pattern, except in partial mode, where it might
                    // simply not be reached yet.
                    // However, a/b/ should still satisfy a/*

                    // now either we fell off the end of the pattern, or we're done.
                    if (fi === fl && pi === pl) {
                        // ran out of pattern and filename at the same time.
                        // an exact hit!
                        return true;
                    } else if (fi === fl) {
                        // ran out of file, but still had pattern left.
                        // this is ok if we're doing the match as part of
                        // a glob fs traversal.
                        return partial;
                    } /* istanbul ignore else */ else if (pi === pl) {
                        // ran out of pattern, still have file left.
                        // this is only acceptable if we're on the very last
                        // empty segment of a file with a trailing slash.
                        // a/* should match a/b/
                        return fi === fl - 1 && file[fi] === '';
                    }

                    // should be unreachable.
                    /* istanbul ignore next */
                    throw new Error('wtf?');
                }

                braceExpand() {
                    return braceExpand(this.pattern, this.options);
                }

                parse(pattern, isSub) {
                    assertValidPattern(pattern);

                    const options = this.options;

                    // shortcuts
                    if (pattern === '**') {
                        if (!options.noglobstar) return GLOBSTAR;
                        else pattern = '*';
                    }
                    if (pattern === '') return '';

                    let re = '';
                    let hasMagic = !!options.nocase;
                    let escaping = false;
                    // ? => one single character
                    const patternListStack = [];
                    const negativeLists = [];
                    let stateChar;
                    let inClass = false;
                    let reClassStart = -1;
                    let classStart = -1;
                    let cs;
                    let pl;
                    let sp;
                    // . and .. never match anything that doesn't start with .,
                    // even when options.dot is set.
                    const patternStart =
                        pattern.charAt(0) === '.'
                            ? '' // anything
                            : // not (start or / followed by . or .. followed by / or end)
                            options.dot
                            ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))'
                            : '(?!\\.)';

                    const clearStateChar = () => {
                        if (stateChar) {
                            // we had some state-tracking character
                            // that wasn't consumed by this pass.
                            switch (stateChar) {
                                case '*':
                                    re += star;
                                    hasMagic = true;
                                    break;
                                case '?':
                                    re += qmark;
                                    hasMagic = true;
                                    break;
                                default:
                                    re += '\\' + stateChar;
                                    break;
                            }
                            this.debug('clearStateChar %j %j', stateChar, re);
                            stateChar = false;
                        }
                    };

                    for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
                        this.debug('%s\t%s %s %j', pattern, i, re, c);

                        // skip over any that are escaped.
                        if (escaping) {
                            /* istanbul ignore next - completely not allowed, even escaped. */
                            if (c === '/') {
                                return false;
                            }

                            if (reSpecials[c]) {
                                re += '\\';
                            }
                            re += c;
                            escaping = false;
                            continue;
                        }

                        switch (c) {
                            /* istanbul ignore next */
                            case '/': {
                                // Should already be path-split by now.
                                return false;
                            }

                            case '\\':
                                clearStateChar();
                                escaping = true;
                                continue;

                            // the various stateChar values
                            // for the "extglob" stuff.
                            case '?':
                            case '*':
                            case '+':
                            case '@':
                            case '!':
                                this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

                                // all of those are literals inside a class, except that
                                // the glob [!a] means [^a] in regexp
                                if (inClass) {
                                    this.debug('  in class');
                                    if (c === '!' && i === classStart + 1) c = '^';
                                    re += c;
                                    continue;
                                }

                                // if we already have a stateChar, then it means
                                // that there was something like ** or +? in there.
                                // Handle the stateChar, then proceed with this one.
                                this.debug('call clearStateChar %j', stateChar);
                                clearStateChar();
                                stateChar = c;
                                // if extglob is disabled, then +(asdf|foo) isn't a thing.
                                // just clear the statechar *now*, rather than even diving into
                                // the patternList stuff.
                                if (options.noext) clearStateChar();
                                continue;

                            case '(':
                                if (inClass) {
                                    re += '(';
                                    continue;
                                }

                                if (!stateChar) {
                                    re += '\\(';
                                    continue;
                                }

                                patternListStack.push({
                                    type: stateChar,
                                    start: i - 1,
                                    reStart: re.length,
                                    open: plTypes[stateChar].open,
                                    close: plTypes[stateChar].close
                                });
                                // negation is (?:(?!js)[^/]*)
                                re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
                                this.debug('plType %j %j', stateChar, re);
                                stateChar = false;
                                continue;

                            case ')':
                                if (inClass || !patternListStack.length) {
                                    re += '\\)';
                                    continue;
                                }

                                clearStateChar();
                                hasMagic = true;
                                pl = patternListStack.pop();
                                // negation is (?:(?!js)[^/]*)
                                // The others are (?:<pattern>)<type>
                                re += pl.close;
                                if (pl.type === '!') {
                                    negativeLists.push(pl);
                                }
                                pl.reEnd = re.length;
                                continue;

                            case '|':
                                if (inClass || !patternListStack.length) {
                                    re += '\\|';
                                    continue;
                                }

                                clearStateChar();
                                re += '|';
                                continue;

                            // these are mostly the same in regexp and glob
                            case '[':
                                // swallow any state-tracking char before the [
                                clearStateChar();

                                if (inClass) {
                                    re += '\\' + c;
                                    continue;
                                }

                                inClass = true;
                                classStart = i;
                                reClassStart = re.length;
                                re += c;
                                continue;

                            case ']':
                                //  a right bracket shall lose its special
                                //  meaning and represent itself in
                                //  a bracket expression if it occurs
                                //  first in the list.  -- POSIX.2 2.8.3.2
                                if (i === classStart + 1 || !inClass) {
                                    re += '\\' + c;
                                    continue;
                                }

                                // handle the case where we left a class open.
                                // "[z-a]" is valid, equivalent to "\[z-a\]"
                                // split where the last [ was, make sure we don't have
                                // an invalid re. if so, re-walk the contents of the
                                // would-be class to re-translate any characters that
                                // were passed through as-is
                                // TODO: It would probably be faster to determine this
                                // without a try/catch and a new RegExp, but it's tricky
                                // to do safely.  For now, this is safe and works.
                                cs = pattern.substring(classStart + 1, i);
                                try {
                                    RegExp('[' + cs + ']');
                                } catch (er) {
                                    // not a valid class!
                                    sp = this.parse(cs, SUBPARSE);
                                    re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
                                    hasMagic = hasMagic || sp[1];
                                    inClass = false;
                                    continue;
                                }

                                // finish up the class.
                                hasMagic = true;
                                inClass = false;
                                re += c;
                                continue;

                            default:
                                // swallow any state char that wasn't consumed
                                clearStateChar();

                                if (reSpecials[c] && !(c === '^' && inClass)) {
                                    re += '\\';
                                }

                                re += c;
                                break;
                        } // switch
                    } // for

                    // handle the case where we left a class open.
                    // "[abc" is valid, equivalent to "\[abc"
                    if (inClass) {
                        // split where the last [ was, and escape it
                        // this is a huge pita.  We now have to re-walk
                        // the contents of the would-be class to re-translate
                        // any characters that were passed through as-is
                        cs = pattern.substr(classStart + 1);
                        sp = this.parse(cs, SUBPARSE);
                        re = re.substr(0, reClassStart) + '\\[' + sp[0];
                        hasMagic = hasMagic || sp[1];
                    }

                    // handle the case where we had a +( thing at the *end*
                    // of the pattern.
                    // each pattern list stack adds 3 chars, and we need to go through
                    // and escape any | chars that were passed through as-is for the regexp.
                    // Go through and escape them, taking care not to double-escape any
                    // | chars that were already escaped.
                    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
                        let tail;
                        tail = re.slice(pl.reStart + pl.open.length);
                        this.debug('setting tail', re, pl);
                        // maybe some even number of \, then maybe 1 \, followed by a |
                        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
                            /* istanbul ignore else - should already be done */
                            if (!$2) {
                                // the | isn't already escaped, so escape it.
                                $2 = '\\';
                            }

                            // need to escape all those slashes *again*, without escaping the
                            // one that we need for escaping the | character.  As it works out,
                            // escaping an even number of slashes can be done by simply repeating
                            // it exactly after itself.  That's why this trick works.
                            //
                            // I am sorry that you have to see this.
                            return $1 + $1 + $2 + '|';
                        });

                        this.debug('tail=%j\n   %s', tail, tail, pl, re);
                        const t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;

                        hasMagic = true;
                        re = re.slice(0, pl.reStart) + t + '\\(' + tail;
                    }

                    // handle trailing things that only matter at the very end.
                    clearStateChar();
                    if (escaping) {
                        // trailing \\
                        re += '\\\\';
                    }

                    // only need to apply the nodot start if the re starts with
                    // something that could conceivably capture a dot
                    const addPatternStart = addPatternStartSet[re.charAt(0)];

                    // Hack to work around lack of negative lookbehind in JS
                    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
                    // like 'a.xyz.yz' doesn't match.  So, the first negative
                    // lookahead, has to look ALL the way ahead, to the end of
                    // the pattern.
                    for (let n = negativeLists.length - 1; n > -1; n--) {
                        const nl = negativeLists[n];

                        const nlBefore = re.slice(0, nl.reStart);
                        const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
                        let nlAfter = re.slice(nl.reEnd);
                        const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;

                        // Handle nested stuff like *(*.js|!(*.json)), where open parens
                        // mean that we should *not* include the ) in the bit that is considered
                        // "after" the negated section.
                        const openParensBefore = nlBefore.split('(').length - 1;
                        let cleanAfter = nlAfter;
                        for (let i = 0; i < openParensBefore; i++) {
                            cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
                        }
                        nlAfter = cleanAfter;

                        const dollar = nlAfter === '' && isSub !== SUBPARSE ? '$' : '';
                        re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
                    }

                    // if the re is not "" at this point, then we need to make sure
                    // it doesn't match against an empty path part.
                    // Otherwise a/* will match a/, which it should not.
                    if (re !== '' && hasMagic) {
                        re = '(?=.)' + re;
                    }

                    if (addPatternStart) {
                        re = patternStart + re;
                    }

                    // parsing just a piece of a larger pattern.
                    if (isSub === SUBPARSE) {
                        return [re, hasMagic];
                    }

                    // skip the regexp for non-magical patterns
                    // unescape anything in it, though, so that it'll be
                    // an exact match against a file etc.
                    if (!hasMagic) {
                        return globUnescape(pattern);
                    }

                    const flags = options.nocase ? 'i' : '';
                    try {
                        return Object.assign(new RegExp('^' + re + '$', flags), {
                            _glob: pattern,
                            _src: re
                        });
                    } catch (er) /* istanbul ignore next - should be impossible */ {
                        // If it was an invalid regular expression, then it can't match
                        // anything.  This trick looks for a character after the end of
                        // the string, which is of course impossible, except in multi-line
                        // mode, but it's not a /m regex.
                        return new RegExp('$.');
                    }
                }

                makeRe() {
                    if (this.regexp || this.regexp === false) return this.regexp;

                    // at this point, this.set is a 2d array of partial
                    // pattern strings, or "**".
                    //
                    // It's better to use .match().  This function shouldn't
                    // be used, really, but it's pretty convenient sometimes,
                    // when you just want to work with a regex.
                    const set = this.set;

                    if (!set.length) {
                        this.regexp = false;
                        return this.regexp;
                    }
                    const options = this.options;

                    const twoStar = options.noglobstar
                        ? star
                        : options.dot
                        ? twoStarDot
                        : twoStarNoDot;
                    const flags = options.nocase ? 'i' : '';

                    // coalesce globstars and regexpify non-globstar patterns
                    // if it's the only item, then we just do one twoStar
                    // if it's the first, and there are more, prepend (\/|twoStar\/)? to next
                    // if it's the last, append (\/twoStar|) to previous
                    // if it's in the middle, append (\/|\/twoStar\/) to previous
                    // then filter out GLOBSTAR symbols
                    let re = set
                        .map((pattern) => {
                            pattern = pattern
                                .map((p) =>
                                    typeof p === 'string'
                                        ? regExpEscape(p)
                                        : p === GLOBSTAR
                                        ? GLOBSTAR
                                        : p._src
                                )
                                .reduce((set, p) => {
                                    if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
                                        set.push(p);
                                    }
                                    return set;
                                }, []);
                            pattern.forEach((p, i) => {
                                if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
                                    return;
                                }
                                if (i === 0) {
                                    if (pattern.length > 1) {
                                        pattern[i + 1] =
                                            '(?:\\/|' + twoStar + '\\/)?' + pattern[i + 1];
                                    } else {
                                        pattern[i] = twoStar;
                                    }
                                } else if (i === pattern.length - 1) {
                                    pattern[i - 1] += '(?:\\/|' + twoStar + ')?';
                                } else {
                                    pattern[i - 1] +=
                                        '(?:\\/|\\/' + twoStar + '\\/)' + pattern[i + 1];
                                    pattern[i + 1] = GLOBSTAR;
                                }
                            });
                            return pattern.filter((p) => p !== GLOBSTAR).join('/');
                        })
                        .join('|');

                    // must match entire pattern
                    // ending in a * or ** will make it less strict.
                    re = '^(?:' + re + ')$';

                    // can match anything, as long as it's not this.
                    if (this.negate) re = '^(?!' + re + ').*$';

                    try {
                        this.regexp = new RegExp(re, flags);
                    } catch (ex) /* istanbul ignore next - should be impossible */ {
                        this.regexp = false;
                    }
                    return this.regexp;
                }

                match(f, partial = this.partial) {
                    this.debug('match', f, this.pattern);
                    // short-circuit in the case of busted things.
                    // comments, etc.
                    if (this.comment) return false;
                    if (this.empty) return f === '';

                    if (f === '/' && partial) return true;

                    const options = this.options;

                    // windows: need to use /, not \
                    if (path.sep !== '/') {
                        f = f.split(path.sep).join('/');
                    }

                    // treat the test path as a set of pathparts.
                    f = f.split(slashSplit);
                    this.debug(this.pattern, 'split', f);

                    // just ONE of the pattern sets in this.set needs to match
                    // in order for it to be valid.  If negating, then just one
                    // match means that we have failed.
                    // Either way, return on the first hit.

                    const set = this.set;
                    this.debug(this.pattern, 'set', set);

                    // Find the basename of the path by looking for the last non-empty segment
                    let filename;
                    for (let i = f.length - 1; i >= 0; i--) {
                        filename = f[i];
                        if (filename) break;
                    }

                    for (let i = 0; i < set.length; i++) {
                        const pattern = set[i];
                        let file = f;
                        if (options.matchBase && pattern.length === 1) {
                            file = [filename];
                        }
                        const hit = this.matchOne(file, pattern, partial);
                        if (hit) {
                            if (options.flipNegate) return true;
                            return !this.negate;
                        }
                    }

                    // didn't get any hits.  this is success if it's a negative
                    // pattern, failure otherwise.
                    if (options.flipNegate) return false;
                    return this.negate;
                }

                static defaults(def) {
                    return minimatch.defaults(def).Minimatch;
                }
            }

            minimatch.Minimatch = Minimatch;

            /***/
        },
        /* 149 */
        /***/ (module) => {
            const isWindows =
                typeof process === 'object' && process && process.platform === 'win32';
            module.exports = isWindows ? { sep: '\\' } : { sep: '/' };

            /***/
        },
        /* 150 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            var balanced = __webpack_require__(151);

            module.exports = expandTop;

            var escSlash = '\0SLASH' + Math.random() + '\0';
            var escOpen = '\0OPEN' + Math.random() + '\0';
            var escClose = '\0CLOSE' + Math.random() + '\0';
            var escComma = '\0COMMA' + Math.random() + '\0';
            var escPeriod = '\0PERIOD' + Math.random() + '\0';

            function numeric(str) {
                return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
            }

            function escapeBraces(str) {
                return str
                    .split('\\\\')
                    .join(escSlash)
                    .split('\\{')
                    .join(escOpen)
                    .split('\\}')
                    .join(escClose)
                    .split('\\,')
                    .join(escComma)
                    .split('\\.')
                    .join(escPeriod);
            }

            function unescapeBraces(str) {
                return str
                    .split(escSlash)
                    .join('\\')
                    .split(escOpen)
                    .join('{')
                    .split(escClose)
                    .join('}')
                    .split(escComma)
                    .join(',')
                    .split(escPeriod)
                    .join('.');
            }

            // Basically just str.split(","), but handling cases
            // where we have nested braced sections, which should be
            // treated as individual members, like {a,{b,c},d}
            function parseCommaParts(str) {
                if (!str) return [''];

                var parts = [];
                var m = balanced('{', '}', str);

                if (!m) return str.split(',');

                var pre = m.pre;
                var body = m.body;
                var post = m.post;
                var p = pre.split(',');

                p[p.length - 1] += '{' + body + '}';
                var postParts = parseCommaParts(post);
                if (post.length) {
                    p[p.length - 1] += postParts.shift();
                    p.push.apply(p, postParts);
                }

                parts.push.apply(parts, p);

                return parts;
            }

            function expandTop(str) {
                if (!str) return [];

                // I don't know why Bash 4.3 does this, but it does.
                // Anything starting with {} will have the first two bytes preserved
                // but *only* at the top level, so {},a}b will not expand to anything,
                // but a{},b}c will be expanded to [a}c,abc].
                // One could argue that this is a bug in Bash, but since the goal of
                // this module is to match Bash's rules, we escape a leading {}
                if (str.substr(0, 2) === '{}') {
                    str = '\\{\\}' + str.substr(2);
                }

                return expand(escapeBraces(str), true).map(unescapeBraces);
            }

            function embrace(str) {
                return '{' + str + '}';
            }
            function isPadded(el) {
                return /^-?0\d/.test(el);
            }

            function lte(i, y) {
                return i <= y;
            }
            function gte(i, y) {
                return i >= y;
            }

            function expand(str, isTop) {
                var expansions = [];

                var m = balanced('{', '}', str);
                if (!m) return [str];

                // no need to expand pre, since it is guaranteed to be free of brace-sets
                var pre = m.pre;
                var post = m.post.length ? expand(m.post, false) : [''];

                if (/\$$/.test(m.pre)) {
                    for (var k = 0; k < post.length; k++) {
                        var expansion = pre + '{' + m.body + '}' + post[k];
                        expansions.push(expansion);
                    }
                } else {
                    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
                    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
                    var isSequence = isNumericSequence || isAlphaSequence;
                    var isOptions = m.body.indexOf(',') >= 0;
                    if (!isSequence && !isOptions) {
                        // {a},b}
                        if (m.post.match(/,.*\}/)) {
                            str = m.pre + '{' + m.body + escClose + m.post;
                            return expand(str);
                        }
                        return [str];
                    }

                    var n;
                    if (isSequence) {
                        n = m.body.split(/\.\./);
                    } else {
                        n = parseCommaParts(m.body);
                        if (n.length === 1) {
                            // x{{a,b}}y ==> x{a}y x{b}y
                            n = expand(n[0], false).map(embrace);
                            if (n.length === 1) {
                                return post.map(function (p) {
                                    return m.pre + n[0] + p;
                                });
                            }
                        }
                    }

                    // at this point, n is the parts, and we know it's not a comma set
                    // with a single entry.
                    var N;

                    if (isSequence) {
                        var x = numeric(n[0]);
                        var y = numeric(n[1]);
                        var width = Math.max(n[0].length, n[1].length);
                        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
                        var test = lte;
                        var reverse = y < x;
                        if (reverse) {
                            incr *= -1;
                            test = gte;
                        }
                        var pad = n.some(isPadded);

                        N = [];

                        for (var i = x; test(i, y); i += incr) {
                            var c;
                            if (isAlphaSequence) {
                                c = String.fromCharCode(i);
                                if (c === '\\') c = '';
                            } else {
                                c = String(i);
                                if (pad) {
                                    var need = width - c.length;
                                    if (need > 0) {
                                        var z = new Array(need + 1).join('0');
                                        if (i < 0) c = '-' + z + c.slice(1);
                                        else c = z + c;
                                    }
                                }
                            }
                            N.push(c);
                        }
                    } else {
                        N = [];

                        for (var j = 0; j < n.length; j++) {
                            N.push.apply(N, expand(n[j], false));
                        }
                    }

                    for (var j = 0; j < N.length; j++) {
                        for (var k = 0; k < post.length; k++) {
                            var expansion = pre + N[j] + post[k];
                            if (!isTop || isSequence || expansion) expansions.push(expansion);
                        }
                    }
                }

                return expansions;
            }

            /***/
        },
        /* 151 */
        /***/ (module) => {
            'use strict';

            module.exports = balanced;
            function balanced(a, b, str) {
                if (a instanceof RegExp) a = maybeMatch(a, str);
                if (b instanceof RegExp) b = maybeMatch(b, str);

                var r = range(a, b, str);

                return (
                    r && {
                        start: r[0],
                        end: r[1],
                        pre: str.slice(0, r[0]),
                        body: str.slice(r[0] + a.length, r[1]),
                        post: str.slice(r[1] + b.length)
                    }
                );
            }

            function maybeMatch(reg, str) {
                var m = str.match(reg);
                return m ? m[0] : null;
            }

            balanced.range = range;
            function range(a, b, str) {
                var begs, beg, left, right, result;
                var ai = str.indexOf(a);
                var bi = str.indexOf(b, ai + 1);
                var i = ai;

                if (ai >= 0 && bi > 0) {
                    if (a === b) {
                        return [ai, bi];
                    }
                    begs = [];
                    left = str.length;

                    while (i >= 0 && !result) {
                        if (i == ai) {
                            begs.push(i);
                            ai = str.indexOf(a, i + 1);
                        } else if (begs.length == 1) {
                            result = [begs.pop(), bi];
                        } else {
                            beg = begs.pop();
                            if (beg < left) {
                                left = beg;
                                right = bi;
                            }

                            bi = str.indexOf(b, i + 1);
                        }

                        i = ai < bi && ai >= 0 ? ai : bi;
                    }

                    if (begs.length) {
                        result = [left, right];
                    }
                }

                return result;
            }

            /***/
        },
        /* 152 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __assign =
                (this && this.__assign) ||
                function () {
                    __assign =
                        Object.assign ||
                        function (t) {
                            for (var s, i = 1, n = arguments.length; i < n; i++) {
                                s = arguments[i];
                                for (var p in s)
                                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                            }
                            return t;
                        };
                    return __assign.apply(this, arguments);
                };
            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.createDirectory = void 0;
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            var stat_1 = __webpack_require__(153);
            function createDirectory(context, dirPath, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var requestOptions, response;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (options.recursive === true)
                                    return [
                                        2 /*return*/,
                                        createDirectoryRecursively(context, dirPath, options)
                                    ];
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            ensureCollectionPath((0, path_1.encodePath)(dirPath))
                                        ),
                                        method: 'MKCOL'
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [2 /*return*/];
                        }
                    });
                });
            }
            exports.createDirectory = createDirectory;
            /**
             * Ensure the path is a proper "collection" path by ensuring it has a trailing "/".
             * The proper format of collection according to the specification does contain the trailing slash.
             * http://www.webdav.org/specs/rfc4918.html#rfc.section.5.2
             * @param path Path of the collection
             * @return string Path of the collection with appended trailing "/" in case the `path` does not have it.
             */
            function ensureCollectionPath(path) {
                if (!path.endsWith('/')) {
                    return path + '/';
                }
                return path;
            }
            function createDirectoryRecursively(context, dirPath, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var paths, creating, _i, paths_1, testPath, testStat, err_1, error;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                paths = (0, path_1.getAllDirectories)(
                                    (0, path_1.normalisePath)(dirPath)
                                );
                                paths.sort(function (a, b) {
                                    if (a.length > b.length) {
                                        return 1;
                                    } else if (b.length > a.length) {
                                        return -1;
                                    }
                                    return 0;
                                });
                                creating = false;
                                (_i = 0), (paths_1 = paths);
                                _a.label = 1;
                            case 1:
                                if (!(_i < paths_1.length)) return [3 /*break*/, 10];
                                testPath = paths_1[_i];
                                if (!creating) return [3 /*break*/, 3];
                                return [
                                    4 /*yield*/,
                                    createDirectory(
                                        context,
                                        testPath,
                                        __assign(__assign({}, options), { recursive: false })
                                    )
                                ];
                            case 2:
                                _a.sent();
                                return [3 /*break*/, 9];
                            case 3:
                                _a.trys.push([3, 5, , 9]);
                                return [4 /*yield*/, (0, stat_1.getStat)(context, testPath)];
                            case 4:
                                testStat = _a.sent();
                                if (testStat.type !== 'directory') {
                                    throw new Error('Path includes a file: '.concat(dirPath));
                                }
                                return [3 /*break*/, 9];
                            case 5:
                                err_1 = _a.sent();
                                error = err_1;
                                if (!(error.status === 404)) return [3 /*break*/, 7];
                                creating = true;
                                return [
                                    4 /*yield*/,
                                    createDirectory(
                                        context,
                                        testPath,
                                        __assign(__assign({}, options), { recursive: false })
                                    )
                                ];
                            case 6:
                                _a.sent();
                                return [3 /*break*/, 8];
                            case 7:
                                throw err_1;
                            case 8:
                                return [3 /*break*/, 9];
                            case 9:
                                _i++;
                                return [3 /*break*/, 1];
                            case 10:
                                return [2 /*return*/];
                        }
                    });
                });
            }

            /***/
        },
        /* 153 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.getStat = void 0;
            var dav_1 = __webpack_require__(154);
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            function getStat(context, filename, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var _a, isDetailed, requestOptions, response, result, stat;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                (_a = options.details), (isDetailed = _a === void 0 ? false : _a);
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(filename)
                                        ),
                                        method: 'PROPFIND',
                                        headers: {
                                            Accept: 'text/plain,application/xml',
                                            Depth: '0'
                                        },
                                        responseType: 'text'
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _b.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [4 /*yield*/, (0, dav_1.parseXML)(response.data)];
                            case 2:
                                result = _b.sent();
                                stat = (0, dav_1.parseStat)(result, filename, isDetailed);
                                return [
                                    2 /*return*/,
                                    (0, response_1.processResponsePayload)(
                                        response,
                                        stat,
                                        isDetailed
                                    )
                                ];
                        }
                    });
                });
            }
            exports.getStat = getStat;

            /***/
        },
        /* 154 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.translateDiskSpace =
                exports.parseStat =
                exports.prepareFileFromProps =
                exports.parseXML =
                    void 0;
            var path_posix_1 = __importDefault(__webpack_require__(56));
            var fast_xml_parser_1 = __importDefault(__webpack_require__(155));
            var nested_property_1 = __importDefault(__webpack_require__(165));
            var encode_1 = __webpack_require__(70);
            var path_1 = __webpack_require__(55);
            var PropertyType;
            (function (PropertyType) {
                PropertyType['Array'] = 'array';
                PropertyType['Object'] = 'object';
                PropertyType['Original'] = 'original';
            })(PropertyType || (PropertyType = {}));
            function getPropertyOfType(obj, prop, type) {
                if (type === void 0) {
                    type = PropertyType.Original;
                }
                var val = nested_property_1.default.get(obj, prop);
                if (type === 'array' && Array.isArray(val) === false) {
                    return [val];
                } else if (type === 'object' && Array.isArray(val)) {
                    return val[0];
                }
                return val;
            }
            function normaliseResponse(response) {
                var output = Object.assign({}, response);
                nested_property_1.default.set(
                    output,
                    'propstat',
                    getPropertyOfType(output, 'propstat', PropertyType.Object)
                );
                nested_property_1.default.set(
                    output,
                    'propstat.prop',
                    getPropertyOfType(output, 'propstat.prop', PropertyType.Object)
                );
                return output;
            }
            function normaliseResult(result) {
                var multistatus = result.multistatus;
                if (multistatus === '') {
                    return {
                        multistatus: {
                            response: []
                        }
                    };
                }
                if (!multistatus) {
                    throw new Error('Invalid response: No root multistatus found');
                }
                var output = {
                    multistatus: Array.isArray(multistatus) ? multistatus[0] : multistatus
                };
                nested_property_1.default.set(
                    output,
                    'multistatus.response',
                    getPropertyOfType(output, 'multistatus.response', PropertyType.Array)
                );
                nested_property_1.default.set(
                    output,
                    'multistatus.response',
                    nested_property_1.default
                        .get(output, 'multistatus.response')
                        .map(function (response) {
                            return normaliseResponse(response);
                        })
                );
                return output;
            }
            function parseXML(xml) {
                return new Promise(function (resolve) {
                    var result = fast_xml_parser_1.default.parse(xml, {
                        arrayMode: false,
                        ignoreNameSpace: true
                        // // We don't use the processors here as decoding is done manually
                        // // later on - decoding early would break some path checks.
                        // attrValueProcessor: val => decodeHTMLEntities(decodeURIComponent(val)),
                        // tagValueProcessor: val => decodeHTMLEntities(decodeURIComponent(val))
                    });
                    resolve(normaliseResult(result));
                });
            }
            exports.parseXML = parseXML;
            function prepareFileFromProps(props, rawFilename, isDetailed) {
                if (isDetailed === void 0) {
                    isDetailed = false;
                }
                // Last modified time, raw size, item type and mime
                var _a = props.getlastModifyified,
                    lastMod = _a === void 0 ? null : _a,
                    _b = props.getcontentlength,
                    rawSize = _b === void 0 ? '0' : _b,
                    _c = props.resourcetype,
                    resourceType = _c === void 0 ? null : _c,
                    _d = props.getcontenttype,
                    mimeType = _d === void 0 ? null : _d,
                    _e = props.getetag,
                    etag = _e === void 0 ? null : _e;
                var type =
                    resourceType &&
                    typeof resourceType === 'object' &&
                    typeof resourceType.collection !== 'undefined'
                        ? 'directory'
                        : 'file';
                var filename = (0, encode_1.decodeHTMLEntities)(rawFilename);
                var stat = {
                    filename: filename,
                    basename: path_posix_1.default.basename(filename),
                    lastModify: lastMod,
                    size: parseInt(rawSize, 10),
                    type: type,
                    etag: typeof etag === 'string' ? etag.replace(/"/g, '') : null
                };
                if (type === 'file') {
                    stat.mime =
                        mimeType && typeof mimeType === 'string' ? mimeType.split(';')[0] : '';
                }
                if (isDetailed) {
                    stat.props = props;
                }
                return stat;
            }
            exports.prepareFileFromProps = prepareFileFromProps;
            function parseStat(result, filename, isDetailed) {
                if (isDetailed === void 0) {
                    isDetailed = false;
                }
                var responseItem = null;
                try {
                    responseItem = result.multistatus.response[0];
                } catch (e) {
                    /* ignore */
                }
                if (!responseItem) {
                    throw new Error('Failed getting item stat: bad response');
                }
                var _a = responseItem.propstat,
                    props = _a.prop,
                    statusLine = _a.status;
                // As defined in https://tools.ietf.org/html/rfc2068#section-6.1
                var _b = statusLine.split(' ', 3),
                    _ = _b[0],
                    statusCodeStr = _b[1],
                    statusText = _b[2];
                var statusCode = parseInt(statusCodeStr, 10);
                if (statusCode >= 400) {
                    var err = new Error(
                        'Invalid response: '.concat(statusCode, ' ').concat(statusText)
                    );
                    err.status = statusCode;
                    throw err;
                }
                var filePath = (0, path_1.normalisePath)(filename);
                return prepareFileFromProps(props, filePath, isDetailed);
            }
            exports.parseStat = parseStat;
            function translateDiskSpace(value) {
                switch (value.toString()) {
                    case '-3':
                        return 'unlimited';
                    case '-2':
                    /* falls-through */
                    case '-1':
                        // -1 is non-computed
                        return 'unknown';
                    default:
                        return parseInt(value, 10);
                }
            }
            exports.translateDiskSpace = translateDiskSpace;

            /***/
        },
        /* 155 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            const nodeToJson = __webpack_require__(156);
            const xmlToNodeobj = __webpack_require__(158);
            const x2xmlnode = __webpack_require__(158);
            const buildOptions = __webpack_require__(157).buildOptions;
            const validator = __webpack_require__(161);

            exports.parse = function (xmlData, givenOptions = {}, validationOption) {
                if (validationOption) {
                    if (validationOption === true) validationOption = {};

                    const result = validator.validate(xmlData, validationOption);
                    if (result !== true) {
                        throw Error(result.err.msg);
                    }
                }
                if (
                    givenOptions.parseTrueNumberOnly &&
                    givenOptions.parseNodeValue !== false &&
                    !givenOptions.numParseOptions
                ) {
                    givenOptions.numParseOptions = {
                        leadingZeros: false
                    };
                }
                let options = buildOptions(givenOptions, x2xmlnode.defaultOptions, x2xmlnode.props);

                const traversableObj = xmlToNodeobj.getTraversalObj(xmlData, options);
                //print(traversableObj, "  ");
                return nodeToJson.convertToJson(traversableObj, options);
            };
            exports.convertTonimn = __webpack_require__(162).convert2nimn;
            exports.getTraversalObj = xmlToNodeobj.getTraversalObj;
            exports.convertToJson = nodeToJson.convertToJson;
            exports.convertToJsonString = __webpack_require__(163).convertToJsonString;
            exports.validate = validator.validate;
            exports.j2xParser = __webpack_require__(164);
            exports.parseToNimn = function (xmlData, schema, options) {
                return exports.convertTonimn(
                    exports.getTraversalObj(xmlData, options),
                    schema,
                    options
                );
            };

            function print(xmlNode, indentation) {
                if (xmlNode) {
                    console.log(indentation + '{');
                    console.log(indentation + '  "tagName": "' + xmlNode.tagname + '", ');
                    if (xmlNode.parent) {
                        console.log(indentation + '  "parent": "' + xmlNode.parent.tagname + '", ');
                    }
                    console.log(indentation + '  "val": "' + xmlNode.val + '", ');
                    console.log(
                        indentation +
                            '  "attrs": ' +
                            JSON.stringify(xmlNode.attrsMap, null, 4) +
                            ', '
                    );

                    if (xmlNode.child) {
                        console.log(indentation + '"child": {');
                        const indentation2 = indentation + indentation;
                        Object.keys(xmlNode.child).forEach(function (key) {
                            const node = xmlNode.child[key];

                            if (Array.isArray(node)) {
                                console.log(indentation + '"' + key + '" :[');
                                node.forEach(function (item, index) {
                                    //console.log(indentation + " \""+index+"\" : [")
                                    print(item, indentation2);
                                });
                                console.log(indentation + '],');
                            } else {
                                console.log(indentation + ' "' + key + '" : {');
                                print(node, indentation2);
                                console.log(indentation + '},');
                            }
                        });
                        console.log(indentation + '},');
                    }
                    console.log(indentation + '},');
                }
            }

            /***/
        },
        /* 156 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            const util = __webpack_require__(157);

            const convertToJson = function (node, options, parentTagName) {
                const jObj = {};

                // when no child node or attr is present
                if (
                    !options.alwaysCreateTextNode &&
                    (!node.child || util.isEmptyObject(node.child)) &&
                    (!node.attrsMap || util.isEmptyObject(node.attrsMap))
                ) {
                    return util.isExist(node.val) ? node.val : '';
                }

                // otherwise create a textnode if node has some text
                if (
                    util.isExist(node.val) &&
                    !(
                        typeof node.val === 'string' &&
                        (node.val === '' || node.val === options.cdataPositionChar)
                    )
                ) {
                    const asArray = util.isTagNameInArrayMode(
                        node.tagname,
                        options.arrayMode,
                        parentTagName
                    );
                    jObj[options.textNodeName] = asArray ? [node.val] : node.val;
                }

                util.merge(jObj, node.attrsMap, options.arrayMode);

                const keys = Object.keys(node.child);
                for (let index = 0; index < keys.length; index++) {
                    const tagName = keys[index];
                    if (node.child[tagName] && node.child[tagName].length > 1) {
                        jObj[tagName] = [];
                        for (let tag in node.child[tagName]) {
                            if (node.child[tagName].hasOwnProperty(tag)) {
                                jObj[tagName].push(
                                    convertToJson(node.child[tagName][tag], options, tagName)
                                );
                            }
                        }
                    } else {
                        const result = convertToJson(node.child[tagName][0], options, tagName);
                        const asArray =
                            (options.arrayMode === true && typeof result === 'object') ||
                            util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);
                        jObj[tagName] = asArray ? [result] : result;
                    }
                }

                //add value
                return jObj;
            };

            exports.convertToJson = convertToJson;

            /***/
        },
        /* 157 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            const nameStartChar =
                ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
            const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
            const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';
            const regexName = new RegExp('^' + nameRegexp + '$');

            const getAllMatches = function (string, regex) {
                const matches = [];
                let match = regex.exec(string);
                while (match) {
                    const allmatches = [];
                    allmatches.startIndex = regex.lastIndex - match[0].length;
                    const len = match.length;
                    for (let index = 0; index < len; index++) {
                        allmatches.push(match[index]);
                    }
                    matches.push(allmatches);
                    match = regex.exec(string);
                }
                return matches;
            };

            const isName = function (string) {
                const match = regexName.exec(string);
                return !(match === null || typeof match === 'undefined');
            };

            exports.isExist = function (v) {
                return typeof v !== 'undefined';
            };

            exports.isEmptyObject = function (obj) {
                return Object.keys(obj).length === 0;
            };

            /**
             * Copy all the properties of a into b.
             * @param {*} target
             * @param {*} a
             */
            exports.merge = function (target, a, arrayMode) {
                if (a) {
                    const keys = Object.keys(a); // will return an array of own properties
                    const len = keys.length; //don't make it inline
                    for (let i = 0; i < len; i++) {
                        if (arrayMode === 'strict') {
                            target[keys[i]] = [a[keys[i]]];
                        } else {
                            target[keys[i]] = a[keys[i]];
                        }
                    }
                }
            };
            /* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

            exports.getValue = function (v) {
                if (exports.isExist(v)) {
                    return v;
                } else {
                    return '';
                }
            };

            // const fakeCall = function(a) {return a;};
            // const fakeCallNoReturn = function() {};

            exports.buildOptions = function (options, defaultOptions, props) {
                let newOptions = {};
                if (!options) {
                    return defaultOptions; //if there are not options
                }

                for (let i = 0; i < props.length; i++) {
                    if (options[props[i]] !== undefined) {
                        newOptions[props[i]] = options[props[i]];
                    } else {
                        newOptions[props[i]] = defaultOptions[props[i]];
                    }
                }
                return newOptions;
            };

            /**
             * Check if a tag name should be treated as array
             *
             * @param tagName the node tagname
             * @param arrayMode the array mode option
             * @param parentTagName the parent tag name
             * @returns {boolean} true if node should be parsed as array
             */
            exports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {
                if (arrayMode === false) {
                    return false;
                } else if (arrayMode instanceof RegExp) {
                    return arrayMode.test(tagName);
                } else if (typeof arrayMode === 'function') {
                    return !!arrayMode(tagName, parentTagName);
                }

                return arrayMode === 'strict';
            };

            exports.isName = isName;
            exports.getAllMatches = getAllMatches;
            exports.nameRegexp = nameRegexp;

            /***/
        },
        /* 158 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            const util = __webpack_require__(157);
            const buildOptions = __webpack_require__(157).buildOptions;
            const xmlNode = __webpack_require__(159);
            const toNumber = __webpack_require__(160);

            const regx =
                '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'.replace(
                    /NAME/g,
                    util.nameRegexp
                );

            //const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
            //const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

            //polyfill
            if (!Number.parseInt && window.parseInt) {
                Number.parseInt = window.parseInt;
            }
            if (!Number.parseFloat && window.parseFloat) {
                Number.parseFloat = window.parseFloat;
            }

            const defaultOptions = {
                attributeNamePrefix: '@_',
                attrNodeName: false,
                textNodeName: '#text',
                ignoreAttributes: true,
                ignoreNameSpace: false,
                allowBooleanAttributes: false, //a tag can have attributes without any value
                //ignoreRootElement : false,
                parseNodeValue: true,
                parseAttributeValue: false,
                arrayMode: false,
                trimValues: true, //Trim string values of tag and attributes
                cdataTagName: false,
                cdataPositionChar: '\\c',
                numParseOptions: {
                    hex: true,
                    leadingZeros: true
                },
                tagValueProcessor: function (a, tagName) {
                    return a;
                },
                attrValueProcessor: function (a, attrName) {
                    return a;
                },
                stopNodes: [],
                alwaysCreateTextNode: false
                //decodeStrict: false,
            };

            exports.defaultOptions = defaultOptions;

            const props = [
                'attributeNamePrefix',
                'attrNodeName',
                'textNodeName',
                'ignoreAttributes',
                'ignoreNameSpace',
                'allowBooleanAttributes',
                'parseNodeValue',
                'parseAttributeValue',
                'arrayMode',
                'trimValues',
                'cdataTagName',
                'cdataPositionChar',
                'tagValueProcessor',
                'attrValueProcessor',
                'parseTrueNumberOnly',
                'numParseOptions',
                'stopNodes',
                'alwaysCreateTextNode'
            ];
            exports.props = props;

            /**
             * Trim -> valueProcessor -> parse value
             * @param {string} tagName
             * @param {string} val
             * @param {object} options
             */
            function processTagValue(tagName, val, options) {
                if (val) {
                    if (options.trimValues) {
                        val = val.trim();
                    }
                    val = options.tagValueProcessor(val, tagName);
                    val = parseValue(val, options.parseNodeValue, options.numParseOptions);
                }

                return val;
            }

            function resolveNameSpace(tagname, options) {
                if (options.ignoreNameSpace) {
                    const tags = tagname.split(':');
                    const prefix = tagname.charAt(0) === '/' ? '/' : '';
                    if (tags[0] === 'xmlns') {
                        return '';
                    }
                    if (tags.length === 2) {
                        tagname = prefix + tags[1];
                    }
                }
                return tagname;
            }

            function parseValue(val, shouldParse, options) {
                if (shouldParse && typeof val === 'string') {
                    //console.log(options)
                    const newval = val.trim();
                    if (newval === 'true') return true;
                    else if (newval === 'false') return false;
                    else return toNumber(val, options);
                } else {
                    if (util.isExist(val)) {
                        return val;
                    } else {
                        return '';
                    }
                }
            }

            //TODO: change regex to capture NS
            //const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
            const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])(.*?)\\3)?', 'g');

            function buildAttributesMap(attrStr, options) {
                if (!options.ignoreAttributes && typeof attrStr === 'string') {
                    attrStr = attrStr.replace(/\r?\n/g, ' ');
                    //attrStr = attrStr || attrStr.trim();

                    const matches = util.getAllMatches(attrStr, attrsRegx);
                    const len = matches.length; //don't make it inline
                    const attrs = {};
                    for (let i = 0; i < len; i++) {
                        const attrName = resolveNameSpace(matches[i][1], options);
                        if (attrName.length) {
                            if (matches[i][4] !== undefined) {
                                if (options.trimValues) {
                                    matches[i][4] = matches[i][4].trim();
                                }
                                matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);
                                attrs[options.attributeNamePrefix + attrName] = parseValue(
                                    matches[i][4],
                                    options.parseAttributeValue,
                                    options.numParseOptions
                                );
                            } else if (options.allowBooleanAttributes) {
                                attrs[options.attributeNamePrefix + attrName] = true;
                            }
                        }
                    }
                    if (!Object.keys(attrs).length) {
                        return;
                    }
                    if (options.attrNodeName) {
                        const attrCollection = {};
                        attrCollection[options.attrNodeName] = attrs;
                        return attrCollection;
                    }
                    return attrs;
                }
            }

            const getTraversalObj = function (xmlData, options) {
                xmlData = xmlData.replace(/\r\n?/g, '\n');
                options = buildOptions(options, defaultOptions, props);
                const xmlObj = new xmlNode('!xml');
                let currentNode = xmlObj;
                let textData = '';

                //function match(xmlData){
                for (let i = 0; i < xmlData.length; i++) {
                    const ch = xmlData[i];
                    if (ch === '<') {
                        if (xmlData[i + 1] === '/') {
                            //Closing Tag
                            const closeIndex = findClosingIndex(
                                xmlData,
                                '>',
                                i,
                                'Closing Tag is not closed.'
                            );
                            let tagName = xmlData.substring(i + 2, closeIndex).trim();

                            if (options.ignoreNameSpace) {
                                const colonIndex = tagName.indexOf(':');
                                if (colonIndex !== -1) {
                                    tagName = tagName.substr(colonIndex + 1);
                                }
                            }

                            /* if (currentNode.parent) {
          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);
        } */
                            if (currentNode) {
                                if (currentNode.val) {
                                    currentNode.val =
                                        util.getValue(currentNode.val) +
                                        '' +
                                        processTagValue(tagName, textData, options);
                                } else {
                                    currentNode.val = processTagValue(tagName, textData, options);
                                }
                            }

                            if (
                                options.stopNodes.length &&
                                options.stopNodes.includes(currentNode.tagname)
                            ) {
                                currentNode.child = [];
                                if (currentNode.attrsMap == undefined) {
                                    currentNode.attrsMap = {};
                                }
                                currentNode.val = xmlData.substr(
                                    currentNode.startIndex + 1,
                                    i - currentNode.startIndex - 1
                                );
                            }
                            currentNode = currentNode.parent;
                            textData = '';
                            i = closeIndex;
                        } else if (xmlData[i + 1] === '?') {
                            i = findClosingIndex(xmlData, '?>', i, 'Pi Tag is not closed.');
                        } else if (xmlData.substr(i + 1, 3) === '!--') {
                            i = findClosingIndex(xmlData, '-->', i, 'Comment is not closed.');
                        } else if (xmlData.substr(i + 1, 2) === '!D') {
                            const closeIndex = findClosingIndex(
                                xmlData,
                                '>',
                                i,
                                'DOCTYPE is not closed.'
                            );
                            const tagExp = xmlData.substring(i, closeIndex);
                            if (tagExp.indexOf('[') >= 0) {
                                i = xmlData.indexOf(']>', i) + 1;
                            } else {
                                i = closeIndex;
                            }
                        } else if (xmlData.substr(i + 1, 2) === '![') {
                            const closeIndex =
                                findClosingIndex(xmlData, ']]>', i, 'CDATA is not closed.') - 2;
                            const tagExp = xmlData.substring(i + 9, closeIndex);

                            //considerations
                            //1. CDATA will always have parent node
                            //2. A tag with CDATA is not a leaf node so it's value would be string type.
                            if (textData) {
                                currentNode.val =
                                    util.getValue(currentNode.val) +
                                    '' +
                                    processTagValue(currentNode.tagname, textData, options);
                                textData = '';
                            }

                            if (options.cdataTagName) {
                                //add cdata node
                                const childNode = new xmlNode(
                                    options.cdataTagName,
                                    currentNode,
                                    tagExp
                                );
                                currentNode.addChild(childNode);
                                //for backtracking
                                currentNode.val =
                                    util.getValue(currentNode.val) + options.cdataPositionChar;
                                //add rest value to parent node
                                if (tagExp) {
                                    childNode.val = tagExp;
                                }
                            } else {
                                currentNode.val = (currentNode.val || '') + (tagExp || '');
                            }

                            i = closeIndex + 2;
                        } else {
                            //Opening tag
                            const result = closingIndexForOpeningTag(xmlData, i + 1);
                            let tagExp = result.data;
                            const closeIndex = result.index;
                            const separatorIndex = tagExp.indexOf(' ');
                            let tagName = tagExp;
                            let shouldBuildAttributesMap = true;
                            if (separatorIndex !== -1) {
                                tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
                                tagExp = tagExp.substr(separatorIndex + 1);
                            }

                            if (options.ignoreNameSpace) {
                                const colonIndex = tagName.indexOf(':');
                                if (colonIndex !== -1) {
                                    tagName = tagName.substr(colonIndex + 1);
                                    shouldBuildAttributesMap =
                                        tagName !== result.data.substr(colonIndex + 1);
                                }
                            }

                            //save text to parent node
                            if (currentNode && textData) {
                                if (currentNode.tagname !== '!xml') {
                                    currentNode.val =
                                        util.getValue(currentNode.val) +
                                        '' +
                                        processTagValue(currentNode.tagname, textData, options);
                                }
                            }

                            if (
                                tagExp.length > 0 &&
                                tagExp.lastIndexOf('/') === tagExp.length - 1
                            ) {
                                //selfClosing tag

                                if (tagName[tagName.length - 1] === '/') {
                                    //remove trailing '/'
                                    tagName = tagName.substr(0, tagName.length - 1);
                                    tagExp = tagName;
                                } else {
                                    tagExp = tagExp.substr(0, tagExp.length - 1);
                                }

                                const childNode = new xmlNode(tagName, currentNode, '');
                                if (tagName !== tagExp) {
                                    childNode.attrsMap = buildAttributesMap(tagExp, options);
                                }
                                currentNode.addChild(childNode);
                            } else {
                                //opening tag

                                const childNode = new xmlNode(tagName, currentNode);
                                if (
                                    options.stopNodes.length &&
                                    options.stopNodes.includes(childNode.tagname)
                                ) {
                                    childNode.startIndex = closeIndex;
                                }
                                if (tagName !== tagExp && shouldBuildAttributesMap) {
                                    childNode.attrsMap = buildAttributesMap(tagExp, options);
                                }
                                currentNode.addChild(childNode);
                                currentNode = childNode;
                            }
                            textData = '';
                            i = closeIndex;
                        }
                    } else {
                        textData += xmlData[i];
                    }
                }
                return xmlObj;
            };

            function closingIndexForOpeningTag(data, i) {
                let attrBoundary;
                let tagExp = '';
                for (let index = i; index < data.length; index++) {
                    let ch = data[index];
                    if (attrBoundary) {
                        if (ch === attrBoundary) attrBoundary = ''; //reset
                    } else if (ch === '"' || ch === "'") {
                        attrBoundary = ch;
                    } else if (ch === '>') {
                        return {
                            data: tagExp,
                            index: index
                        };
                    } else if (ch === '\t') {
                        ch = ' ';
                    }
                    tagExp += ch;
                }
            }

            function findClosingIndex(xmlData, str, i, errMsg) {
                const closingIndex = xmlData.indexOf(str, i);
                if (closingIndex === -1) {
                    throw new Error(errMsg);
                } else {
                    return closingIndex + str.length - 1;
                }
            }

            exports.getTraversalObj = getTraversalObj;

            /***/
        },
        /* 159 */
        /***/ (module) => {
            'use strict';

            module.exports = function (tagname, parent, val) {
                this.tagname = tagname;
                this.parent = parent;
                this.child = {}; //child tags
                this.attrsMap = {}; //attributes map
                this.val = val; //text only
                this.addChild = function (child) {
                    if (Array.isArray(this.child[child.tagname])) {
                        //already presents
                        this.child[child.tagname].push(child);
                    } else {
                        this.child[child.tagname] = [child];
                    }
                };
            };

            /***/
        },
        /* 160 */
        /***/ (module) => {
            const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
            const numRegex =
                /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
            // const octRegex = /0x[a-z0-9]+/;
            // const binRegex = /0x[a-z0-9]+/;

            //polyfill
            if (!Number.parseInt && window.parseInt) {
                Number.parseInt = window.parseInt;
            }
            if (!Number.parseFloat && window.parseFloat) {
                Number.parseFloat = window.parseFloat;
            }

            const consider = {
                hex: true,
                leadingZeros: true,
                decimalPoint: '.',
                eNotation: true
                //skipLike: /regex/
            };

            function toNumber(str, options = {}) {
                // const options = Object.assign({}, consider);
                // if(opt.leadingZeros === false){
                //     options.leadingZeros = false;
                // }else if(opt.hex === false){
                //     options.hex = false;
                // }

                options = Object.assign({}, consider, options);
                if (!str || typeof str !== 'string') return str;

                let trimmedStr = str.trim();
                // if(trimmedStr === "0.0") return 0;
                // else if(trimmedStr === "+0.0") return 0;
                // else if(trimmedStr === "-0.0") return -0;

                if (options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
                else if (options.hex && hexRegex.test(trimmedStr)) {
                    return Number.parseInt(trimmedStr, 16);
                    // } else if (options.parseOct && octRegex.test(str)) {
                    //     return Number.parseInt(val, 8);
                    // }else if (options.parseBin && binRegex.test(str)) {
                    //     return Number.parseInt(val, 2);
                } else {
                    //separate negative sign, leading zeros, and rest number
                    const match = numRegex.exec(trimmedStr);
                    if (match) {
                        const sign = match[1];
                        const leadingZeros = match[2];
                        let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
                        //trim ending zeros for floating number

                        const eNotation = match[4] || match[6];
                        if (
                            !options.leadingZeros &&
                            leadingZeros.length > 0 &&
                            sign &&
                            trimmedStr[2] !== '.'
                        )
                            return str; //-0123
                        else if (
                            !options.leadingZeros &&
                            leadingZeros.length > 0 &&
                            !sign &&
                            trimmedStr[1] !== '.'
                        )
                            return str; //0123
                        else {
                            //no leading zeros or leading zeros are allowed
                            const num = Number(trimmedStr);
                            const numStr = '' + num;
                            if (numStr.search(/[eE]/) !== -1) {
                                //given number is long and parsed to eNotation
                                if (options.eNotation) return num;
                                else return str;
                            } else if (eNotation) {
                                //given number has enotation
                                if (options.eNotation) return num;
                                else return str;
                            } else if (trimmedStr.indexOf('.') !== -1) {
                                //floating number
                                // const decimalPart = match[5].substr(1);
                                // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                                // const p = numStr.indexOf(".");
                                // const givenIntPart = numStr.substr(0,p);
                                // const givenDecPart = numStr.substr(p+1);
                                if (numStr === '0' && numTrimmedByZeros === '') return num; //0.0
                                else if (numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                                else if (sign && numStr === '-' + numTrimmedByZeros) return num;
                                else return str;
                            }

                            if (leadingZeros) {
                                // if(numTrimmedByZeros === numStr){
                                //     if(options.leadingZeros) return num;
                                //     else return str;
                                // }else return str;
                                if (numTrimmedByZeros === numStr) return num;
                                else if (sign + numTrimmedByZeros === numStr) return num;
                                else return str;
                            }

                            if (trimmedStr === numStr) return num;
                            else if (trimmedStr === sign + numStr) return num;
                            // else{
                            //     //number with +/- sign
                            //     trimmedStr.test(/[-+][0-9]);

                            // }
                            return str;
                        }
                        // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
                    } else {
                        //non-numeric string
                        return str;
                    }
                }
            }

            /**
             *
             * @param {string} numStr without leading zeros
             * @returns
             */
            function trimZeros(numStr) {
                if (numStr && numStr.indexOf('.') !== -1) {
                    //float
                    numStr = numStr.replace(/0+$/, ''); //remove ending zeros
                    if (numStr === '.') numStr = '0';
                    else if (numStr[0] === '.') numStr = '0' + numStr;
                    else if (numStr[numStr.length - 1] === '.')
                        numStr = numStr.substr(0, numStr.length - 1);
                    return numStr;
                }
                return numStr;
            }
            module.exports = toNumber;

            /***/
        },
        /* 161 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            const util = __webpack_require__(157);

            const defaultOptions = {
                allowBooleanAttributes: false //A tag can have attributes without any value
            };

            const props = ['allowBooleanAttributes'];

            //const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
            exports.validate = function (xmlData, options) {
                options = util.buildOptions(options, defaultOptions, props);

                //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
                //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
                //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
                const tags = [];
                let tagFound = false;

                //indicates that the root tag has been closed (aka. depth 0 has been reached)
                let reachedRoot = false;

                if (xmlData[0] === '\ufeff') {
                    // check for byte order mark (BOM)
                    xmlData = xmlData.substr(1);
                }

                for (let i = 0; i < xmlData.length; i++) {
                    if (xmlData[i] === '<' && xmlData[i + 1] === '?') {
                        i += 2;
                        i = readPI(xmlData, i);
                        if (i.err) return i;
                    } else if (xmlData[i] === '<') {
                        //starting of tag
                        //read until you reach to '>' avoiding any '>' in attribute value
                        let tagStartPos = i;
                        i++;

                        if (xmlData[i] === '!') {
                            i = readCommentAndCDATA(xmlData, i);
                            continue;
                        } else {
                            let closingTag = false;
                            if (xmlData[i] === '/') {
                                //closing tag
                                closingTag = true;
                                i++;
                            }
                            //read tagname
                            let tagName = '';
                            for (
                                ;
                                i < xmlData.length &&
                                xmlData[i] !== '>' &&
                                xmlData[i] !== ' ' &&
                                xmlData[i] !== '\t' &&
                                xmlData[i] !== '\n' &&
                                xmlData[i] !== '\r';
                                i++
                            ) {
                                tagName += xmlData[i];
                            }
                            tagName = tagName.trim();
                            //console.log(tagName);

                            if (tagName[tagName.length - 1] === '/') {
                                //self closing tag without attributes
                                tagName = tagName.substring(0, tagName.length - 1);
                                //continue;
                                i--;
                            }
                            if (!validateTagName(tagName)) {
                                let msg;
                                if (tagName.trim().length === 0) {
                                    msg = "Invalid space after '<'.";
                                } else {
                                    msg = "Tag '" + tagName + "' is an invalid name.";
                                }
                                return getErrorObject(
                                    'InvalidTag',
                                    msg,
                                    getLineNumberForPosition(xmlData, i)
                                );
                            }

                            const result = readAttributeStr(xmlData, i);
                            if (result === false) {
                                return getErrorObject(
                                    'InvalidAttr',
                                    "Attributes for '" + tagName + "' have open quote.",
                                    getLineNumberForPosition(xmlData, i)
                                );
                            }
                            let attrStr = result.value;
                            i = result.index;

                            if (attrStr[attrStr.length - 1] === '/') {
                                //self closing tag
                                const attrStrStart = i - attrStr.length;
                                attrStr = attrStr.substring(0, attrStr.length - 1);
                                const isValid = validateAttributeString(attrStr, options);
                                if (isValid === true) {
                                    tagFound = true;
                                    //continue; //text may presents after self closing tag
                                } else {
                                    //the result from the nested function returns the position of the error within the attribute
                                    //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
                                    //this gives us the absolute index in the entire xml, which we can use to find the line at last
                                    return getErrorObject(
                                        isValid.err.code,
                                        isValid.err.msg,
                                        getLineNumberForPosition(
                                            xmlData,
                                            attrStrStart + isValid.err.line
                                        )
                                    );
                                }
                            } else if (closingTag) {
                                if (!result.tagClosed) {
                                    return getErrorObject(
                                        'InvalidTag',
                                        "Closing tag '" +
                                            tagName +
                                            "' doesn't have proper closing.",
                                        getLineNumberForPosition(xmlData, i)
                                    );
                                } else if (attrStr.trim().length > 0) {
                                    return getErrorObject(
                                        'InvalidTag',
                                        "Closing tag '" +
                                            tagName +
                                            "' can't have attributes or invalid starting.",
                                        getLineNumberForPosition(xmlData, tagStartPos)
                                    );
                                } else {
                                    const otg = tags.pop();
                                    if (tagName !== otg.tagName) {
                                        let openPos = getLineNumberForPosition(
                                            xmlData,
                                            otg.tagStartPos
                                        );
                                        return getErrorObject(
                                            'InvalidTag',
                                            "Expected closing tag '" +
                                                otg.tagName +
                                                "' (opened in line " +
                                                openPos.line +
                                                ', col ' +
                                                openPos.col +
                                                ") instead of closing tag '" +
                                                tagName +
                                                "'.",
                                            getLineNumberForPosition(xmlData, tagStartPos)
                                        );
                                    }

                                    //when there are no more tags, we reached the root level.
                                    if (tags.length == 0) {
                                        reachedRoot = true;
                                    }
                                }
                            } else {
                                const isValid = validateAttributeString(attrStr, options);
                                if (isValid !== true) {
                                    //the result from the nested function returns the position of the error within the attribute
                                    //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
                                    //this gives us the absolute index in the entire xml, which we can use to find the line at last
                                    return getErrorObject(
                                        isValid.err.code,
                                        isValid.err.msg,
                                        getLineNumberForPosition(
                                            xmlData,
                                            i - attrStr.length + isValid.err.line
                                        )
                                    );
                                }

                                //if the root level has been reached before ...
                                if (reachedRoot === true) {
                                    return getErrorObject(
                                        'InvalidXml',
                                        'Multiple possible root nodes found.',
                                        getLineNumberForPosition(xmlData, i)
                                    );
                                } else {
                                    tags.push({ tagName, tagStartPos });
                                }
                                tagFound = true;
                            }

                            //skip tag text value
                            //It may include comments and CDATA value
                            for (i++; i < xmlData.length; i++) {
                                if (xmlData[i] === '<') {
                                    if (xmlData[i + 1] === '!') {
                                        //comment or CADATA
                                        i++;
                                        i = readCommentAndCDATA(xmlData, i);
                                        continue;
                                    } else if (xmlData[i + 1] === '?') {
                                        i = readPI(xmlData, ++i);
                                        if (i.err) return i;
                                    } else {
                                        break;
                                    }
                                } else if (xmlData[i] === '&') {
                                    const afterAmp = validateAmpersand(xmlData, i);
                                    if (afterAmp == -1)
                                        return getErrorObject(
                                            'InvalidChar',
                                            "char '&' is not expected.",
                                            getLineNumberForPosition(xmlData, i)
                                        );
                                    i = afterAmp;
                                }
                            } //end of reading tag text value
                            if (xmlData[i] === '<') {
                                i--;
                            }
                        }
                    } else {
                        if (
                            xmlData[i] === ' ' ||
                            xmlData[i] === '\t' ||
                            xmlData[i] === '\n' ||
                            xmlData[i] === '\r'
                        ) {
                            continue;
                        }
                        return getErrorObject(
                            'InvalidChar',
                            "char '" + xmlData[i] + "' is not expected.",
                            getLineNumberForPosition(xmlData, i)
                        );
                    }
                }

                if (!tagFound) {
                    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
                } else if (tags.length == 1) {
                    return getErrorObject(
                        'InvalidTag',
                        "Unclosed tag '" + tags[0].tagName + "'.",
                        getLineNumberForPosition(xmlData, tags[0].tagStartPos)
                    );
                } else if (tags.length > 0) {
                    return getErrorObject(
                        'InvalidXml',
                        "Invalid '" +
                            JSON.stringify(
                                tags.map((t) => t.tagName),
                                null,
                                4
                            ).replace(/\r?\n/g, '') +
                            "' found.",
                        { line: 1, col: 1 }
                    );
                }

                return true;
            };

            /**
             * Read Processing insstructions and skip
             * @param {*} xmlData
             * @param {*} i
             */
            function readPI(xmlData, i) {
                const start = i;
                for (; i < xmlData.length; i++) {
                    if (xmlData[i] == '?' || xmlData[i] == ' ') {
                        //tagname
                        const tagname = xmlData.substr(start, i - start);
                        if (i > 5 && tagname === 'xml') {
                            return getErrorObject(
                                'InvalidXml',
                                'XML declaration allowed only at the start of the document.',
                                getLineNumberForPosition(xmlData, i)
                            );
                        } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
                            //check if valid attribut string
                            i++;
                            break;
                        } else {
                            continue;
                        }
                    }
                }
                return i;
            }

            function readCommentAndCDATA(xmlData, i) {
                if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
                    //comment
                    for (i += 3; i < xmlData.length; i++) {
                        if (
                            xmlData[i] === '-' &&
                            xmlData[i + 1] === '-' &&
                            xmlData[i + 2] === '>'
                        ) {
                            i += 2;
                            break;
                        }
                    }
                } else if (
                    xmlData.length > i + 8 &&
                    xmlData[i + 1] === 'D' &&
                    xmlData[i + 2] === 'O' &&
                    xmlData[i + 3] === 'C' &&
                    xmlData[i + 4] === 'T' &&
                    xmlData[i + 5] === 'Y' &&
                    xmlData[i + 6] === 'P' &&
                    xmlData[i + 7] === 'E'
                ) {
                    let angleBracketsCount = 1;
                    for (i += 8; i < xmlData.length; i++) {
                        if (xmlData[i] === '<') {
                            angleBracketsCount++;
                        } else if (xmlData[i] === '>') {
                            angleBracketsCount--;
                            if (angleBracketsCount === 0) {
                                break;
                            }
                        }
                    }
                } else if (
                    xmlData.length > i + 9 &&
                    xmlData[i + 1] === '[' &&
                    xmlData[i + 2] === 'C' &&
                    xmlData[i + 3] === 'D' &&
                    xmlData[i + 4] === 'A' &&
                    xmlData[i + 5] === 'T' &&
                    xmlData[i + 6] === 'A' &&
                    xmlData[i + 7] === '['
                ) {
                    for (i += 8; i < xmlData.length; i++) {
                        if (
                            xmlData[i] === ']' &&
                            xmlData[i + 1] === ']' &&
                            xmlData[i + 2] === '>'
                        ) {
                            i += 2;
                            break;
                        }
                    }
                }

                return i;
            }

            const doubleQuote = '"';
            const singleQuote = "'";

            /**
             * Keep reading xmlData until '<' is found outside the attribute value.
             * @param {string} xmlData
             * @param {number} i
             */
            function readAttributeStr(xmlData, i) {
                let attrStr = '';
                let startChar = '';
                let tagClosed = false;
                for (; i < xmlData.length; i++) {
                    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
                        if (startChar === '') {
                            startChar = xmlData[i];
                        } else if (startChar !== xmlData[i]) {
                            //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
                        } else {
                            startChar = '';
                        }
                    } else if (xmlData[i] === '>') {
                        if (startChar === '') {
                            tagClosed = true;
                            break;
                        }
                    }
                    attrStr += xmlData[i];
                }
                if (startChar !== '') {
                    return false;
                }

                return {
                    value: attrStr,
                    index: i,
                    tagClosed: tagClosed
                };
            }

            /**
             * Select all the attributes whether valid or invalid.
             */
            const validAttrStrRegxp = new RegExp(
                '(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?',
                'g'
            );

            //attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

            function validateAttributeString(attrStr, options) {
                //console.log("start:"+attrStr+":end");

                //if(attrStr.trim().length === 0) return true; //empty string

                const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
                const attrNames = {};

                for (let i = 0; i < matches.length; i++) {
                    if (matches[i][1].length === 0) {
                        //nospace before attribute name: a="sd"b="saf"
                        return getErrorObject(
                            'InvalidAttr',
                            "Attribute '" + matches[i][2] + "' has no space in starting.",
                            getPositionFromMatch(matches[i])
                        );
                    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
                        //independent attribute: ab
                        return getErrorObject(
                            'InvalidAttr',
                            "boolean attribute '" + matches[i][2] + "' is not allowed.",
                            getPositionFromMatch(matches[i])
                        );
                    }
                    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
                    const attrName = matches[i][2];
                    if (!validateAttrName(attrName)) {
                        return getErrorObject(
                            'InvalidAttr',
                            "Attribute '" + attrName + "' is an invalid name.",
                            getPositionFromMatch(matches[i])
                        );
                    }
                    if (!attrNames.hasOwnProperty(attrName)) {
                        //check for duplicate attribute.
                        attrNames[attrName] = 1;
                    } else {
                        return getErrorObject(
                            'InvalidAttr',
                            "Attribute '" + attrName + "' is repeated.",
                            getPositionFromMatch(matches[i])
                        );
                    }
                }

                return true;
            }

            function validateNumberAmpersand(xmlData, i) {
                let re = /\d/;
                if (xmlData[i] === 'x') {
                    i++;
                    re = /[\da-fA-F]/;
                }
                for (; i < xmlData.length; i++) {
                    if (xmlData[i] === ';') return i;
                    if (!xmlData[i].match(re)) break;
                }
                return -1;
            }

            function validateAmpersand(xmlData, i) {
                // https://www.w3.org/TR/xml/#dt-charref
                i++;
                if (xmlData[i] === ';') return -1;
                if (xmlData[i] === '#') {
                    i++;
                    return validateNumberAmpersand(xmlData, i);
                }
                let count = 0;
                for (; i < xmlData.length; i++, count++) {
                    if (xmlData[i].match(/\w/) && count < 20) continue;
                    if (xmlData[i] === ';') break;
                    return -1;
                }
                return i;
            }

            function getErrorObject(code, message, lineNumber) {
                return {
                    err: {
                        code: code,
                        msg: message,
                        line: lineNumber.line || lineNumber,
                        col: lineNumber.col
                    }
                };
            }

            function validateAttrName(attrName) {
                return util.isName(attrName);
            }

            // const startsWithXML = /^xml/i;

            function validateTagName(tagname) {
                return util.isName(tagname); /* && !tagname.match(startsWithXML) */
            }

            //this function returns the line number for the character at the given index
            function getLineNumberForPosition(xmlData, index) {
                const lines = xmlData.substring(0, index).split(/\r?\n/);
                return {
                    line: lines.length,

                    // column number is last line's length + 1, because column numbering starts at 1:
                    col: lines[lines.length - 1].length + 1
                };
            }

            //this function returns the position of the first character of match within attrStr
            function getPositionFromMatch(match) {
                return match.startIndex + match[1].length;
            }

            /***/
        },
        /* 162 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            const char = function (a) {
                return String.fromCharCode(a);
            };

            const chars = {
                nilChar: char(176),
                missingChar: char(201),
                nilPremitive: char(175),
                missingPremitive: char(200),

                emptyChar: char(178),
                emptyValue: char(177), //empty Premitive

                boundryChar: char(179),

                objStart: char(198),
                arrStart: char(204),
                arrayEnd: char(185)
            };

            const charsArr = [
                chars.nilChar,
                chars.nilPremitive,
                chars.missingChar,
                chars.missingPremitive,
                chars.boundryChar,
                chars.emptyChar,
                chars.emptyValue,
                chars.arrayEnd,
                chars.objStart,
                chars.arrStart
            ];

            const _e = function (node, e_schema, options) {
                if (typeof e_schema === 'string') {
                    //premitive
                    if (node && node[0] && node[0].val !== undefined) {
                        return getValue(node[0].val, e_schema);
                    } else {
                        return getValue(node, e_schema);
                    }
                } else {
                    const hasValidData = hasData(node);
                    if (hasValidData === true) {
                        let str = '';
                        if (Array.isArray(e_schema)) {
                            //attributes can't be repeated. hence check in children tags only
                            str += chars.arrStart;
                            const itemSchema = e_schema[0];
                            //const itemSchemaType = itemSchema;
                            const arr_len = node.length;

                            if (typeof itemSchema === 'string') {
                                for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                                    const r = getValue(node[arr_i].val, itemSchema);
                                    str = processValue(str, r);
                                }
                            } else {
                                for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                                    const r = _e(node[arr_i], itemSchema, options);
                                    str = processValue(str, r);
                                }
                            }
                            str += chars.arrayEnd; //indicates that next item is not array item
                        } else {
                            //object
                            str += chars.objStart;
                            const keys = Object.keys(e_schema);
                            if (Array.isArray(node)) {
                                node = node[0];
                            }
                            for (let i in keys) {
                                const key = keys[i];
                                //a property defined in schema can be present either in attrsMap or children tags
                                //options.textNodeName will not present in both maps, take it's value from val
                                //options.attrNodeName will be present in attrsMap
                                let r;
                                if (
                                    !options.ignoreAttributes &&
                                    node.attrsMap &&
                                    node.attrsMap[key]
                                ) {
                                    r = _e(node.attrsMap[key], e_schema[key], options);
                                } else if (key === options.textNodeName) {
                                    r = _e(node.val, e_schema[key], options);
                                } else {
                                    r = _e(node.child[key], e_schema[key], options);
                                }
                                str = processValue(str, r);
                            }
                        }
                        return str;
                    } else {
                        return hasValidData;
                    }
                }
            };

            const getValue = function (a /*, type*/) {
                switch (a) {
                    case undefined:
                        return chars.missingPremitive;
                    case null:
                        return chars.nilPremitive;
                    case '':
                        return chars.emptyValue;
                    default:
                        return a;
                }
            };

            const processValue = function (str, r) {
                if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {
                    str += chars.boundryChar;
                }
                return str + r;
            };

            const isAppChar = function (ch) {
                return charsArr.indexOf(ch) !== -1;
            };

            function hasData(jObj) {
                if (jObj === undefined) {
                    return chars.missingChar;
                } else if (jObj === null) {
                    return chars.nilChar;
                } else if (
                    jObj.child &&
                    Object.keys(jObj.child).length === 0 &&
                    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)
                ) {
                    return chars.emptyChar;
                } else {
                    return true;
                }
            }

            const x2j = __webpack_require__(158);
            const buildOptions = __webpack_require__(157).buildOptions;

            const convert2nimn = function (node, e_schema, options) {
                options = buildOptions(options, x2j.defaultOptions, x2j.props);
                return _e(node, e_schema, options);
            };

            exports.convert2nimn = convert2nimn;

            /***/
        },
        /* 163 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            const util = __webpack_require__(157);
            const buildOptions = __webpack_require__(157).buildOptions;
            const x2j = __webpack_require__(158);

            //TODO: do it later
            const convertToJsonString = function (node, options) {
                options = buildOptions(options, x2j.defaultOptions, x2j.props);

                options.indentBy = options.indentBy || '';
                return _cToJsonStr(node, options, 0);
            };

            const _cToJsonStr = function (node, options, level) {
                let jObj = '{';

                //traver through all the children
                const keys = Object.keys(node.child);

                for (let index = 0; index < keys.length; index++) {
                    const tagname = keys[index];
                    if (node.child[tagname] && node.child[tagname].length > 1) {
                        jObj += '"' + tagname + '" : [ ';
                        for (let tag in node.child[tagname]) {
                            jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';
                        }
                        jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last
                    } else {
                        jObj +=
                            '"' +
                            tagname +
                            '" : ' +
                            _cToJsonStr(node.child[tagname][0], options) +
                            ' ,';
                    }
                }
                util.merge(jObj, node.attrsMap);
                //add attrsMap as new children
                if (util.isEmptyObject(jObj)) {
                    return util.isExist(node.val) ? node.val : '';
                } else {
                    if (util.isExist(node.val)) {
                        if (
                            !(
                                typeof node.val === 'string' &&
                                (node.val === '' || node.val === options.cdataPositionChar)
                            )
                        ) {
                            jObj += '"' + options.textNodeName + '" : ' + stringval(node.val);
                        }
                    }
                }
                //add value
                if (jObj[jObj.length - 1] === ',') {
                    jObj = jObj.substr(0, jObj.length - 2);
                }
                return jObj + '}';
            };

            function stringval(v) {
                if (v === true || v === false || !isNaN(v)) {
                    return v;
                } else {
                    return '"' + v + '"';
                }
            }

            function indentate(options, level) {
                return options.indentBy.repeat(level);
            }

            exports.convertToJsonString = convertToJsonString;

            /***/
        },
        /* 164 */
        /***/ (module, __unused_webpack_exports, __webpack_require__) => {
            'use strict';

            //parse Empty Node as self closing node
            const buildOptions = __webpack_require__(157).buildOptions;

            const defaultOptions = {
                attributeNamePrefix: '@_',
                attrNodeName: false,
                textNodeName: '#text',
                ignoreAttributes: true,
                cdataTagName: false,
                cdataPositionChar: '\\c',
                format: false,
                indentBy: '  ',
                supressEmptyNode: false,
                tagValueProcessor: function (a) {
                    return a;
                },
                attrValueProcessor: function (a) {
                    return a;
                }
            };

            const props = [
                'attributeNamePrefix',
                'attrNodeName',
                'textNodeName',
                'ignoreAttributes',
                'cdataTagName',
                'cdataPositionChar',
                'format',
                'indentBy',
                'supressEmptyNode',
                'tagValueProcessor',
                'attrValueProcessor',
                'rootNodeName' //when array as root
            ];

            function Parser(options) {
                this.options = buildOptions(options, defaultOptions, props);
                if (this.options.ignoreAttributes || this.options.attrNodeName) {
                    this.isAttribute = function (/*a*/) {
                        return false;
                    };
                } else {
                    this.attrPrefixLen = this.options.attributeNamePrefix.length;
                    this.isAttribute = isAttribute;
                }
                if (this.options.cdataTagName) {
                    this.isCDATA = isCDATA;
                } else {
                    this.isCDATA = function (/*a*/) {
                        return false;
                    };
                }
                this.replaceCDATAstr = replaceCDATAstr;
                this.replaceCDATAarr = replaceCDATAarr;

                this.processTextOrObjNode = processTextOrObjNode;

                if (this.options.format) {
                    this.indentate = indentate;
                    this.tagEndChar = '>\n';
                    this.newLine = '\n';
                } else {
                    this.indentate = function () {
                        return '';
                    };
                    this.tagEndChar = '>';
                    this.newLine = '';
                }

                if (this.options.supressEmptyNode) {
                    this.buildTextNode = buildEmptyTextNode;
                    this.buildObjNode = buildEmptyObjNode;
                } else {
                    this.buildTextNode = buildTextValNode;
                    this.buildObjNode = buildObjectNode;
                }

                this.buildTextValNode = buildTextValNode;
                this.buildObjectNode = buildObjectNode;
            }

            Parser.prototype.parse = function (jObj) {
                if (
                    Array.isArray(jObj) &&
                    this.options.rootNodeName &&
                    this.options.rootNodeName.length > 1
                ) {
                    jObj = {
                        [this.options.rootNodeName]: jObj
                    };
                }
                return this.j2x(jObj, 0).val;
            };

            Parser.prototype.j2x = function (jObj, level) {
                let attrStr = '';
                let val = '';
                for (let key in jObj) {
                    if (typeof jObj[key] === 'undefined') {
                        // supress undefined node
                    } else if (jObj[key] === null) {
                        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
                    } else if (jObj[key] instanceof Date) {
                        val += this.buildTextNode(jObj[key], key, '', level);
                    } else if (typeof jObj[key] !== 'object') {
                        //premitive type
                        const attr = this.isAttribute(key);
                        if (attr) {
                            attrStr +=
                                ' ' +
                                attr +
                                '="' +
                                this.options.attrValueProcessor('' + jObj[key]) +
                                '"';
                        } else if (this.isCDATA(key)) {
                            if (jObj[this.options.textNodeName]) {
                                val += this.replaceCDATAstr(
                                    jObj[this.options.textNodeName],
                                    jObj[key]
                                );
                            } else {
                                val += this.replaceCDATAstr('', jObj[key]);
                            }
                        } else {
                            //tag value
                            if (key === this.options.textNodeName) {
                                if (jObj[this.options.cdataTagName]) {
                                    //value will added while processing cdata
                                } else {
                                    val += this.options.tagValueProcessor('' + jObj[key]);
                                }
                            } else {
                                val += this.buildTextNode(jObj[key], key, '', level);
                            }
                        }
                    } else if (Array.isArray(jObj[key])) {
                        //repeated nodes
                        if (this.isCDATA(key)) {
                            val += this.indentate(level);
                            if (jObj[this.options.textNodeName]) {
                                val += this.replaceCDATAarr(
                                    jObj[this.options.textNodeName],
                                    jObj[key]
                                );
                            } else {
                                val += this.replaceCDATAarr('', jObj[key]);
                            }
                        } else {
                            //nested nodes
                            const arrLen = jObj[key].length;
                            for (let j = 0; j < arrLen; j++) {
                                const item = jObj[key][j];
                                if (typeof item === 'undefined') {
                                    // supress undefined node
                                } else if (item === null) {
                                    val +=
                                        this.indentate(level) + '<' + key + '/' + this.tagEndChar;
                                } else if (typeof item === 'object') {
                                    val += this.processTextOrObjNode(item, key, level);
                                } else {
                                    val += this.buildTextNode(item, key, '', level);
                                }
                            }
                        }
                    } else {
                        //nested node
                        if (this.options.attrNodeName && key === this.options.attrNodeName) {
                            const Ks = Object.keys(jObj[key]);
                            const L = Ks.length;
                            for (let j = 0; j < L; j++) {
                                attrStr +=
                                    ' ' +
                                    Ks[j] +
                                    '="' +
                                    this.options.attrValueProcessor('' + jObj[key][Ks[j]]) +
                                    '"';
                            }
                        } else {
                            val += this.processTextOrObjNode(jObj[key], key, level);
                        }
                    }
                }
                return { attrStr: attrStr, val: val };
            };

            function processTextOrObjNode(object, key, level) {
                const result = this.j2x(object, level + 1);
                if (
                    object[this.options.textNodeName] !== undefined &&
                    Object.keys(object).length === 1
                ) {
                    return this.buildTextNode(result.val, key, result.attrStr, level);
                } else {
                    return this.buildObjNode(result.val, key, result.attrStr, level);
                }
            }

            function replaceCDATAstr(str, cdata) {
                str = this.options.tagValueProcessor('' + str);
                if (this.options.cdataPositionChar === '' || str === '') {
                    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;
                } else {
                    return str.replace(
                        this.options.cdataPositionChar,
                        '<![CDATA[' + cdata + ']]' + this.tagEndChar
                    );
                }
            }

            function replaceCDATAarr(str, cdata) {
                str = this.options.tagValueProcessor('' + str);
                if (this.options.cdataPositionChar === '' || str === '') {
                    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;
                } else {
                    for (let v in cdata) {
                        str = str.replace(
                            this.options.cdataPositionChar,
                            '<![CDATA[' + cdata[v] + ']]>'
                        );
                    }
                    return str + this.newLine;
                }
            }

            function buildObjectNode(val, key, attrStr, level) {
                if (attrStr && val.indexOf('<') === -1) {
                    return (
                        this.indentate(level) +
                        '<' +
                        key +
                        attrStr +
                        '>' +
                        val +
                        //+ this.newLine
                        // + this.indentate(level)
                        '</' +
                        key +
                        this.tagEndChar
                    );
                } else {
                    return (
                        this.indentate(level) +
                        '<' +
                        key +
                        attrStr +
                        this.tagEndChar +
                        val +
                        //+ this.newLine
                        this.indentate(level) +
                        '</' +
                        key +
                        this.tagEndChar
                    );
                }
            }

            function buildEmptyObjNode(val, key, attrStr, level) {
                if (val !== '') {
                    return this.buildObjectNode(val, key, attrStr, level);
                } else {
                    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
                    //+ this.newLine
                }
            }

            function buildTextValNode(val, key, attrStr, level) {
                return (
                    this.indentate(level) +
                    '<' +
                    key +
                    attrStr +
                    '>' +
                    this.options.tagValueProcessor(val) +
                    '</' +
                    key +
                    this.tagEndChar
                );
            }

            function buildEmptyTextNode(val, key, attrStr, level) {
                if (val !== '') {
                    return this.buildTextValNode(val, key, attrStr, level);
                } else {
                    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
                }
            }

            function indentate(level) {
                return this.options.indentBy.repeat(level);
            }

            function isAttribute(name /*, options*/) {
                if (name.startsWith(this.options.attributeNamePrefix)) {
                    return name.substr(this.attrPrefixLen);
                } else {
                    return false;
                }
            }

            function isCDATA(name) {
                return name === this.options.cdataTagName;
            }

            //formatting
            //indentation
            //\n after each closing or self closing tag

            module.exports = Parser;

            /***/
        },
        /* 165 */
        /***/ (module) => {
            'use strict';
            /**
             * @license nested-property https://github.com/cosmosio/nested-property
             *
             * The MIT License (MIT)
             *
             * Copyright (c) 2014-2020 Olivier Scherrer <pode.fr@gmail.com>
             */

            function _typeof(obj) {
                '@babel/helpers - typeof';
                if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
                    _typeof = function _typeof(obj) {
                        return typeof obj;
                    };
                } else {
                    _typeof = function _typeof(obj) {
                        return obj &&
                            typeof Symbol === 'function' &&
                            obj.constructor === Symbol &&
                            obj !== Symbol.prototype
                            ? 'symbol'
                            : typeof obj;
                    };
                }
                return _typeof(obj);
            }

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError('Cannot call a class as a function');
                }
            }

            function _possibleConstructorReturn(self, call) {
                if (call && (_typeof(call) === 'object' || typeof call === 'function')) {
                    return call;
                }
                return _assertThisInitialized(self);
            }

            function _assertThisInitialized(self) {
                if (self === void 0) {
                    throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                    );
                }
                return self;
            }

            function _inherits(subClass, superClass) {
                if (typeof superClass !== 'function' && superClass !== null) {
                    throw new TypeError('Super expression must either be null or a function');
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: { value: subClass, writable: true, configurable: true }
                });
                if (superClass) _setPrototypeOf(subClass, superClass);
            }

            function _wrapNativeSuper(Class) {
                var _cache = typeof Map === 'function' ? new Map() : undefined;
                _wrapNativeSuper = function _wrapNativeSuper(Class) {
                    if (Class === null || !_isNativeFunction(Class)) return Class;
                    if (typeof Class !== 'function') {
                        throw new TypeError('Super expression must either be null or a function');
                    }
                    if (typeof _cache !== 'undefined') {
                        if (_cache.has(Class)) return _cache.get(Class);
                        _cache.set(Class, Wrapper);
                    }
                    function Wrapper() {
                        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                    }
                    Wrapper.prototype = Object.create(Class.prototype, {
                        constructor: {
                            value: Wrapper,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    return _setPrototypeOf(Wrapper, Class);
                };
                return _wrapNativeSuper(Class);
            }

            function _construct(Parent, args, Class) {
                if (_isNativeReflectConstruct()) {
                    _construct = Reflect.construct;
                } else {
                    _construct = function _construct(Parent, args, Class) {
                        var a = [null];
                        a.push.apply(a, args);
                        var Constructor = Function.bind.apply(Parent, a);
                        var instance = new Constructor();
                        if (Class) _setPrototypeOf(instance, Class.prototype);
                        return instance;
                    };
                }
                return _construct.apply(null, arguments);
            }

            function _isNativeReflectConstruct() {
                if (typeof Reflect === 'undefined' || !Reflect.construct) return false;
                if (Reflect.construct.sham) return false;
                if (typeof Proxy === 'function') return true;
                try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
                    return true;
                } catch (e) {
                    return false;
                }
            }

            function _isNativeFunction(fn) {
                return Function.toString.call(fn).indexOf('[native code]') !== -1;
            }

            function _setPrototypeOf(o, p) {
                _setPrototypeOf =
                    Object.setPrototypeOf ||
                    function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                return _setPrototypeOf(o, p);
            }

            function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf
                    ? Object.getPrototypeOf
                    : function _getPrototypeOf(o) {
                          return o.__proto__ || Object.getPrototypeOf(o);
                      };
                return _getPrototypeOf(o);
            }

            var ARRAY_WILDCARD = '+';
            var PATH_DELIMITER = '.';

            var ObjectPrototypeMutationError = /*#__PURE__*/ (function (_Error) {
                _inherits(ObjectPrototypeMutationError, _Error);

                function ObjectPrototypeMutationError(params) {
                    var _this;

                    _classCallCheck(this, ObjectPrototypeMutationError);

                    _this = _possibleConstructorReturn(
                        this,
                        _getPrototypeOf(ObjectPrototypeMutationError).call(this, params)
                    );
                    _this.name = 'ObjectPrototypeMutationError';
                    return _this;
                }

                return ObjectPrototypeMutationError;
            })(_wrapNativeSuper(Error));

            module.exports = {
                set: setNestedProperty,
                get: getNestedProperty,
                has: hasNestedProperty,
                hasOwn: function hasOwn(object, property, options) {
                    return this.has(
                        object,
                        property,
                        options || {
                            own: true
                        }
                    );
                },
                isIn: isInNestedProperty,
                ObjectPrototypeMutationError: ObjectPrototypeMutationError
            };
            /**
             * Get the property of an object nested in one or more objects or array
             * Given an object such as a.b.c.d = 5, getNestedProperty(a, "b.c.d") will return 5.
             * It also works through arrays. Given a nested array such as a[0].b = 5, getNestedProperty(a, "0.b") will return 5.
             * For accessing nested properties through all items in an array, you may use the array wildcard "+".
             * For instance, getNestedProperty([{a:1}, {a:2}, {a:3}], "+.a") will return [1, 2, 3]
             * @param {Object} object the object to get the property from
             * @param {String} property the path to the property as a string
             * @returns the object or the the property value if found
             */

            function getNestedProperty(object, property) {
                if (_typeof(object) != 'object' || object === null) {
                    return object;
                }

                if (typeof property == 'undefined') {
                    return object;
                }

                if (typeof property == 'number') {
                    return object[property];
                }

                try {
                    return traverse(
                        object,
                        property,
                        function _getNestedProperty(currentObject, currentProperty) {
                            return currentObject[currentProperty];
                        }
                    );
                } catch (err) {
                    return object;
                }
            }
            /**
             * Tell if a nested object has a given property (or array a given index)
             * given an object such as a.b.c.d = 5, hasNestedProperty(a, "b.c.d") will return true.
             * It also returns true if the property is in the prototype chain.
             * @param {Object} object the object to get the property from
             * @param {String} property the path to the property as a string
             * @param {Object} options:
             *  - own: set to reject properties from the prototype
             * @returns true if has (property in object), false otherwise
             */

            function hasNestedProperty(object, property) {
                var options =
                    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

                if (_typeof(object) != 'object' || object === null) {
                    return false;
                }

                if (typeof property == 'undefined') {
                    return false;
                }

                if (typeof property == 'number') {
                    return property in object;
                }

                try {
                    var has = false;
                    traverse(
                        object,
                        property,
                        function _hasNestedProperty(
                            currentObject,
                            currentProperty,
                            segments,
                            index
                        ) {
                            if (isLastSegment(segments, index)) {
                                if (options.own) {
                                    has = currentObject.hasOwnProperty(currentProperty);
                                } else {
                                    has = currentProperty in currentObject;
                                }
                            } else {
                                return currentObject && currentObject[currentProperty];
                            }
                        }
                    );
                    return has;
                } catch (err) {
                    return false;
                }
            }
            /**
             * Set the property of an object nested in one or more objects
             * If the property doesn't exist, it gets created.
             * @param {Object} object
             * @param {String} property
             * @param value the value to set
             * @returns object if no assignment was made or the value if the assignment was made
             */

            function setNestedProperty(object, property, value) {
                if (_typeof(object) != 'object' || object === null) {
                    return object;
                }

                if (typeof property == 'undefined') {
                    return object;
                }

                if (typeof property == 'number') {
                    object[property] = value;
                    return object[property];
                }

                try {
                    return traverse(
                        object,
                        property,
                        function _setNestedProperty(
                            currentObject,
                            currentProperty,
                            segments,
                            index
                        ) {
                            if (currentObject === Reflect.getPrototypeOf({})) {
                                throw new ObjectPrototypeMutationError(
                                    'Attempting to mutate Object.prototype'
                                );
                            }

                            if (!currentObject[currentProperty]) {
                                var nextPropIsNumber = Number.isInteger(
                                    Number(segments[index + 1])
                                );
                                var nextPropIsArrayWildcard =
                                    segments[index + 1] === ARRAY_WILDCARD;

                                if (nextPropIsNumber || nextPropIsArrayWildcard) {
                                    currentObject[currentProperty] = [];
                                } else {
                                    currentObject[currentProperty] = {};
                                }
                            }

                            if (isLastSegment(segments, index)) {
                                currentObject[currentProperty] = value;
                            }

                            return currentObject[currentProperty];
                        }
                    );
                } catch (err) {
                    if (err instanceof ObjectPrototypeMutationError) {
                        // rethrow
                        throw err;
                    } else {
                        return object;
                    }
                }
            }
            /**
             * Tell if an object is on the path to a nested property
             * If the object is on the path, and the path exists, it returns true, and false otherwise.
             * @param {Object} object to get the nested property from
             * @param {String} property name of the nested property
             * @param {Object} objectInPath the object to check
             * @param {Object} options:
             *  - validPath: return false if the path is invalid, even if the object is in the path
             * @returns {boolean} true if the object is on the path
             */

            function isInNestedProperty(object, property, objectInPath) {
                var options =
                    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

                if (_typeof(object) != 'object' || object === null) {
                    return false;
                }

                if (typeof property == 'undefined') {
                    return false;
                }

                try {
                    var isIn = false,
                        pathExists = false;
                    traverse(
                        object,
                        property,
                        function _isInNestedProperty(
                            currentObject,
                            currentProperty,
                            segments,
                            index
                        ) {
                            isIn =
                                isIn ||
                                currentObject === objectInPath ||
                                (!!currentObject &&
                                    currentObject[currentProperty] === objectInPath);
                            pathExists =
                                isLastSegment(segments, index) &&
                                _typeof(currentObject) === 'object' &&
                                currentProperty in currentObject;
                            return currentObject && currentObject[currentProperty];
                        }
                    );

                    if (options.validPath) {
                        return isIn && pathExists;
                    } else {
                        return isIn;
                    }
                } catch (err) {
                    return false;
                }
            }

            function traverse(object, path) {
                var callback =
                    arguments.length > 2 && arguments[2] !== undefined
                        ? arguments[2]
                        : function () {};
                var segments = path.split(PATH_DELIMITER);
                var length = segments.length;

                var _loop = function _loop(idx) {
                    var currentSegment = segments[idx];

                    if (!object) {
                        return {
                            v: void 0
                        };
                    }

                    if (currentSegment === ARRAY_WILDCARD) {
                        if (Array.isArray(object)) {
                            return {
                                v: object.map(function (value, index) {
                                    var remainingSegments = segments.slice(idx + 1);

                                    if (remainingSegments.length > 0) {
                                        return traverse(
                                            value,
                                            remainingSegments.join(PATH_DELIMITER),
                                            callback
                                        );
                                    } else {
                                        return callback(object, index, segments, idx);
                                    }
                                })
                            };
                        } else {
                            var pathToHere = segments.slice(0, idx).join(PATH_DELIMITER);
                            throw new Error(
                                'Object at wildcard ('.concat(pathToHere, ') is not an array')
                            );
                        }
                    } else {
                        object = callback(object, currentSegment, segments, idx);
                    }
                };

                for (var idx = 0; idx < length; idx++) {
                    var _ret = _loop(idx);

                    if (_typeof(_ret) === 'object') return _ret.v;
                }

                return object;
            }

            function isLastSegment(segments, index) {
                return segments.length === index + 1;
            }

            /***/
        },
        /* 166 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.createWriteStream = exports.createReadStream = void 0;
            var stream_1 = __importDefault(__webpack_require__(14));
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            var NOOP = function () {};
            function createReadStream(context, filePath, options) {
                if (options === void 0) {
                    options = {};
                }
                var PassThroughStream = stream_1.default.PassThrough;
                var outStream = new PassThroughStream();
                getFileStream(context, filePath, options)
                    .then(function (stream) {
                        stream.pipe(outStream);
                    })
                    .catch(function (err) {
                        outStream.emit('error', err);
                    });
                return outStream;
            }
            exports.createReadStream = createReadStream;
            function createWriteStream(context, filePath, options, callback) {
                if (options === void 0) {
                    options = {};
                }
                if (callback === void 0) {
                    callback = NOOP;
                }
                var PassThroughStream = stream_1.default.PassThrough;
                var writeStream = new PassThroughStream();
                var headers = {};
                if (options.overwrite === false) {
                    headers['If-None-Match'] = '*';
                }
                var requestOptions = (0, request_1.prepareRequestOptions)(
                    {
                        url: (0, url_1.joinURL)(
                            context.remoteURL,
                            (0, path_1.encodePath)(filePath)
                        ),
                        method: 'PUT',
                        headers: headers,
                        data: writeStream,
                        maxRedirects: 0
                    },
                    context,
                    options
                );
                (0, request_1.request)(requestOptions)
                    .then(function (response) {
                        return (0, response_1.handleResponseCode)(context, response);
                    })
                    .then(function (response) {
                        // Fire callback asynchronously to avoid errors
                        setTimeout(function () {
                            callback(response);
                        }, 0);
                    })
                    .catch(function (err) {
                        writeStream.emit('error', err);
                    });
                return writeStream;
            }
            exports.createWriteStream = createWriteStream;
            function getFileStream(context, filePath, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var headers, rangeHeader, requestOptions, response, responseError;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                headers = {};
                                if (
                                    typeof options.range === 'object' &&
                                    typeof options.range.start === 'number'
                                ) {
                                    rangeHeader = 'bytes='.concat(options.range.start, '-');
                                    if (typeof options.range.end === 'number') {
                                        rangeHeader = ''
                                            .concat(rangeHeader)
                                            .concat(options.range.end);
                                    }
                                    headers.Range = rangeHeader;
                                }
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(filePath)
                                        ),
                                        method: 'GET',
                                        headers: headers,
                                        responseType: 'stream'
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                if (headers.Range && response.status !== 206) {
                                    responseError = new Error(
                                        'Invalid response code for partial request: '.concat(
                                            response.status
                                        )
                                    );
                                    responseError.status = response.status;
                                    throw responseError;
                                }
                                if (options.callback) {
                                    setTimeout(function () {
                                        options.callback(response);
                                    }, 0);
                                }
                                return [2 /*return*/, response.data];
                        }
                    });
                });
            }

            /***/
        },
        /* 167 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.customRequest = void 0;
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            function customRequest(context, remotePath, requestOptions) {
                return __awaiter(this, void 0, void 0, function () {
                    var finalOptions, response;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!requestOptions.url) {
                                    requestOptions.url = (0, url_1.joinURL)(
                                        context.remoteURL,
                                        (0, path_1.encodePath)(remotePath)
                                    );
                                }
                                finalOptions = (0, request_1.prepareRequestOptions)(
                                    requestOptions,
                                    context,
                                    {}
                                );
                                return [4 /*yield*/, (0, request_1.request)(finalOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [2 /*return*/, response];
                        }
                    });
                });
            }
            exports.customRequest = customRequest;

            /***/
        },
        /* 168 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.deleteFile = void 0;
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            function deleteFile(context, filename, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var requestOptions, response;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(filename)
                                        ),
                                        method: 'DELETE'
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [2 /*return*/];
                        }
                    });
                });
            }
            exports.deleteFile = deleteFile;

            /***/
        },
        /* 169 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.exists = void 0;
            var stat_1 = __webpack_require__(153);
            function exists(context, remotePath, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var err_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [
                                    4 /*yield*/,
                                    (0, stat_1.getStat)(context, remotePath, options)
                                ];
                            case 1:
                                _a.sent();
                                return [2 /*return*/, true];
                            case 2:
                                err_1 = _a.sent();
                                if (err_1.status === 404) {
                                    return [2 /*return*/, false];
                                }
                                throw err_1;
                            case 3:
                                return [2 /*return*/];
                        }
                    });
                });
            }
            exports.exists = exists;

            /***/
        },
        /* 170 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.getDirectoryContents = void 0;
            var path_posix_1 = __importDefault(__webpack_require__(56));
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var dav_1 = __webpack_require__(154);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            function getDirectoryContents(context, remotePath, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var requestOptions, response, davResp, files;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(remotePath),
                                            '/'
                                        ),
                                        method: 'PROPFIND',
                                        headers: {
                                            Accept: 'text/plain',
                                            Depth: options.deep ? 'infinity' : '1'
                                        },
                                        responseType: 'text'
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [4 /*yield*/, (0, dav_1.parseXML)(response.data)];
                            case 2:
                                davResp = _a.sent();
                                files = getDirectoryFiles(
                                    davResp,
                                    context.remotePath,
                                    remotePath,
                                    options.details
                                );
                                if (options.glob) {
                                    files = (0, response_1.processGlobFilter)(files, options.glob);
                                }
                                return [
                                    2 /*return*/,
                                    (0, response_1.processResponsePayload)(
                                        response,
                                        files,
                                        options.details
                                    )
                                ];
                        }
                    });
                });
            }
            exports.getDirectoryContents = getDirectoryContents;
            function getDirectoryFiles(result, serverBasePath, requestPath, isDetailed) {
                if (isDetailed === void 0) {
                    isDetailed = false;
                }
                var serverBase = path_posix_1.default.join(serverBasePath, '/');
                // Extract the response items (directory contents)
                var responseItems = result.multistatus.response;
                return (
                    responseItems
                        // Map all items to a consistent output structure (results)
                        .map(function (item) {
                            // HREF is the file path (in full)
                            var href = (0, url_1.normaliseHREF)(item.href);
                            // Each item should contain a stat object
                            var props = item.propstat.prop;
                            // Process the true full filename (minus the base server path)
                            var filename =
                                serverBase === '/'
                                    ? decodeURIComponent((0, path_1.normalisePath)(href))
                                    : decodeURIComponent(
                                          (0, path_1.normalisePath)(
                                              path_posix_1.default.relative(serverBase, href)
                                          )
                                      );
                            return (0, dav_1.prepareFileFromProps)(props, filename, isDetailed);
                        })
                        // Filter out the item pointing to the current directory (not needed)
                        .filter(function (item) {
                            return (
                                item.basename &&
                                (item.type === 'file' ||
                                    item.filename !== requestPath.replace(/\/$/, ''))
                            );
                        })
                );
            }

            /***/
        },
        /* 171 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.getFileDownloadLink = exports.getFileContents = void 0;
            var layerr_1 = __webpack_require__(58);
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var encode_1 = __webpack_require__(70);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            var types_1 = __webpack_require__(74);
            var TRANSFORM_RETAIN_FORMAT = function (v) {
                return v;
            };
            function getFileContents(context, filePath, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var _a, format;
                    return __generator(this, function (_b) {
                        (_a = options.format), (format = _a === void 0 ? 'binary' : _a);
                        if (format !== 'binary' && format !== 'text') {
                            throw new layerr_1.Layerr(
                                {
                                    info: {
                                        code: types_1.ErrorCode.InvalidOutputFormat
                                    }
                                },
                                'Invalid output format: '.concat(format)
                            );
                        }
                        return [
                            2 /*return*/,
                            format === 'text'
                                ? getFileContentsString(context, filePath, options)
                                : getFileContentsBuffer(context, filePath, options)
                        ];
                    });
                });
            }
            exports.getFileContents = getFileContents;
            function getFileContentsBuffer(context, filePath, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var requestOptions, response;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(filePath)
                                        ),
                                        method: 'GET',
                                        responseType: 'arraybuffer'
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [
                                    2 /*return*/,
                                    (0, response_1.processResponsePayload)(
                                        response,
                                        response.data,
                                        options.details
                                    )
                                ];
                        }
                    });
                });
            }
            function getFileContentsString(context, filePath, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var requestOptions, response;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(filePath)
                                        ),
                                        method: 'GET',
                                        responseType: 'text',
                                        transformResponse: [TRANSFORM_RETAIN_FORMAT]
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [
                                    2 /*return*/,
                                    (0, response_1.processResponsePayload)(
                                        response,
                                        response.data,
                                        options.details
                                    )
                                ];
                        }
                    });
                });
            }
            function getFileDownloadLink(context, filePath) {
                var url = (0, url_1.joinURL)(context.remoteURL, (0, path_1.encodePath)(filePath));
                var protocol = /^https:/i.test(url) ? 'https' : 'http';
                switch (context.authType) {
                    case types_1.AuthType.None:
                        // Do nothing
                        break;
                    case types_1.AuthType.Password: {
                        var authPart = context.headers.Authorization.replace(/^Basic /i, '').trim();
                        var authContents = (0, encode_1.fromBase64)(authPart);
                        url = url.replace(
                            /^https?:\/\//,
                            ''.concat(protocol, '://').concat(authContents, '@')
                        );
                        break;
                    }
                    default:
                        throw new layerr_1.Layerr(
                            {
                                info: {
                                    code: types_1.ErrorCode.LinkUnsupportedAuthType
                                }
                            },
                            'Unsupported auth type for file link: '.concat(context.authType)
                        );
                }
                return url;
            }
            exports.getFileDownloadLink = getFileDownloadLink;

            /***/
        },
        /* 172 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.unlock = exports.lock = void 0;
            var nested_property_1 = __importDefault(__webpack_require__(165));
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var xml_1 = __webpack_require__(173);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            var DEFAULT_TIMEOUT = 'Infinite, Second-4100000000';
            function lock(context, path, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var refreshToken,
                        _a,
                        timeout,
                        headers,
                        requestOptions,
                        response,
                        lockPayload,
                        token,
                        serverTimeout,
                        err;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                (refreshToken = options.refreshToken),
                                    (_a = options.timeout),
                                    (timeout = _a === void 0 ? DEFAULT_TIMEOUT : _a);
                                headers = {
                                    Accept: 'text/plain,application/xml',
                                    Timeout: timeout
                                };
                                if (refreshToken) {
                                    headers.If = refreshToken;
                                }
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(path)
                                        ),
                                        method: 'LOCK',
                                        headers: headers,
                                        data: (0, xml_1.generateLockXML)(context.contactHref),
                                        responseType: 'text'
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _b.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                lockPayload = (0, xml_1.parseGenericResponse)(response.data);
                                token = nested_property_1.default.get(
                                    lockPayload,
                                    'prop.lockdiscovery.activelock.locktoken.href'
                                );
                                serverTimeout = nested_property_1.default.get(
                                    lockPayload,
                                    'prop.lockdiscovery.activelock.timeout'
                                );
                                if (!token) {
                                    err = (0, response_1.createErrorFromResponse)(
                                        response,
                                        'No lock token received: '
                                    );
                                    throw err;
                                }
                                return [
                                    2 /*return*/,
                                    {
                                        token: token,
                                        serverTimeout: serverTimeout
                                    }
                                ];
                        }
                    });
                });
            }
            exports.lock = lock;
            function unlock(context, path, token, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var requestOptions, response, err;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(path)
                                        ),
                                        method: 'UNLOCK',
                                        headers: {
                                            'Lock-Token': token
                                        }
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                if (response.status !== 204 && response.status !== 200) {
                                    err = (0, response_1.createErrorFromResponse)(response);
                                    throw err;
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            }
            exports.unlock = unlock;

            /***/
        },
        /* 173 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __assign =
                (this && this.__assign) ||
                function () {
                    __assign =
                        Object.assign ||
                        function (t) {
                            for (var s, i = 1, n = arguments.length; i < n; i++) {
                                s = arguments[i];
                                for (var p in s)
                                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                            }
                            return t;
                        };
                    return __assign.apply(this, arguments);
                };
            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          var desc = Object.getOwnPropertyDescriptor(m, k);
                          if (
                              !desc ||
                              ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
                          ) {
                              desc = {
                                  enumerable: true,
                                  get: function () {
                                      return m[k];
                                  }
                              };
                          }
                          Object.defineProperty(o, k2, desc);
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, 'default', { enumerable: true, value: v });
                      }
                    : function (o, v) {
                          o['default'] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.parseGenericResponse = exports.generateLockXML = void 0;
            var fast_xml_parser_1 = __importStar(__webpack_require__(155));
            function generateLockXML(ownerHREF) {
                return getParser().parse(
                    namespace(
                        {
                            lockinfo: {
                                '@_xmlns:d': 'DAV:',
                                lockscope: {
                                    exclusive: {}
                                },
                                locktype: {
                                    write: {}
                                },
                                owner: {
                                    href: ownerHREF
                                }
                            }
                        },
                        'd'
                    )
                );
            }
            exports.generateLockXML = generateLockXML;
            function getParser() {
                return new fast_xml_parser_1.j2xParser({
                    attributeNamePrefix: '@_',
                    format: true,
                    ignoreAttributes: false,
                    supressEmptyNode: true
                });
            }
            function namespace(obj, ns) {
                var copy = __assign({}, obj);
                for (var key in copy) {
                    if (!copy.hasOwnProperty(key)) {
                        continue;
                    }
                    if (copy[key] && typeof copy[key] === 'object' && key.indexOf(':') === -1) {
                        copy[''.concat(ns, ':').concat(key)] = namespace(copy[key], ns);
                        delete copy[key];
                    } else if (/^@_/.test(key) === false) {
                        copy[''.concat(ns, ':').concat(key)] = copy[key];
                        delete copy[key];
                    }
                }
                return copy;
            }
            function parseGenericResponse(xml) {
                return fast_xml_parser_1.default.parse(xml, {
                    arrayMode: false,
                    ignoreNameSpace: true,
                    parseAttributeValue: true,
                    parseNodeValue: true
                });
            }
            exports.parseGenericResponse = parseGenericResponse;

            /***/
        },
        /* 174 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.getQuota = void 0;
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            var dav_1 = __webpack_require__(154);
            var url_1 = __webpack_require__(50);
            var quota_1 = __webpack_require__(175);
            function getQuota(context, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var path, requestOptions, response, result, quota;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                path = options.path || '/';
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(context.remoteURL, path),
                                        method: 'PROPFIND',
                                        headers: {
                                            Accept: 'text/plain',
                                            Depth: '0'
                                        },
                                        responseType: 'text'
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [4 /*yield*/, (0, dav_1.parseXML)(response.data)];
                            case 2:
                                result = _a.sent();
                                quota = (0, quota_1.parseQuota)(result);
                                return [
                                    2 /*return*/,
                                    (0, response_1.processResponsePayload)(
                                        response,
                                        quota,
                                        options.details
                                    )
                                ];
                        }
                    });
                });
            }
            exports.getQuota = getQuota;

            /***/
        },
        /* 175 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.parseQuota = void 0;
            var dav_1 = __webpack_require__(154);
            function parseQuota(result) {
                try {
                    var responseItem = result.multistatus.response[0];
                    var _a = responseItem.propstat.prop,
                        quotaUsed = _a['quota-used-bytes'],
                        quotaAvail = _a['quota-available-bytes'];
                    return typeof quotaUsed !== 'undefined' && typeof quotaAvail !== 'undefined'
                        ? {
                              used: parseInt(quotaUsed, 10),
                              available: (0, dav_1.translateDiskSpace)(quotaAvail)
                          }
                        : null;
                } catch (err) {
                    /* ignore */
                }
                return null;
            }
            exports.parseQuota = parseQuota;

            /***/
        },
        /* 176 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.moveFile = void 0;
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            function moveFile(context, filename, destination, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var requestOptions, response;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(filename)
                                        ),
                                        method: 'MOVE',
                                        headers: {
                                            Destination: (0, url_1.joinURL)(
                                                context.remoteURL,
                                                (0, path_1.encodePath)(destination)
                                            )
                                        }
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _a.sent();
                                (0, response_1.handleResponseCode)(context, response);
                                return [2 /*return*/];
                        }
                    });
                });
            }
            exports.moveFile = moveFile;

            /***/
        },
        /* 177 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __awaiter =
                (this && this.__awaiter) ||
                function (thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P
                            ? value
                            : new P(function (resolve) {
                                  resolve(value);
                              });
                    }
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator['throw'](value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            result.done
                                ? resolve(result.value)
                                : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
            var __generator =
                (this && this.__generator) ||
                function (thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function () {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f,
                        y,
                        t,
                        g;
                    return (
                        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                        typeof Symbol === 'function' &&
                            (g[Symbol.iterator] = function () {
                                return this;
                            }),
                        g
                    );
                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }
                    function step(op) {
                        if (f) throw new TypeError('Generator is already executing.');
                        while (_)
                            try {
                                if (
                                    ((f = 1),
                                    y &&
                                        (t =
                                            op[0] & 2
                                                ? y['return']
                                                : op[0]
                                                ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                                                : y.next) &&
                                        !(t = t.call(y, op[1])).done)
                                )
                                    return t;
                                if (((y = 0), t)) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (
                                            !((t = _.trys),
                                            (t = t.length > 0 && t[t.length - 1])) &&
                                            (op[0] === 6 || op[0] === 2)
                                        ) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        if (op[0] & 5) throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
            var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                    return mod && mod.__esModule ? mod : { default: mod };
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.getFileUploadLink = exports.putFileContents = void 0;
            var layerr_1 = __webpack_require__(58);
            var stream_1 = __importDefault(__webpack_require__(14));
            var encode_1 = __webpack_require__(70);
            var url_1 = __webpack_require__(50);
            var path_1 = __webpack_require__(55);
            var request_1 = __webpack_require__(76);
            var response_1 = __webpack_require__(147);
            var size_1 = __webpack_require__(178);
            var types_1 = __webpack_require__(74);
            function putFileContents(context, filePath, data, options) {
                if (options === void 0) {
                    options = {};
                }
                return __awaiter(this, void 0, void 0, function () {
                    var _a, contentLength, _b, overwrite, headers, requestOptions, response, error;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                (_a = options.contentLength),
                                    (contentLength = _a === void 0 ? true : _a),
                                    (_b = options.overwrite),
                                    (overwrite = _b === void 0 ? true : _b);
                                headers = {
                                    'Content-Type': 'application/octet-stream'
                                };
                                if (
                                    typeof WEB === 'undefined' &&
                                    typeof stream_1.default !== 'undefined' &&
                                    typeof (stream_1.default === null || stream_1.default === void 0
                                        ? void 0
                                        : stream_1.default.Readable) !== 'undefined' &&
                                    data instanceof stream_1.default.Readable
                                ) {
                                    // Skip, no content-length
                                } else if (contentLength === false) {
                                    // Skip, disabled
                                } else if (typeof contentLength === 'number') {
                                    headers['Content-Length'] = ''.concat(contentLength);
                                } else {
                                    headers['Content-Length'] = ''.concat(
                                        (0, size_1.calculateDataLength)(data)
                                    );
                                }
                                if (!overwrite) {
                                    headers['If-None-Match'] = '*';
                                }
                                requestOptions = (0, request_1.prepareRequestOptions)(
                                    {
                                        url: (0, url_1.joinURL)(
                                            context.remoteURL,
                                            (0, path_1.encodePath)(filePath)
                                        ),
                                        method: 'PUT',
                                        headers: headers,
                                        data: data
                                    },
                                    context,
                                    options
                                );
                                return [4 /*yield*/, (0, request_1.request)(requestOptions)];
                            case 1:
                                response = _c.sent();
                                try {
                                    (0, response_1.handleResponseCode)(context, response);
                                } catch (err) {
                                    error = err;
                                    if (error.status === 412 && !overwrite) {
                                        return [2 /*return*/, false];
                                    } else {
                                        throw error;
                                    }
                                }
                                return [2 /*return*/, true];
                        }
                    });
                });
            }
            exports.putFileContents = putFileContents;
            function getFileUploadLink(context, filePath) {
                var url = ''.concat(
                    (0, url_1.joinURL)(context.remoteURL, (0, path_1.encodePath)(filePath)),
                    '?Content-Type=application/octet-stream'
                );
                var protocol = /^https:/i.test(url) ? 'https' : 'http';
                switch (context.authType) {
                    case types_1.AuthType.None:
                        // Do nothing
                        break;
                    case types_1.AuthType.Password: {
                        var authPart = context.headers.Authorization.replace(/^Basic /i, '').trim();
                        var authContents = (0, encode_1.fromBase64)(authPart);
                        url = url.replace(
                            /^https?:\/\//,
                            ''.concat(protocol, '://').concat(authContents, '@')
                        );
                        break;
                    }
                    default:
                        throw new layerr_1.Layerr(
                            {
                                info: {
                                    code: types_1.ErrorCode.LinkUnsupportedAuthType
                                }
                            },
                            'Unsupported auth type for file link: '.concat(context.authType)
                        );
                }
                return url;
            }
            exports.getFileUploadLink = getFileUploadLink;

            /***/
        },
        /* 178 */
        /***/ (__unused_webpack_module, exports, __webpack_require__) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.calculateDataLength = void 0;
            var layerr_1 = __webpack_require__(58);
            var byte_length_1 = __webpack_require__(179);
            var arrayBuffer_1 = __webpack_require__(180);
            var buffer_1 = __webpack_require__(181);
            var types_1 = __webpack_require__(74);
            function calculateDataLength(data) {
                if ((0, arrayBuffer_1.isArrayBuffer)(data)) {
                    return data.byteLength;
                } else if ((0, buffer_1.isBuffer)(data)) {
                    return data.length;
                } else if (typeof data === 'string') {
                    return (0, byte_length_1.byteLength)(data);
                }
                throw new layerr_1.Layerr(
                    {
                        info: {
                            code: types_1.ErrorCode.DataTypeNoLength
                        }
                    },
                    'Cannot calculate data length: Invalid type'
                );
            }
            exports.calculateDataLength = calculateDataLength;

            /***/
        },
        /* 179 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            /*
             * Calculate the byte lengths for utf8 encoded strings.
             */
            function byteLength(str) {
                if (!str) {
                    return 0;
                }
                str = str.toString();
                var len = str.length;
                for (var i = str.length; i--; ) {
                    var code = str.charCodeAt(i);
                    if (0xdc00 <= code && code <= 0xdfff) {
                        i--;
                    }
                    if (0x7f < code && code <= 0x7ff) {
                        len++;
                    } else if (0x7ff < code && code <= 0xffff) {
                        len += 2;
                    }
                }
                return len;
            }
            exports.byteLength = byteLength;
            //# sourceMappingURL=index.js.map

            /***/
        },
        /* 180 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.isArrayBuffer = void 0;
            var hasArrayBuffer = typeof ArrayBuffer === 'function';
            var objToString = Object.prototype.toString;
            // Taken from: https://github.com/fengyuanchen/is-array-buffer/blob/master/src/index.js
            function isArrayBuffer(value) {
                return (
                    hasArrayBuffer &&
                    (value instanceof ArrayBuffer ||
                        objToString.call(value) === '[object ArrayBuffer]')
                );
            }
            exports.isArrayBuffer = isArrayBuffer;

            /***/
        },
        /* 181 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.isBuffer = void 0;
            function isBuffer(value) {
                return (
                    value != null &&
                    value.constructor != null &&
                    typeof value.constructor.isBuffer === 'function' &&
                    value.constructor.isBuffer(value)
                );
            }
            exports.isBuffer = isBuffer;

            /***/
        },
        /* 182 */
        /***/ function (__unused_webpack_module, exports, __webpack_require__) {
            'use strict';

            var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                    ? function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          var desc = Object.getOwnPropertyDescriptor(m, k);
                          if (
                              !desc ||
                              ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
                          ) {
                              desc = {
                                  enumerable: true,
                                  get: function () {
                                      return m[k];
                                  }
                              };
                          }
                          Object.defineProperty(o, k2, desc);
                      }
                    : function (o, m, k, k2) {
                          if (k2 === undefined) k2 = k;
                          o[k2] = m[k];
                      });
            var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                    ? function (o, v) {
                          Object.defineProperty(o, 'default', { enumerable: true, value: v });
                      }
                    : function (o, v) {
                          o['default'] = v;
                      });
            var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                    if (mod && mod.__esModule) return mod;
                    var result = {};
                    if (mod != null)
                        for (var k in mod)
                            if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
                                __createBinding(result, mod, k);
                    __setModuleDefault(result, mod);
                    return result;
                };
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.TOCProvider = void 0;
            const vscode = __importStar(__webpack_require__(1));
            const path = __importStar(__webpack_require__(4));
            const tocs_1 = __webpack_require__(183);
            class TOCProvider {
                constructor(context) {
                    this._onDidChangeTreeData = new vscode.EventEmitter();
                    this.onDidChangeTreeData = this._onDidChangeTreeData.event;
                    const view = vscode.window.createTreeView('snippet-cat-outline', {
                        treeDataProvider: this
                    });
                    context.subscriptions.push(view);
                    this.languageID = vscode.window.activeTextEditor?.document.languageId;
                }
                getChildren(element) {
                    const editor = vscode.window.activeTextEditor;
                    let documentText;
                    if (editor) {
                        documentText = editor.document.getText();
                        if (this.languageID === 'markdown') {
                            return Promise.resolve((0, tocs_1.getMarkdownInfo)(documentText));
                        }
                    } else {
                        documentText = '';
                    }
                    return Promise.resolve((0, tocs_1.getFunInfo)(documentText));
                }
                getTreeItem(element) {
                    const treeItem = this._getTreeItem(element);
                    return treeItem;
                }
                _getTreeItem(element) {
                    const treeElement = this._getTreeElement(element);
                    return new TOCItem(
                        treeElement,
                        treeElement.name,
                        true ? vscode.TreeItemCollapsibleState.None : 0,
                        this.languageID
                    );
                }
                _getTreeElement(element) {
                    return element;
                }
                // Element 列表
                // _getChildren(folderPath: string): TOCElement[] {
                // }
                async refresh() {
                    this.languageID = vscode.window.activeTextEditor?.document.languageId;
                    this._onDidChangeTreeData.fire(undefined);
                }
                // 单击大纲 移动到对应函数上面2行 并选中
                // ref:// https://code.visualstudio.com/api/references/commands
                async click(element) {
                    let editor = vscode.window.activeTextEditor;
                    editor.selection = new vscode.Selection(
                        element.line,
                        0,
                        element.line + element.length,
                        0
                    );
                    await vscode.commands
                        .executeCommand('revealLine', {
                            at: 'top',
                            lineNumber: element.line - 2 < 0 ? element.line : element.line - 2
                        })
                        .then(() => {
                            vscode.commands
                                .executeCommand('workbench.action.navigateToLastEditLocation')
                                .then(() => {
                                    editor.selection = new vscode.Selection(
                                        element.line,
                                        0,
                                        element.line + element.length,
                                        0
                                    );
                                });
                        });
                }
                copy(element) {
                    this.click(element);
                    vscode.commands.executeCommand('editor.action.clipboardCopyAction');
                }
            }
            exports.TOCProvider = TOCProvider;
            class TOCItem extends vscode.TreeItem {
                constructor(element, label, collapsibleState, languageID) {
                    super(label, collapsibleState);
                    this.label = element.name;
                    this.tooltip = element.description;
                    this.contextValue = 'Title';
                    let icon = languageID === 'markdown' ? 'markdown' : 'function';
                    if (this.contextValue === 'Title') {
                        this.command = {
                            title: 'Item Command',
                            command: 'snippet-cat.outline.click',
                            arguments: [element]
                        };
                    }
                    this.iconPath = {
                        light: path.join(
                            __filename,
                            '..',
                            '..',
                            'media',
                            'icons',
                            'interface',
                            'light',
                            `${icon}.svg`
                        ),
                        dark: path.join(
                            __filename,
                            '..',
                            '..',
                            'media',
                            'icons',
                            'interface',
                            'dark',
                            `${icon}.svg`
                        )
                    };
                }
            }

            /***/
        },
        /* 183 */
        /***/ (__unused_webpack_module, exports) => {
            'use strict';

            Object.defineProperty(exports, '__esModule', { value: true });
            exports.getMarkdownInfo = exports.getFunInfo = exports.TOCElement = void 0;
            class TOCElement {
                constructor(name, description, line, length) {
                    {
                        this.name = name;
                        this.description = description;
                        this.line = line;
                        this.length = length;
                    }
                }
            }
            exports.TOCElement = TOCElement;
            function getRegContens(reg, content) {
                let res = [];
                let m;
                while ((m = reg.exec(content)) !== null) {
                    if (m.index === reg.lastIndex) {
                        reg.lastIndex++;
                    }
                    res.push(m[0]);
                }
                return res;
            }
            function getFunInfo(documentText) {
                let mStart, mContent, mSpace;
                const regStart = /(.+\s|\s)*?.+@start/;
                const regContent = /(?<=@start\s)(.+\s|\s)+?(?=.+@end)/gm;
                const regSpace = /(.+@end\s)(.*\s|\s)*?.*@start/gm;
                mStart = regStart.exec(documentText) !== null ? regStart.exec(documentText)[0] : '';
                mContent = getRegContens(regContent, documentText);
                mSpace = getRegContens(regSpace, documentText);
                let rrr = [];
                const sLineNumber = mStart.split('\n').length;
                let contentLineNumber = 0;
                let spaceLineNumber = 0;
                for (var i = 0, j = mContent.length; i < j; i++) {
                    const mc = mContent[i];
                    const ms = mSpace[i];
                    const currentLineNumbers = mc.split('\n').length;
                    let name = /(?<=@name:).+/.exec(mc);
                    let des = /(?<=@description:).+/.exec(mc);
                    name = name === null ? `未命名函数 ${i + 1}` : name[0];
                    des = des === null ? `暂无描述` : des[0];
                    // + 2 是去掉2行注释, -4是去掉2行注释和首尾标记
                    rrr.push(
                        new TOCElement(
                            name,
                            des,
                            sLineNumber + contentLineNumber + spaceLineNumber + 2,
                            currentLineNumbers - 4
                        )
                    );
                    contentLineNumber += currentLineNumbers;
                    spaceLineNumber += ms === undefined ? 0 : ms.split('\n').length - 2;
                }
                return rrr;
            }
            exports.getFunInfo = getFunInfo;
            function getMarkdownInfo(documentText) {
                const regMarkdown = /(?<=(^##)\s).*/gm;
                let mRes = getRegContens(regMarkdown, documentText);
                let rrr = [];
                mRes.forEach((ma) => {
                    rrr.push(new TOCElement(ma, ma, 1, 1));
                });
                return rrr;
            }
            exports.getMarkdownInfo = getMarkdownInfo;

            /***/
        },
        /* 184 */
        /***/ (module) => {
            'use strict';
            module.exports = JSON.parse(
                '{"snippet-cat-title":"Snippet Cat","snippet-cat-view-name":"Collections","snippet-cat-outline-name":"Outline","snippet-cat.lastFileExt":"Default extname when add snippet ","snippet-cat.syncModel1":"Please set webdav setting","snippet-cat.syncModel2":"Use github to sync","snippet-cat.github-pull":"custom pull command","snippet-cat.github-push":"custom push command","snippet-cat.github":"use \'|\' to split commands","snippet-cat.webdav-url":"WebDAV Url","snippet-cat.webdav-username":"username","snippet-cat.webdav-password":"Password","snippet-cat.webdav":"WEBDAV Setting","snippet-cat.stockPath":"StockPath","snippet-cat.main.search":"Search","snippet-cat.main.viewSwitch":"Switch View","snippet-cat.main.download":"Download","snippet-cat.main.upload":"Upload","snippet-cat.main.refresh":"Refresh","snippet-cat.main.addStockPath":"Add Stock Path","snippet-cat.main.addGroup":"Add Group","snippet-cat.main.editGroup":"Edit Group","snippet-cat.main.deleteGroup":"Delete Group","snippet-cat.main.openGroup":"Open in System File Explorer","snippet-cat.main.addSnippet":"Add Snippet","snippet-cat.main.editSnippet":"Edit Snippet","snippet-cat.main.deleteSnippet":"Delete Snippet","snippet-cat.outline.refresh":"Refresh","snippet-cat.outline.copy":"Copy"}'
            );

            /***/
        },
        /* 185 */
        /***/ (module) => {
            'use strict';
            module.exports = {};

            /***/
        }
        /******/
    ];
    /************************************************************************/
    /******/ // The module cache
    /******/ var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/ function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/ var cachedModule = __webpack_module_cache__[moduleId];
        /******/ if (cachedModule !== undefined) {
            /******/ return cachedModule.exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/ var module = (__webpack_module_cache__[moduleId] = {
            /******/ id: moduleId,
            /******/ loaded: false,
            /******/ exports: {}
            /******/
        });
        /******/
        /******/ // Execute the module function
        /******/ __webpack_modules__[moduleId].call(
            module.exports,
            module,
            module.exports,
            __webpack_require__
        );
        /******/
        /******/ // Flag the module as loaded
        /******/ module.loaded = true;
        /******/
        /******/ // Return the exports of the module
        /******/ return module.exports;
        /******/
    }
    /******/
    /************************************************************************/
    /******/ /* webpack/runtime/node module decorator */
    /******/ (() => {
        /******/ __webpack_require__.nmd = (module) => {
            /******/ module.paths = [];
            /******/ if (!module.children) module.children = [];
            /******/ return module;
            /******/
        };
        /******/
    })();
    /******/
    /************************************************************************/
    /******/
    /******/ // startup
    /******/ // Load entry module and return exports
    /******/ // This entry module is referenced by other modules so it can't be inlined
    /******/ var __webpack_exports__ = __webpack_require__(0);
    /******/ module.exports = __webpack_exports__;
    /******/
    /******/
})();
//# sourceMappingURL=extension.js.map
